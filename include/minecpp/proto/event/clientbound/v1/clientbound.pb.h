// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minecpp/proto/event/clientbound/v1/clientbound.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <minecpp/proto/common/v1/common.pb.h>
#include <minecpp/proto/player/v1/id.pb.h>
#include <minecpp/proto/player/v1/player.pb.h>
#include <minecpp/proto/entity/v1/entity.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
namespace minecpp {
namespace proto {
namespace event {
namespace clientbound {
namespace v1 {
class AcceptPlayer;
struct AcceptPlayerDefaultTypeInternal;
extern AcceptPlayerDefaultTypeInternal _AcceptPlayer_default_instance_;
class AddPlayer;
struct AddPlayerDefaultTypeInternal;
extern AddPlayerDefaultTypeInternal _AddPlayer_default_instance_;
class AnimateHand;
struct AnimateHandDefaultTypeInternal;
extern AnimateHandDefaultTypeInternal _AnimateHand_default_instance_;
class Chat;
struct ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class DenyPlayer;
struct DenyPlayerDefaultTypeInternal;
extern DenyPlayerDefaultTypeInternal _DenyPlayer_default_instance_;
class EntityList;
struct EntityListDefaultTypeInternal;
extern EntityListDefaultTypeInternal _EntityList_default_instance_;
class EntityLook;
struct EntityLookDefaultTypeInternal;
extern EntityLookDefaultTypeInternal _EntityLook_default_instance_;
class EntityMove;
struct EntityMoveDefaultTypeInternal;
extern EntityMoveDefaultTypeInternal _EntityMove_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class LoadTerrain;
struct LoadTerrainDefaultTypeInternal;
extern LoadTerrainDefaultTypeInternal _LoadTerrain_default_instance_;
class PlayerList;
struct PlayerListDefaultTypeInternal;
extern PlayerListDefaultTypeInternal _PlayerList_default_instance_;
class PlayerPositionRotation;
struct PlayerPositionRotationDefaultTypeInternal;
extern PlayerPositionRotationDefaultTypeInternal _PlayerPositionRotation_default_instance_;
class RecipientAllPlayers;
struct RecipientAllPlayersDefaultTypeInternal;
extern RecipientAllPlayersDefaultTypeInternal _RecipientAllPlayers_default_instance_;
class RecipientMultiplePlayers;
struct RecipientMultiplePlayersDefaultTypeInternal;
extern RecipientMultiplePlayersDefaultTypeInternal _RecipientMultiplePlayers_default_instance_;
class RecipientSinglePlayer;
struct RecipientSinglePlayerDefaultTypeInternal;
extern RecipientSinglePlayerDefaultTypeInternal _RecipientSinglePlayer_default_instance_;
class RemovePlayer;
struct RemovePlayerDefaultTypeInternal;
extern RemovePlayerDefaultTypeInternal _RemovePlayer_default_instance_;
class SpawnPlayer;
struct SpawnPlayerDefaultTypeInternal;
extern SpawnPlayerDefaultTypeInternal _SpawnPlayer_default_instance_;
class TransferPlayer;
struct TransferPlayerDefaultTypeInternal;
extern TransferPlayerDefaultTypeInternal _TransferPlayer_default_instance_;
class UnloadChunk;
struct UnloadChunkDefaultTypeInternal;
extern UnloadChunkDefaultTypeInternal _UnloadChunk_default_instance_;
class UpdateBlock;
struct UpdateBlockDefaultTypeInternal;
extern UpdateBlockDefaultTypeInternal _UpdateBlock_default_instance_;
class UpdatePlayerAbilities;
struct UpdatePlayerAbilitiesDefaultTypeInternal;
extern UpdatePlayerAbilitiesDefaultTypeInternal _UpdatePlayerAbilities_default_instance_;
}  // namespace v1
}  // namespace clientbound
}  // namespace event
}  // namespace proto
}  // namespace minecpp
PROTOBUF_NAMESPACE_OPEN
template<> ::minecpp::proto::event::clientbound::v1::AcceptPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::AcceptPlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::AddPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::AddPlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::AnimateHand* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::AnimateHand>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::Chat* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::Chat>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::DenyPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::DenyPlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::EntityList* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::EntityList>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::EntityLook* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::EntityLook>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::EntityMove* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::EntityMove>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::Event* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::Event>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::LoadTerrain* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::LoadTerrain>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::PlayerList* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::PlayerList>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::PlayerPositionRotation* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::PlayerPositionRotation>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::RecipientAllPlayers>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::RemovePlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::RemovePlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::SpawnPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::SpawnPlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::TransferPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::TransferPlayer>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::UnloadChunk* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::UnloadChunk>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::UpdateBlock* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::UpdateBlock>(Arena*);
template<> ::minecpp::proto::event::clientbound::v1::UpdatePlayerAbilities* Arena::CreateMaybeMessage<::minecpp::proto::event::clientbound::v1::UpdatePlayerAbilities>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minecpp {
namespace proto {
namespace event {
namespace clientbound {
namespace v1 {

// ===================================================================

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  enum RecipientCase {
    kSinglePlayer = 2,
    kMultiplePlayers = 3,
    kAllPlayers = 4,
    RECIPIENT_NOT_SET = 0,
  };

  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return new Event();
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
    kSinglePlayerFieldNumber = 2,
    kMultiplePlayersFieldNumber = 3,
    kAllPlayersFieldNumber = 4,
  };
  // .google.protobuf.Any payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const PROTOBUF_NAMESPACE_ID::Any& payload() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Any* release_payload();
  PROTOBUF_NAMESPACE_ID::Any* mutable_payload();
  void set_allocated_payload(PROTOBUF_NAMESPACE_ID::Any* payload);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_payload() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      PROTOBUF_NAMESPACE_ID::Any* payload);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_payload();

  // .minecpp.proto.event.clientbound.v1.RecipientSinglePlayer single_player = 2;
  bool has_single_player() const;
  private:
  bool _internal_has_single_player() const;
  public:
  void clear_single_player();
  const ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer& single_player() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* release_single_player();
  ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* mutable_single_player();
  void set_allocated_single_player(::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* single_player);
  private:
  const ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer& _internal_single_player() const;
  ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* _internal_mutable_single_player();
  public:
  void unsafe_arena_set_allocated_single_player(
      ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* single_player);
  ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* unsafe_arena_release_single_player();

  // .minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers multiple_players = 3;
  bool has_multiple_players() const;
  private:
  bool _internal_has_multiple_players() const;
  public:
  void clear_multiple_players();
  const ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers& multiple_players() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* release_multiple_players();
  ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* mutable_multiple_players();
  void set_allocated_multiple_players(::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* multiple_players);
  private:
  const ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers& _internal_multiple_players() const;
  ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* _internal_mutable_multiple_players();
  public:
  void unsafe_arena_set_allocated_multiple_players(
      ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* multiple_players);
  ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* unsafe_arena_release_multiple_players();

  // .minecpp.proto.event.clientbound.v1.RecipientAllPlayers all_players = 4;
  bool has_all_players() const;
  private:
  bool _internal_has_all_players() const;
  public:
  void clear_all_players();
  const ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers& all_players() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* release_all_players();
  ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* mutable_all_players();
  void set_allocated_all_players(::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* all_players);
  private:
  const ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers& _internal_all_players() const;
  ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* _internal_mutable_all_players();
  public:
  void unsafe_arena_set_allocated_all_players(
      ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* all_players);
  ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* unsafe_arena_release_all_players();

  void clear_recipient();
  RecipientCase recipient_case() const;
  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.Event)
 private:
  class _Internal;
  void set_has_single_player();
  void set_has_multiple_players();
  void set_has_all_players();

  inline bool has_recipient() const;
  inline void clear_has_recipient();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Any* payload_;
  union RecipientUnion {
    constexpr RecipientUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* single_player_;
    ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* multiple_players_;
    ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* all_players_;
  } recipient_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class RecipientSinglePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer) */ {
 public:
  inline RecipientSinglePlayer() : RecipientSinglePlayer(nullptr) {}
  ~RecipientSinglePlayer() override;
  explicit constexpr RecipientSinglePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecipientSinglePlayer(const RecipientSinglePlayer& from);
  RecipientSinglePlayer(RecipientSinglePlayer&& from) noexcept
    : RecipientSinglePlayer() {
    *this = ::std::move(from);
  }

  inline RecipientSinglePlayer& operator=(const RecipientSinglePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecipientSinglePlayer& operator=(RecipientSinglePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecipientSinglePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecipientSinglePlayer* internal_default_instance() {
    return reinterpret_cast<const RecipientSinglePlayer*>(
               &_RecipientSinglePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RecipientSinglePlayer& a, RecipientSinglePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(RecipientSinglePlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecipientSinglePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecipientSinglePlayer* New() const final {
    return new RecipientSinglePlayer();
  }

  RecipientSinglePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecipientSinglePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecipientSinglePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecipientSinglePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecipientSinglePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.RecipientSinglePlayer";
  }
  protected:
  explicit RecipientSinglePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class RecipientMultiplePlayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers) */ {
 public:
  inline RecipientMultiplePlayers() : RecipientMultiplePlayers(nullptr) {}
  ~RecipientMultiplePlayers() override;
  explicit constexpr RecipientMultiplePlayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecipientMultiplePlayers(const RecipientMultiplePlayers& from);
  RecipientMultiplePlayers(RecipientMultiplePlayers&& from) noexcept
    : RecipientMultiplePlayers() {
    *this = ::std::move(from);
  }

  inline RecipientMultiplePlayers& operator=(const RecipientMultiplePlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecipientMultiplePlayers& operator=(RecipientMultiplePlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecipientMultiplePlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecipientMultiplePlayers* internal_default_instance() {
    return reinterpret_cast<const RecipientMultiplePlayers*>(
               &_RecipientMultiplePlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RecipientMultiplePlayers& a, RecipientMultiplePlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(RecipientMultiplePlayers* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecipientMultiplePlayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecipientMultiplePlayers* New() const final {
    return new RecipientMultiplePlayers();
  }

  RecipientMultiplePlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecipientMultiplePlayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecipientMultiplePlayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecipientMultiplePlayers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecipientMultiplePlayers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers";
  }
  protected:
  explicit RecipientMultiplePlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdsFieldNumber = 1,
  };
  // repeated .minecpp.proto.player.v1.PlayerId player_ids = 1;
  int player_ids_size() const;
  private:
  int _internal_player_ids_size() const;
  public:
  void clear_player_ids();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::PlayerId >*
      mutable_player_ids();
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_ids(int index) const;
  ::minecpp::proto::player::v1::PlayerId* _internal_add_player_ids();
  public:
  const ::minecpp::proto::player::v1::PlayerId& player_ids(int index) const;
  ::minecpp::proto::player::v1::PlayerId* add_player_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::PlayerId >&
      player_ids() const;

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::PlayerId > player_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class RecipientAllPlayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.RecipientAllPlayers) */ {
 public:
  inline RecipientAllPlayers() : RecipientAllPlayers(nullptr) {}
  ~RecipientAllPlayers() override;
  explicit constexpr RecipientAllPlayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecipientAllPlayers(const RecipientAllPlayers& from);
  RecipientAllPlayers(RecipientAllPlayers&& from) noexcept
    : RecipientAllPlayers() {
    *this = ::std::move(from);
  }

  inline RecipientAllPlayers& operator=(const RecipientAllPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecipientAllPlayers& operator=(RecipientAllPlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecipientAllPlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecipientAllPlayers* internal_default_instance() {
    return reinterpret_cast<const RecipientAllPlayers*>(
               &_RecipientAllPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RecipientAllPlayers& a, RecipientAllPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(RecipientAllPlayers* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecipientAllPlayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecipientAllPlayers* New() const final {
    return new RecipientAllPlayers();
  }

  RecipientAllPlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecipientAllPlayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecipientAllPlayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RecipientAllPlayers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecipientAllPlayers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.RecipientAllPlayers";
  }
  protected:
  explicit RecipientAllPlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.RecipientAllPlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class AddPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.AddPlayer) */ {
 public:
  inline AddPlayer() : AddPlayer(nullptr) {}
  ~AddPlayer() override;
  explicit constexpr AddPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPlayer(const AddPlayer& from);
  AddPlayer(AddPlayer&& from) noexcept
    : AddPlayer() {
    *this = ::std::move(from);
  }

  inline AddPlayer& operator=(const AddPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPlayer& operator=(AddPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPlayer* internal_default_instance() {
    return reinterpret_cast<const AddPlayer*>(
               &_AddPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AddPlayer& a, AddPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddPlayer* New() const final {
    return new AddPlayer();
  }

  AddPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.AddPlayer";
  }
  protected:
  explicit AddPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kGameModeFieldNumber = 3,
    kPingFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // .minecpp.proto.common.v1.GameMode game_mode = 3;
  void clear_game_mode();
  ::minecpp::proto::common::v1::GameMode game_mode() const;
  void set_game_mode(::minecpp::proto::common::v1::GameMode value);
  private:
  ::minecpp::proto::common::v1::GameMode _internal_game_mode() const;
  void _internal_set_game_mode(::minecpp::proto::common::v1::GameMode value);
  public:

  // uint32 ping = 4;
  void clear_ping();
  ::PROTOBUF_NAMESPACE_ID::uint32 ping() const;
  void set_ping(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ping() const;
  void _internal_set_ping(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.AddPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  int game_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class SpawnPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.SpawnPlayer) */ {
 public:
  inline SpawnPlayer() : SpawnPlayer(nullptr) {}
  ~SpawnPlayer() override;
  explicit constexpr SpawnPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpawnPlayer(const SpawnPlayer& from);
  SpawnPlayer(SpawnPlayer&& from) noexcept
    : SpawnPlayer() {
    *this = ::std::move(from);
  }

  inline SpawnPlayer& operator=(const SpawnPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpawnPlayer& operator=(SpawnPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpawnPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpawnPlayer* internal_default_instance() {
    return reinterpret_cast<const SpawnPlayer*>(
               &_SpawnPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SpawnPlayer& a, SpawnPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SpawnPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpawnPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpawnPlayer* New() const final {
    return new SpawnPlayer();
  }

  SpawnPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpawnPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpawnPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpawnPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpawnPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.SpawnPlayer";
  }
  protected:
  explicit SpawnPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPositionFieldNumber = 3,
    kRotationFieldNumber = 4,
    kEntityIdFieldNumber = 2,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // .minecpp.proto.entity.v1.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::minecpp::proto::entity::v1::Position& position() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::entity::v1::Position* release_position();
  ::minecpp::proto::entity::v1::Position* mutable_position();
  void set_allocated_position(::minecpp::proto::entity::v1::Position* position);
  private:
  const ::minecpp::proto::entity::v1::Position& _internal_position() const;
  ::minecpp::proto::entity::v1::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::minecpp::proto::entity::v1::Position* position);
  ::minecpp::proto::entity::v1::Position* unsafe_arena_release_position();

  // .minecpp.proto.entity.v1.Rotation rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::minecpp::proto::entity::v1::Rotation& rotation() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::entity::v1::Rotation* release_rotation();
  ::minecpp::proto::entity::v1::Rotation* mutable_rotation();
  void set_allocated_rotation(::minecpp::proto::entity::v1::Rotation* rotation);
  private:
  const ::minecpp::proto::entity::v1::Rotation& _internal_rotation() const;
  ::minecpp::proto::entity::v1::Rotation* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::minecpp::proto::entity::v1::Rotation* rotation);
  ::minecpp::proto::entity::v1::Rotation* unsafe_arena_release_rotation();

  // uint32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.SpawnPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  ::minecpp::proto::entity::v1::Position* position_;
  ::minecpp::proto::entity::v1::Rotation* rotation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class EntityMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.EntityMove) */ {
 public:
  inline EntityMove() : EntityMove(nullptr) {}
  ~EntityMove() override;
  explicit constexpr EntityMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityMove(const EntityMove& from);
  EntityMove(EntityMove&& from) noexcept
    : EntityMove() {
    *this = ::std::move(from);
  }

  inline EntityMove& operator=(const EntityMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityMove& operator=(EntityMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityMove* internal_default_instance() {
    return reinterpret_cast<const EntityMove*>(
               &_EntityMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EntityMove& a, EntityMove& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityMove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityMove* New() const final {
    return new EntityMove();
  }

  EntityMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EntityMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.EntityMove";
  }
  protected:
  explicit EntityMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kMovementFieldNumber = 3,
    kRotationFieldNumber = 4,
    kEntityIdFieldNumber = 2,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // .minecpp.proto.entity.v1.Movement movement = 3;
  bool has_movement() const;
  private:
  bool _internal_has_movement() const;
  public:
  void clear_movement();
  const ::minecpp::proto::entity::v1::Movement& movement() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::entity::v1::Movement* release_movement();
  ::minecpp::proto::entity::v1::Movement* mutable_movement();
  void set_allocated_movement(::minecpp::proto::entity::v1::Movement* movement);
  private:
  const ::minecpp::proto::entity::v1::Movement& _internal_movement() const;
  ::minecpp::proto::entity::v1::Movement* _internal_mutable_movement();
  public:
  void unsafe_arena_set_allocated_movement(
      ::minecpp::proto::entity::v1::Movement* movement);
  ::minecpp::proto::entity::v1::Movement* unsafe_arena_release_movement();

  // .minecpp.proto.entity.v1.Rotation rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::minecpp::proto::entity::v1::Rotation& rotation() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::entity::v1::Rotation* release_rotation();
  ::minecpp::proto::entity::v1::Rotation* mutable_rotation();
  void set_allocated_rotation(::minecpp::proto::entity::v1::Rotation* rotation);
  private:
  const ::minecpp::proto::entity::v1::Rotation& _internal_rotation() const;
  ::minecpp::proto::entity::v1::Rotation* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::minecpp::proto::entity::v1::Rotation* rotation);
  ::minecpp::proto::entity::v1::Rotation* unsafe_arena_release_rotation();

  // uint32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.EntityMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  ::minecpp::proto::entity::v1::Movement* movement_;
  ::minecpp::proto::entity::v1::Rotation* rotation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class EntityLook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.EntityLook) */ {
 public:
  inline EntityLook() : EntityLook(nullptr) {}
  ~EntityLook() override;
  explicit constexpr EntityLook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityLook(const EntityLook& from);
  EntityLook(EntityLook&& from) noexcept
    : EntityLook() {
    *this = ::std::move(from);
  }

  inline EntityLook& operator=(const EntityLook& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityLook& operator=(EntityLook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityLook& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityLook* internal_default_instance() {
    return reinterpret_cast<const EntityLook*>(
               &_EntityLook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EntityLook& a, EntityLook& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityLook* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityLook* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityLook* New() const final {
    return new EntityLook();
  }

  EntityLook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityLook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityLook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EntityLook& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityLook* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.EntityLook";
  }
  protected:
  explicit EntityLook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kRotationFieldNumber = 3,
    kEntityIdFieldNumber = 2,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // .minecpp.proto.entity.v1.Rotation rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::minecpp::proto::entity::v1::Rotation& rotation() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::entity::v1::Rotation* release_rotation();
  ::minecpp::proto::entity::v1::Rotation* mutable_rotation();
  void set_allocated_rotation(::minecpp::proto::entity::v1::Rotation* rotation);
  private:
  const ::minecpp::proto::entity::v1::Rotation& _internal_rotation() const;
  ::minecpp::proto::entity::v1::Rotation* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::minecpp::proto::entity::v1::Rotation* rotation);
  ::minecpp::proto::entity::v1::Rotation* unsafe_arena_release_rotation();

  // uint32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.EntityLook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  ::minecpp::proto::entity::v1::Rotation* rotation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class PlayerPositionRotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.PlayerPositionRotation) */ {
 public:
  inline PlayerPositionRotation() : PlayerPositionRotation(nullptr) {}
  ~PlayerPositionRotation() override;
  explicit constexpr PlayerPositionRotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerPositionRotation(const PlayerPositionRotation& from);
  PlayerPositionRotation(PlayerPositionRotation&& from) noexcept
    : PlayerPositionRotation() {
    *this = ::std::move(from);
  }

  inline PlayerPositionRotation& operator=(const PlayerPositionRotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPositionRotation& operator=(PlayerPositionRotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerPositionRotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerPositionRotation* internal_default_instance() {
    return reinterpret_cast<const PlayerPositionRotation*>(
               &_PlayerPositionRotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerPositionRotation& a, PlayerPositionRotation& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerPositionRotation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerPositionRotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerPositionRotation* New() const final {
    return new PlayerPositionRotation();
  }

  PlayerPositionRotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerPositionRotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerPositionRotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerPositionRotation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerPositionRotation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.PlayerPositionRotation";
  }
  protected:
  explicit PlayerPositionRotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.PlayerPositionRotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.Chat) */ {
 public:
  inline Chat() : Chat(nullptr) {}
  ~Chat() override;
  explicit constexpr Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chat(const Chat& from);
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chat& operator=(Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(Chat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Chat* New() const final {
    return new Chat();
  }

  Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Chat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.Chat";
  }
  protected:
  explicit Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 type = 2;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class RemovePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.RemovePlayer) */ {
 public:
  inline RemovePlayer() : RemovePlayer(nullptr) {}
  ~RemovePlayer() override;
  explicit constexpr RemovePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemovePlayer(const RemovePlayer& from);
  RemovePlayer(RemovePlayer&& from) noexcept
    : RemovePlayer() {
    *this = ::std::move(from);
  }

  inline RemovePlayer& operator=(const RemovePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemovePlayer& operator=(RemovePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemovePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemovePlayer* internal_default_instance() {
    return reinterpret_cast<const RemovePlayer*>(
               &_RemovePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RemovePlayer& a, RemovePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(RemovePlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemovePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemovePlayer* New() const final {
    return new RemovePlayer();
  }

  RemovePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemovePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemovePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemovePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemovePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.RemovePlayer";
  }
  protected:
  explicit RemovePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // uint32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.RemovePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class UpdateBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.UpdateBlock) */ {
 public:
  inline UpdateBlock() : UpdateBlock(nullptr) {}
  ~UpdateBlock() override;
  explicit constexpr UpdateBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBlock(const UpdateBlock& from);
  UpdateBlock(UpdateBlock&& from) noexcept
    : UpdateBlock() {
    *this = ::std::move(from);
  }

  inline UpdateBlock& operator=(const UpdateBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBlock& operator=(UpdateBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBlock* internal_default_instance() {
    return reinterpret_cast<const UpdateBlock*>(
               &_UpdateBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateBlock& a, UpdateBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBlock* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateBlock* New() const final {
    return new UpdateBlock();
  }

  UpdateBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateBlock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.UpdateBlock";
  }
  protected:
  explicit UpdateBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockPositionFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // uint64 block_position = 1;
  void clear_block_position();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_position() const;
  void set_block_position(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_position() const;
  void _internal_set_block_position(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 state = 2;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::uint32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.UpdateBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class AnimateHand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.AnimateHand) */ {
 public:
  inline AnimateHand() : AnimateHand(nullptr) {}
  ~AnimateHand() override;
  explicit constexpr AnimateHand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateHand(const AnimateHand& from);
  AnimateHand(AnimateHand&& from) noexcept
    : AnimateHand() {
    *this = ::std::move(from);
  }

  inline AnimateHand& operator=(const AnimateHand& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateHand& operator=(AnimateHand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateHand& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimateHand* internal_default_instance() {
    return reinterpret_cast<const AnimateHand*>(
               &_AnimateHand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AnimateHand& a, AnimateHand& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateHand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateHand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnimateHand* New() const final {
    return new AnimateHand();
  }

  AnimateHand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnimateHand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateHand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnimateHand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateHand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.AnimateHand";
  }
  protected:
  explicit AnimateHand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kEntityIdFieldNumber = 2,
    kHandFieldNumber = 3,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // uint32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 hand = 3;
  void clear_hand();
  ::PROTOBUF_NAMESPACE_ID::uint32 hand() const;
  void set_hand(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hand() const;
  void _internal_set_hand(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.AnimateHand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 entity_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hand_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class LoadTerrain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.LoadTerrain) */ {
 public:
  inline LoadTerrain() : LoadTerrain(nullptr) {}
  ~LoadTerrain() override;
  explicit constexpr LoadTerrain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadTerrain(const LoadTerrain& from);
  LoadTerrain(LoadTerrain&& from) noexcept
    : LoadTerrain() {
    *this = ::std::move(from);
  }

  inline LoadTerrain& operator=(const LoadTerrain& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadTerrain& operator=(LoadTerrain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadTerrain& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadTerrain* internal_default_instance() {
    return reinterpret_cast<const LoadTerrain*>(
               &_LoadTerrain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LoadTerrain& a, LoadTerrain& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadTerrain* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadTerrain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadTerrain* New() const final {
    return new LoadTerrain();
  }

  LoadTerrain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadTerrain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadTerrain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadTerrain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadTerrain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.LoadTerrain";
  }
  protected:
  explicit LoadTerrain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordsFieldNumber = 2,
    kCentralChunkFieldNumber = 1,
  };
  // repeated .minecpp.proto.common.v1.ChunkPosition coords = 2;
  int coords_size() const;
  private:
  int _internal_coords_size() const;
  public:
  void clear_coords();
  ::minecpp::proto::common::v1::ChunkPosition* mutable_coords(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::common::v1::ChunkPosition >*
      mutable_coords();
  private:
  const ::minecpp::proto::common::v1::ChunkPosition& _internal_coords(int index) const;
  ::minecpp::proto::common::v1::ChunkPosition* _internal_add_coords();
  public:
  const ::minecpp::proto::common::v1::ChunkPosition& coords(int index) const;
  ::minecpp::proto::common::v1::ChunkPosition* add_coords();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::common::v1::ChunkPosition >&
      coords() const;

  // .minecpp.proto.common.v1.ChunkPosition central_chunk = 1;
  bool has_central_chunk() const;
  private:
  bool _internal_has_central_chunk() const;
  public:
  void clear_central_chunk();
  const ::minecpp::proto::common::v1::ChunkPosition& central_chunk() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::common::v1::ChunkPosition* release_central_chunk();
  ::minecpp::proto::common::v1::ChunkPosition* mutable_central_chunk();
  void set_allocated_central_chunk(::minecpp::proto::common::v1::ChunkPosition* central_chunk);
  private:
  const ::minecpp::proto::common::v1::ChunkPosition& _internal_central_chunk() const;
  ::minecpp::proto::common::v1::ChunkPosition* _internal_mutable_central_chunk();
  public:
  void unsafe_arena_set_allocated_central_chunk(
      ::minecpp::proto::common::v1::ChunkPosition* central_chunk);
  ::minecpp::proto::common::v1::ChunkPosition* unsafe_arena_release_central_chunk();

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.LoadTerrain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::common::v1::ChunkPosition > coords_;
  ::minecpp::proto::common::v1::ChunkPosition* central_chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class TransferPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.TransferPlayer) */ {
 public:
  inline TransferPlayer() : TransferPlayer(nullptr) {}
  ~TransferPlayer() override;
  explicit constexpr TransferPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferPlayer(const TransferPlayer& from);
  TransferPlayer(TransferPlayer&& from) noexcept
    : TransferPlayer() {
    *this = ::std::move(from);
  }

  inline TransferPlayer& operator=(const TransferPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferPlayer& operator=(TransferPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferPlayer* internal_default_instance() {
    return reinterpret_cast<const TransferPlayer*>(
               &_TransferPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransferPlayer& a, TransferPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferPlayer* New() const final {
    return new TransferPlayer();
  }

  TransferPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.TransferPlayer";
  }
  protected:
  explicit TransferPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEngineInstanceIdFieldNumber = 2,
  };
  // uint64 engine_instance_id = 2;
  void clear_engine_instance_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 engine_instance_id() const;
  void set_engine_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_engine_instance_id() const;
  void _internal_set_engine_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.TransferPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 engine_instance_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayerAbilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities) */ {
 public:
  inline UpdatePlayerAbilities() : UpdatePlayerAbilities(nullptr) {}
  ~UpdatePlayerAbilities() override;
  explicit constexpr UpdatePlayerAbilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePlayerAbilities(const UpdatePlayerAbilities& from);
  UpdatePlayerAbilities(UpdatePlayerAbilities&& from) noexcept
    : UpdatePlayerAbilities() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerAbilities& operator=(const UpdatePlayerAbilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerAbilities& operator=(UpdatePlayerAbilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerAbilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerAbilities* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerAbilities*>(
               &_UpdatePlayerAbilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdatePlayerAbilities& a, UpdatePlayerAbilities& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerAbilities* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerAbilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayerAbilities* New() const final {
    return new UpdatePlayerAbilities();
  }

  UpdatePlayerAbilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayerAbilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerAbilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePlayerAbilities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayerAbilities* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities";
  }
  protected:
  explicit UpdatePlayerAbilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kInvulnerableFieldNumber = 2,
    kIsFlyingFieldNumber = 3,
    kAllowFlyingFieldNumber = 4,
    kCreativeModeFieldNumber = 5,
    kWalkSpeedFieldNumber = 7,
    kFlySpeedFieldNumber = 8,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // bool invulnerable = 2;
  void clear_invulnerable();
  bool invulnerable() const;
  void set_invulnerable(bool value);
  private:
  bool _internal_invulnerable() const;
  void _internal_set_invulnerable(bool value);
  public:

  // bool is_flying = 3;
  void clear_is_flying();
  bool is_flying() const;
  void set_is_flying(bool value);
  private:
  bool _internal_is_flying() const;
  void _internal_set_is_flying(bool value);
  public:

  // bool allow_flying = 4;
  void clear_allow_flying();
  bool allow_flying() const;
  void set_allow_flying(bool value);
  private:
  bool _internal_allow_flying() const;
  void _internal_set_allow_flying(bool value);
  public:

  // bool creative_mode = 5;
  void clear_creative_mode();
  bool creative_mode() const;
  void set_creative_mode(bool value);
  private:
  bool _internal_creative_mode() const;
  void _internal_set_creative_mode(bool value);
  public:

  // float walk_speed = 7;
  void clear_walk_speed();
  float walk_speed() const;
  void set_walk_speed(float value);
  private:
  float _internal_walk_speed() const;
  void _internal_set_walk_speed(float value);
  public:

  // float fly_speed = 8;
  void clear_fly_speed();
  float fly_speed() const;
  void set_fly_speed(float value);
  private:
  float _internal_fly_speed() const;
  void _internal_set_fly_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  bool invulnerable_;
  bool is_flying_;
  bool allow_flying_;
  bool creative_mode_;
  float walk_speed_;
  float fly_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class UnloadChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.UnloadChunk) */ {
 public:
  inline UnloadChunk() : UnloadChunk(nullptr) {}
  ~UnloadChunk() override;
  explicit constexpr UnloadChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnloadChunk(const UnloadChunk& from);
  UnloadChunk(UnloadChunk&& from) noexcept
    : UnloadChunk() {
    *this = ::std::move(from);
  }

  inline UnloadChunk& operator=(const UnloadChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloadChunk& operator=(UnloadChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnloadChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnloadChunk* internal_default_instance() {
    return reinterpret_cast<const UnloadChunk*>(
               &_UnloadChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UnloadChunk& a, UnloadChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloadChunk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloadChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnloadChunk* New() const final {
    return new UnloadChunk();
  }

  UnloadChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnloadChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnloadChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnloadChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnloadChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.UnloadChunk";
  }
  protected:
  explicit UnloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kChunkPositionFieldNumber = 2,
  };
  // .minecpp.proto.player.v1.PlayerId player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::minecpp::proto::player::v1::PlayerId& player_id() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::PlayerId* release_player_id();
  ::minecpp::proto::player::v1::PlayerId* mutable_player_id();
  void set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id);
  private:
  const ::minecpp::proto::player::v1::PlayerId& _internal_player_id() const;
  ::minecpp::proto::player::v1::PlayerId* _internal_mutable_player_id();
  public:
  void unsafe_arena_set_allocated_player_id(
      ::minecpp::proto::player::v1::PlayerId* player_id);
  ::minecpp::proto::player::v1::PlayerId* unsafe_arena_release_player_id();

  // .minecpp.proto.common.v1.ChunkPosition chunk_position = 2;
  bool has_chunk_position() const;
  private:
  bool _internal_has_chunk_position() const;
  public:
  void clear_chunk_position();
  const ::minecpp::proto::common::v1::ChunkPosition& chunk_position() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::common::v1::ChunkPosition* release_chunk_position();
  ::minecpp::proto::common::v1::ChunkPosition* mutable_chunk_position();
  void set_allocated_chunk_position(::minecpp::proto::common::v1::ChunkPosition* chunk_position);
  private:
  const ::minecpp::proto::common::v1::ChunkPosition& _internal_chunk_position() const;
  ::minecpp::proto::common::v1::ChunkPosition* _internal_mutable_chunk_position();
  public:
  void unsafe_arena_set_allocated_chunk_position(
      ::minecpp::proto::common::v1::ChunkPosition* chunk_position);
  ::minecpp::proto::common::v1::ChunkPosition* unsafe_arena_release_chunk_position();

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.UnloadChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::player::v1::PlayerId* player_id_;
  ::minecpp::proto::common::v1::ChunkPosition* chunk_position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class PlayerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.PlayerList) */ {
 public:
  inline PlayerList() : PlayerList(nullptr) {}
  ~PlayerList() override;
  explicit constexpr PlayerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerList(const PlayerList& from);
  PlayerList(PlayerList&& from) noexcept
    : PlayerList() {
    *this = ::std::move(from);
  }

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerList& operator=(PlayerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerList* internal_default_instance() {
    return reinterpret_cast<const PlayerList*>(
               &_PlayerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PlayerList& a, PlayerList& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerList* New() const final {
    return new PlayerList();
  }

  PlayerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.PlayerList";
  }
  protected:
  explicit PlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .minecpp.proto.player.v1.Status list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::minecpp::proto::player::v1::Status* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::Status >*
      mutable_list();
  private:
  const ::minecpp::proto::player::v1::Status& _internal_list(int index) const;
  ::minecpp::proto::player::v1::Status* _internal_add_list();
  public:
  const ::minecpp::proto::player::v1::Status& list(int index) const;
  ::minecpp::proto::player::v1::Status* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::Status >&
      list() const;

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.PlayerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::Status > list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class EntityList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.EntityList) */ {
 public:
  inline EntityList() : EntityList(nullptr) {}
  ~EntityList() override;
  explicit constexpr EntityList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityList(const EntityList& from);
  EntityList(EntityList&& from) noexcept
    : EntityList() {
    *this = ::std::move(from);
  }

  inline EntityList& operator=(const EntityList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityList& operator=(EntityList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityList& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityList* internal_default_instance() {
    return reinterpret_cast<const EntityList*>(
               &_EntityList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EntityList& a, EntityList& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityList* New() const final {
    return new EntityList();
  }

  EntityList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EntityList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.EntityList";
  }
  protected:
  explicit EntityList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
  };
  // repeated .minecpp.proto.entity.v1.Entity list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::minecpp::proto::entity::v1::Entity* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::entity::v1::Entity >*
      mutable_list();
  private:
  const ::minecpp::proto::entity::v1::Entity& _internal_list(int index) const;
  ::minecpp::proto::entity::v1::Entity* _internal_add_list();
  public:
  const ::minecpp::proto::entity::v1::Entity& list(int index) const;
  ::minecpp::proto::entity::v1::Entity* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::entity::v1::Entity >&
      list() const;

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.EntityList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::entity::v1::Entity > list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class AcceptPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.AcceptPlayer) */ {
 public:
  inline AcceptPlayer() : AcceptPlayer(nullptr) {}
  ~AcceptPlayer() override;
  explicit constexpr AcceptPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcceptPlayer(const AcceptPlayer& from);
  AcceptPlayer(AcceptPlayer&& from) noexcept
    : AcceptPlayer() {
    *this = ::std::move(from);
  }

  inline AcceptPlayer& operator=(const AcceptPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptPlayer& operator=(AcceptPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptPlayer* internal_default_instance() {
    return reinterpret_cast<const AcceptPlayer*>(
               &_AcceptPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AcceptPlayer& a, AcceptPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcceptPlayer* New() const final {
    return new AcceptPlayer();
  }

  AcceptPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcceptPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcceptPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AcceptPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.AcceptPlayer";
  }
  protected:
  explicit AcceptPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameplayFieldNumber = 1,
    kPlayerFieldNumber = 2,
  };
  // .minecpp.proto.common.v1.Gameplay gameplay = 1;
  bool has_gameplay() const;
  private:
  bool _internal_has_gameplay() const;
  public:
  void clear_gameplay();
  const ::minecpp::proto::common::v1::Gameplay& gameplay() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::common::v1::Gameplay* release_gameplay();
  ::minecpp::proto::common::v1::Gameplay* mutable_gameplay();
  void set_allocated_gameplay(::minecpp::proto::common::v1::Gameplay* gameplay);
  private:
  const ::minecpp::proto::common::v1::Gameplay& _internal_gameplay() const;
  ::minecpp::proto::common::v1::Gameplay* _internal_mutable_gameplay();
  public:
  void unsafe_arena_set_allocated_gameplay(
      ::minecpp::proto::common::v1::Gameplay* gameplay);
  ::minecpp::proto::common::v1::Gameplay* unsafe_arena_release_gameplay();

  // .minecpp.proto.player.v1.Player player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::minecpp::proto::player::v1::Player& player() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::player::v1::Player* release_player();
  ::minecpp::proto::player::v1::Player* mutable_player();
  void set_allocated_player(::minecpp::proto::player::v1::Player* player);
  private:
  const ::minecpp::proto::player::v1::Player& _internal_player() const;
  ::minecpp::proto::player::v1::Player* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::minecpp::proto::player::v1::Player* player);
  ::minecpp::proto::player::v1::Player* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.AcceptPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minecpp::proto::common::v1::Gameplay* gameplay_;
  ::minecpp::proto::player::v1::Player* player_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// -------------------------------------------------------------------

class DenyPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.clientbound.v1.DenyPlayer) */ {
 public:
  inline DenyPlayer() : DenyPlayer(nullptr) {}
  ~DenyPlayer() override;
  explicit constexpr DenyPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DenyPlayer(const DenyPlayer& from);
  DenyPlayer(DenyPlayer&& from) noexcept
    : DenyPlayer() {
    *this = ::std::move(from);
  }

  inline DenyPlayer& operator=(const DenyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DenyPlayer& operator=(DenyPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DenyPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const DenyPlayer* internal_default_instance() {
    return reinterpret_cast<const DenyPlayer*>(
               &_DenyPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DenyPlayer& a, DenyPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(DenyPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DenyPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DenyPlayer* New() const final {
    return new DenyPlayer();
  }

  DenyPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DenyPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DenyPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DenyPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DenyPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.clientbound.v1.DenyPlayer";
  }
  protected:
  explicit DenyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenialReasonFieldNumber = 1,
  };
  // string denial_reason = 1;
  void clear_denial_reason();
  const std::string& denial_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_denial_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_denial_reason();
  PROTOBUF_MUST_USE_RESULT std::string* release_denial_reason();
  void set_allocated_denial_reason(std::string* denial_reason);
  private:
  const std::string& _internal_denial_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denial_reason(const std::string& value);
  std::string* _internal_mutable_denial_reason();
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.clientbound.v1.DenyPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denial_reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event

// .google.protobuf.Any payload = 1;
inline bool Event::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool Event::has_payload() const {
  return _internal_has_payload();
}
inline const PROTOBUF_NAMESPACE_ID::Any& Event::_internal_payload() const {
  const PROTOBUF_NAMESPACE_ID::Any* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Any&>(
      PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& Event::payload() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.Event.payload)
  return _internal_payload();
}
inline void Event::unsafe_arena_set_allocated_payload(
    PROTOBUF_NAMESPACE_ID::Any* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.Event.payload)
}
inline PROTOBUF_NAMESPACE_ID::Any* Event::release_payload() {
  
  PROTOBUF_NAMESPACE_ID::Any* temp = payload_;
  payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Event::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.Event.payload)
  
  PROTOBUF_NAMESPACE_ID::Any* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Any* Event::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    payload_ = p;
  }
  return payload_;
}
inline PROTOBUF_NAMESPACE_ID::Any* Event::mutable_payload() {
  PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.Event.payload)
  return _msg;
}
inline void Event::set_allocated_payload(PROTOBUF_NAMESPACE_ID::Any* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload));
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.Event.payload)
}

// .minecpp.proto.event.clientbound.v1.RecipientSinglePlayer single_player = 2;
inline bool Event::_internal_has_single_player() const {
  return recipient_case() == kSinglePlayer;
}
inline bool Event::has_single_player() const {
  return _internal_has_single_player();
}
inline void Event::set_has_single_player() {
  _oneof_case_[0] = kSinglePlayer;
}
inline void Event::clear_single_player() {
  if (_internal_has_single_player()) {
    if (GetArenaForAllocation() == nullptr) {
      delete recipient_.single_player_;
    }
    clear_has_recipient();
  }
}
inline ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* Event::release_single_player() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.Event.single_player)
  if (_internal_has_single_player()) {
    clear_has_recipient();
      ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* temp = recipient_.single_player_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    recipient_.single_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer& Event::_internal_single_player() const {
  return _internal_has_single_player()
      ? *recipient_.single_player_
      : reinterpret_cast< ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer&>(::minecpp::proto::event::clientbound::v1::_RecipientSinglePlayer_default_instance_);
}
inline const ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer& Event::single_player() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.Event.single_player)
  return _internal_single_player();
}
inline ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* Event::unsafe_arena_release_single_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.event.clientbound.v1.Event.single_player)
  if (_internal_has_single_player()) {
    clear_has_recipient();
    ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* temp = recipient_.single_player_;
    recipient_.single_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_single_player(::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* single_player) {
  clear_recipient();
  if (single_player) {
    set_has_single_player();
    recipient_.single_player_ = single_player;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.Event.single_player)
}
inline ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* Event::_internal_mutable_single_player() {
  if (!_internal_has_single_player()) {
    clear_recipient();
    set_has_single_player();
    recipient_.single_player_ = CreateMaybeMessage< ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer >(GetArenaForAllocation());
  }
  return recipient_.single_player_;
}
inline ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* Event::mutable_single_player() {
  ::minecpp::proto::event::clientbound::v1::RecipientSinglePlayer* _msg = _internal_mutable_single_player();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.Event.single_player)
  return _msg;
}

// .minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers multiple_players = 3;
inline bool Event::_internal_has_multiple_players() const {
  return recipient_case() == kMultiplePlayers;
}
inline bool Event::has_multiple_players() const {
  return _internal_has_multiple_players();
}
inline void Event::set_has_multiple_players() {
  _oneof_case_[0] = kMultiplePlayers;
}
inline void Event::clear_multiple_players() {
  if (_internal_has_multiple_players()) {
    if (GetArenaForAllocation() == nullptr) {
      delete recipient_.multiple_players_;
    }
    clear_has_recipient();
  }
}
inline ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* Event::release_multiple_players() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.Event.multiple_players)
  if (_internal_has_multiple_players()) {
    clear_has_recipient();
      ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* temp = recipient_.multiple_players_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    recipient_.multiple_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers& Event::_internal_multiple_players() const {
  return _internal_has_multiple_players()
      ? *recipient_.multiple_players_
      : reinterpret_cast< ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers&>(::minecpp::proto::event::clientbound::v1::_RecipientMultiplePlayers_default_instance_);
}
inline const ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers& Event::multiple_players() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.Event.multiple_players)
  return _internal_multiple_players();
}
inline ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* Event::unsafe_arena_release_multiple_players() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.event.clientbound.v1.Event.multiple_players)
  if (_internal_has_multiple_players()) {
    clear_has_recipient();
    ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* temp = recipient_.multiple_players_;
    recipient_.multiple_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_multiple_players(::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* multiple_players) {
  clear_recipient();
  if (multiple_players) {
    set_has_multiple_players();
    recipient_.multiple_players_ = multiple_players;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.Event.multiple_players)
}
inline ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* Event::_internal_mutable_multiple_players() {
  if (!_internal_has_multiple_players()) {
    clear_recipient();
    set_has_multiple_players();
    recipient_.multiple_players_ = CreateMaybeMessage< ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers >(GetArenaForAllocation());
  }
  return recipient_.multiple_players_;
}
inline ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* Event::mutable_multiple_players() {
  ::minecpp::proto::event::clientbound::v1::RecipientMultiplePlayers* _msg = _internal_mutable_multiple_players();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.Event.multiple_players)
  return _msg;
}

// .minecpp.proto.event.clientbound.v1.RecipientAllPlayers all_players = 4;
inline bool Event::_internal_has_all_players() const {
  return recipient_case() == kAllPlayers;
}
inline bool Event::has_all_players() const {
  return _internal_has_all_players();
}
inline void Event::set_has_all_players() {
  _oneof_case_[0] = kAllPlayers;
}
inline void Event::clear_all_players() {
  if (_internal_has_all_players()) {
    if (GetArenaForAllocation() == nullptr) {
      delete recipient_.all_players_;
    }
    clear_has_recipient();
  }
}
inline ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* Event::release_all_players() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.Event.all_players)
  if (_internal_has_all_players()) {
    clear_has_recipient();
      ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* temp = recipient_.all_players_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    recipient_.all_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers& Event::_internal_all_players() const {
  return _internal_has_all_players()
      ? *recipient_.all_players_
      : reinterpret_cast< ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers&>(::minecpp::proto::event::clientbound::v1::_RecipientAllPlayers_default_instance_);
}
inline const ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers& Event::all_players() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.Event.all_players)
  return _internal_all_players();
}
inline ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* Event::unsafe_arena_release_all_players() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.event.clientbound.v1.Event.all_players)
  if (_internal_has_all_players()) {
    clear_has_recipient();
    ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* temp = recipient_.all_players_;
    recipient_.all_players_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Event::unsafe_arena_set_allocated_all_players(::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* all_players) {
  clear_recipient();
  if (all_players) {
    set_has_all_players();
    recipient_.all_players_ = all_players;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.Event.all_players)
}
inline ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* Event::_internal_mutable_all_players() {
  if (!_internal_has_all_players()) {
    clear_recipient();
    set_has_all_players();
    recipient_.all_players_ = CreateMaybeMessage< ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers >(GetArenaForAllocation());
  }
  return recipient_.all_players_;
}
inline ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* Event::mutable_all_players() {
  ::minecpp::proto::event::clientbound::v1::RecipientAllPlayers* _msg = _internal_mutable_all_players();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.Event.all_players)
  return _msg;
}

inline bool Event::has_recipient() const {
  return recipient_case() != RECIPIENT_NOT_SET;
}
inline void Event::clear_has_recipient() {
  _oneof_case_[0] = RECIPIENT_NOT_SET;
}
inline Event::RecipientCase Event::recipient_case() const {
  return Event::RecipientCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RecipientSinglePlayer

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool RecipientSinglePlayer::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool RecipientSinglePlayer::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& RecipientSinglePlayer::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& RecipientSinglePlayer::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer.player_id)
  return _internal_player_id();
}
inline void RecipientSinglePlayer::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientSinglePlayer::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientSinglePlayer::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientSinglePlayer::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientSinglePlayer::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer.player_id)
  return _msg;
}
inline void RecipientSinglePlayer::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.RecipientSinglePlayer.player_id)
}

// -------------------------------------------------------------------

// RecipientMultiplePlayers

// repeated .minecpp.proto.player.v1.PlayerId player_ids = 1;
inline int RecipientMultiplePlayers::_internal_player_ids_size() const {
  return player_ids_.size();
}
inline int RecipientMultiplePlayers::player_ids_size() const {
  return _internal_player_ids_size();
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientMultiplePlayers::mutable_player_ids(int index) {
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers.player_ids)
  return player_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::PlayerId >*
RecipientMultiplePlayers::mutable_player_ids() {
  // @@protoc_insertion_point(field_mutable_list:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers.player_ids)
  return &player_ids_;
}
inline const ::minecpp::proto::player::v1::PlayerId& RecipientMultiplePlayers::_internal_player_ids(int index) const {
  return player_ids_.Get(index);
}
inline const ::minecpp::proto::player::v1::PlayerId& RecipientMultiplePlayers::player_ids(int index) const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers.player_ids)
  return _internal_player_ids(index);
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientMultiplePlayers::_internal_add_player_ids() {
  return player_ids_.Add();
}
inline ::minecpp::proto::player::v1::PlayerId* RecipientMultiplePlayers::add_player_ids() {
  ::minecpp::proto::player::v1::PlayerId* _add = _internal_add_player_ids();
  // @@protoc_insertion_point(field_add:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers.player_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::PlayerId >&
RecipientMultiplePlayers::player_ids() const {
  // @@protoc_insertion_point(field_list:minecpp.proto.event.clientbound.v1.RecipientMultiplePlayers.player_ids)
  return player_ids_;
}

// -------------------------------------------------------------------

// RecipientAllPlayers

// -------------------------------------------------------------------

// AddPlayer

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool AddPlayer::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool AddPlayer::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& AddPlayer::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& AddPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AddPlayer.player_id)
  return _internal_player_id();
}
inline void AddPlayer::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.AddPlayer.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* AddPlayer::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* AddPlayer::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.AddPlayer.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* AddPlayer::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* AddPlayer::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.AddPlayer.player_id)
  return _msg;
}
inline void AddPlayer::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.AddPlayer.player_id)
}

// string name = 2;
inline void AddPlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AddPlayer::name() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AddPlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddPlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.AddPlayer.name)
}
inline std::string* AddPlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.AddPlayer.name)
  return _s;
}
inline const std::string& AddPlayer::_internal_name() const {
  return name_.Get();
}
inline void AddPlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddPlayer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddPlayer::release_name() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.AddPlayer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.AddPlayer.name)
}

// .minecpp.proto.common.v1.GameMode game_mode = 3;
inline void AddPlayer::clear_game_mode() {
  game_mode_ = 0;
}
inline ::minecpp::proto::common::v1::GameMode AddPlayer::_internal_game_mode() const {
  return static_cast< ::minecpp::proto::common::v1::GameMode >(game_mode_);
}
inline ::minecpp::proto::common::v1::GameMode AddPlayer::game_mode() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AddPlayer.game_mode)
  return _internal_game_mode();
}
inline void AddPlayer::_internal_set_game_mode(::minecpp::proto::common::v1::GameMode value) {
  
  game_mode_ = value;
}
inline void AddPlayer::set_game_mode(::minecpp::proto::common::v1::GameMode value) {
  _internal_set_game_mode(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.AddPlayer.game_mode)
}

// uint32 ping = 4;
inline void AddPlayer::clear_ping() {
  ping_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AddPlayer::_internal_ping() const {
  return ping_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AddPlayer::ping() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AddPlayer.ping)
  return _internal_ping();
}
inline void AddPlayer::_internal_set_ping(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ping_ = value;
}
inline void AddPlayer::set_ping(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ping(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.AddPlayer.ping)
}

// -------------------------------------------------------------------

// SpawnPlayer

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool SpawnPlayer::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool SpawnPlayer::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& SpawnPlayer::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& SpawnPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.SpawnPlayer.player_id)
  return _internal_player_id();
}
inline void SpawnPlayer::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.SpawnPlayer.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* SpawnPlayer::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* SpawnPlayer::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.SpawnPlayer.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* SpawnPlayer::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* SpawnPlayer::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.SpawnPlayer.player_id)
  return _msg;
}
inline void SpawnPlayer::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.SpawnPlayer.player_id)
}

// uint32 entity_id = 2;
inline void SpawnPlayer::clear_entity_id() {
  entity_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SpawnPlayer::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SpawnPlayer::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.SpawnPlayer.entity_id)
  return _internal_entity_id();
}
inline void SpawnPlayer::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entity_id_ = value;
}
inline void SpawnPlayer::set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.SpawnPlayer.entity_id)
}

// .minecpp.proto.entity.v1.Position position = 3;
inline bool SpawnPlayer::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SpawnPlayer::has_position() const {
  return _internal_has_position();
}
inline const ::minecpp::proto::entity::v1::Position& SpawnPlayer::_internal_position() const {
  const ::minecpp::proto::entity::v1::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::entity::v1::Position&>(
      ::minecpp::proto::entity::v1::_Position_default_instance_);
}
inline const ::minecpp::proto::entity::v1::Position& SpawnPlayer::position() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.SpawnPlayer.position)
  return _internal_position();
}
inline void SpawnPlayer::unsafe_arena_set_allocated_position(
    ::minecpp::proto::entity::v1::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.SpawnPlayer.position)
}
inline ::minecpp::proto::entity::v1::Position* SpawnPlayer::release_position() {
  
  ::minecpp::proto::entity::v1::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::entity::v1::Position* SpawnPlayer::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.SpawnPlayer.position)
  
  ::minecpp::proto::entity::v1::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::minecpp::proto::entity::v1::Position* SpawnPlayer::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::entity::v1::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::minecpp::proto::entity::v1::Position* SpawnPlayer::mutable_position() {
  ::minecpp::proto::entity::v1::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.SpawnPlayer.position)
  return _msg;
}
inline void SpawnPlayer::set_allocated_position(::minecpp::proto::entity::v1::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.SpawnPlayer.position)
}

// .minecpp.proto.entity.v1.Rotation rotation = 4;
inline bool SpawnPlayer::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool SpawnPlayer::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::minecpp::proto::entity::v1::Rotation& SpawnPlayer::_internal_rotation() const {
  const ::minecpp::proto::entity::v1::Rotation* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::entity::v1::Rotation&>(
      ::minecpp::proto::entity::v1::_Rotation_default_instance_);
}
inline const ::minecpp::proto::entity::v1::Rotation& SpawnPlayer::rotation() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.SpawnPlayer.rotation)
  return _internal_rotation();
}
inline void SpawnPlayer::unsafe_arena_set_allocated_rotation(
    ::minecpp::proto::entity::v1::Rotation* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.SpawnPlayer.rotation)
}
inline ::minecpp::proto::entity::v1::Rotation* SpawnPlayer::release_rotation() {
  
  ::minecpp::proto::entity::v1::Rotation* temp = rotation_;
  rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::entity::v1::Rotation* SpawnPlayer::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.SpawnPlayer.rotation)
  
  ::minecpp::proto::entity::v1::Rotation* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::minecpp::proto::entity::v1::Rotation* SpawnPlayer::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::entity::v1::Rotation>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::minecpp::proto::entity::v1::Rotation* SpawnPlayer::mutable_rotation() {
  ::minecpp::proto::entity::v1::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.SpawnPlayer.rotation)
  return _msg;
}
inline void SpawnPlayer::set_allocated_rotation(::minecpp::proto::entity::v1::Rotation* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.SpawnPlayer.rotation)
}

// -------------------------------------------------------------------

// EntityMove

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool EntityMove::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool EntityMove::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& EntityMove::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& EntityMove::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityMove.player_id)
  return _internal_player_id();
}
inline void EntityMove::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.EntityMove.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* EntityMove::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* EntityMove::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.EntityMove.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* EntityMove::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* EntityMove::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.EntityMove.player_id)
  return _msg;
}
inline void EntityMove::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.EntityMove.player_id)
}

// uint32 entity_id = 2;
inline void EntityMove::clear_entity_id() {
  entity_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EntityMove::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EntityMove::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityMove.entity_id)
  return _internal_entity_id();
}
inline void EntityMove::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entity_id_ = value;
}
inline void EntityMove::set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.EntityMove.entity_id)
}

// .minecpp.proto.entity.v1.Movement movement = 3;
inline bool EntityMove::_internal_has_movement() const {
  return this != internal_default_instance() && movement_ != nullptr;
}
inline bool EntityMove::has_movement() const {
  return _internal_has_movement();
}
inline const ::minecpp::proto::entity::v1::Movement& EntityMove::_internal_movement() const {
  const ::minecpp::proto::entity::v1::Movement* p = movement_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::entity::v1::Movement&>(
      ::minecpp::proto::entity::v1::_Movement_default_instance_);
}
inline const ::minecpp::proto::entity::v1::Movement& EntityMove::movement() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityMove.movement)
  return _internal_movement();
}
inline void EntityMove::unsafe_arena_set_allocated_movement(
    ::minecpp::proto::entity::v1::Movement* movement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_);
  }
  movement_ = movement;
  if (movement) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.EntityMove.movement)
}
inline ::minecpp::proto::entity::v1::Movement* EntityMove::release_movement() {
  
  ::minecpp::proto::entity::v1::Movement* temp = movement_;
  movement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::entity::v1::Movement* EntityMove::unsafe_arena_release_movement() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.EntityMove.movement)
  
  ::minecpp::proto::entity::v1::Movement* temp = movement_;
  movement_ = nullptr;
  return temp;
}
inline ::minecpp::proto::entity::v1::Movement* EntityMove::_internal_mutable_movement() {
  
  if (movement_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::entity::v1::Movement>(GetArenaForAllocation());
    movement_ = p;
  }
  return movement_;
}
inline ::minecpp::proto::entity::v1::Movement* EntityMove::mutable_movement() {
  ::minecpp::proto::entity::v1::Movement* _msg = _internal_mutable_movement();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.EntityMove.movement)
  return _msg;
}
inline void EntityMove::set_allocated_movement(::minecpp::proto::entity::v1::Movement* movement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_);
  }
  if (movement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement));
    if (message_arena != submessage_arena) {
      movement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, movement, submessage_arena);
    }
    
  } else {
    
  }
  movement_ = movement;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.EntityMove.movement)
}

// .minecpp.proto.entity.v1.Rotation rotation = 4;
inline bool EntityMove::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool EntityMove::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::minecpp::proto::entity::v1::Rotation& EntityMove::_internal_rotation() const {
  const ::minecpp::proto::entity::v1::Rotation* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::entity::v1::Rotation&>(
      ::minecpp::proto::entity::v1::_Rotation_default_instance_);
}
inline const ::minecpp::proto::entity::v1::Rotation& EntityMove::rotation() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityMove.rotation)
  return _internal_rotation();
}
inline void EntityMove::unsafe_arena_set_allocated_rotation(
    ::minecpp::proto::entity::v1::Rotation* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.EntityMove.rotation)
}
inline ::minecpp::proto::entity::v1::Rotation* EntityMove::release_rotation() {
  
  ::minecpp::proto::entity::v1::Rotation* temp = rotation_;
  rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::entity::v1::Rotation* EntityMove::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.EntityMove.rotation)
  
  ::minecpp::proto::entity::v1::Rotation* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::minecpp::proto::entity::v1::Rotation* EntityMove::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::entity::v1::Rotation>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::minecpp::proto::entity::v1::Rotation* EntityMove::mutable_rotation() {
  ::minecpp::proto::entity::v1::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.EntityMove.rotation)
  return _msg;
}
inline void EntityMove::set_allocated_rotation(::minecpp::proto::entity::v1::Rotation* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.EntityMove.rotation)
}

// -------------------------------------------------------------------

// EntityLook

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool EntityLook::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool EntityLook::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& EntityLook::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& EntityLook::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityLook.player_id)
  return _internal_player_id();
}
inline void EntityLook::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.EntityLook.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* EntityLook::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* EntityLook::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.EntityLook.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* EntityLook::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* EntityLook::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.EntityLook.player_id)
  return _msg;
}
inline void EntityLook::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.EntityLook.player_id)
}

// uint32 entity_id = 2;
inline void EntityLook::clear_entity_id() {
  entity_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EntityLook::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EntityLook::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityLook.entity_id)
  return _internal_entity_id();
}
inline void EntityLook::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entity_id_ = value;
}
inline void EntityLook::set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.EntityLook.entity_id)
}

// .minecpp.proto.entity.v1.Rotation rotation = 3;
inline bool EntityLook::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool EntityLook::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::minecpp::proto::entity::v1::Rotation& EntityLook::_internal_rotation() const {
  const ::minecpp::proto::entity::v1::Rotation* p = rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::entity::v1::Rotation&>(
      ::minecpp::proto::entity::v1::_Rotation_default_instance_);
}
inline const ::minecpp::proto::entity::v1::Rotation& EntityLook::rotation() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityLook.rotation)
  return _internal_rotation();
}
inline void EntityLook::unsafe_arena_set_allocated_rotation(
    ::minecpp::proto::entity::v1::Rotation* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.EntityLook.rotation)
}
inline ::minecpp::proto::entity::v1::Rotation* EntityLook::release_rotation() {
  
  ::minecpp::proto::entity::v1::Rotation* temp = rotation_;
  rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::entity::v1::Rotation* EntityLook::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.EntityLook.rotation)
  
  ::minecpp::proto::entity::v1::Rotation* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::minecpp::proto::entity::v1::Rotation* EntityLook::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::entity::v1::Rotation>(GetArenaForAllocation());
    rotation_ = p;
  }
  return rotation_;
}
inline ::minecpp::proto::entity::v1::Rotation* EntityLook::mutable_rotation() {
  ::minecpp::proto::entity::v1::Rotation* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.EntityLook.rotation)
  return _msg;
}
inline void EntityLook::set_allocated_rotation(::minecpp::proto::entity::v1::Rotation* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.EntityLook.rotation)
}

// -------------------------------------------------------------------

// PlayerPositionRotation

// -------------------------------------------------------------------

// Chat

// string message = 1;
inline void Chat::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Chat::message() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.Chat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.Chat.message)
}
inline std::string* Chat::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.Chat.message)
  return _s;
}
inline const std::string& Chat::_internal_message() const {
  return message_.Get();
}
inline void Chat::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chat::release_message() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.Chat.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.Chat.message)
}

// int32 type = 2;
inline void Chat::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Chat::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Chat::type() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.Chat.type)
  return _internal_type();
}
inline void Chat::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void Chat::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.Chat.type)
}

// -------------------------------------------------------------------

// RemovePlayer

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool RemovePlayer::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool RemovePlayer::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& RemovePlayer::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& RemovePlayer::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.RemovePlayer.player_id)
  return _internal_player_id();
}
inline void RemovePlayer::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.RemovePlayer.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* RemovePlayer::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* RemovePlayer::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.RemovePlayer.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* RemovePlayer::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* RemovePlayer::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.RemovePlayer.player_id)
  return _msg;
}
inline void RemovePlayer::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.RemovePlayer.player_id)
}

// uint32 entity_id = 2;
inline void RemovePlayer::clear_entity_id() {
  entity_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RemovePlayer::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RemovePlayer::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.RemovePlayer.entity_id)
  return _internal_entity_id();
}
inline void RemovePlayer::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entity_id_ = value;
}
inline void RemovePlayer::set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.RemovePlayer.entity_id)
}

// -------------------------------------------------------------------

// UpdateBlock

// uint64 block_position = 1;
inline void UpdateBlock::clear_block_position() {
  block_position_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UpdateBlock::_internal_block_position() const {
  return block_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UpdateBlock::block_position() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdateBlock.block_position)
  return _internal_block_position();
}
inline void UpdateBlock::_internal_set_block_position(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_position_ = value;
}
inline void UpdateBlock::set_block_position(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_position(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdateBlock.block_position)
}

// uint32 state = 2;
inline void UpdateBlock::clear_state() {
  state_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateBlock::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateBlock::state() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdateBlock.state)
  return _internal_state();
}
inline void UpdateBlock::_internal_set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  state_ = value;
}
inline void UpdateBlock::set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdateBlock.state)
}

// -------------------------------------------------------------------

// AnimateHand

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool AnimateHand::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool AnimateHand::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& AnimateHand::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& AnimateHand::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AnimateHand.player_id)
  return _internal_player_id();
}
inline void AnimateHand::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.AnimateHand.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* AnimateHand::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* AnimateHand::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.AnimateHand.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* AnimateHand::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* AnimateHand::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.AnimateHand.player_id)
  return _msg;
}
inline void AnimateHand::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.AnimateHand.player_id)
}

// uint32 entity_id = 2;
inline void AnimateHand::clear_entity_id() {
  entity_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimateHand::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimateHand::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AnimateHand.entity_id)
  return _internal_entity_id();
}
inline void AnimateHand::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  entity_id_ = value;
}
inline void AnimateHand::set_entity_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.AnimateHand.entity_id)
}

// uint32 hand = 3;
inline void AnimateHand::clear_hand() {
  hand_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimateHand::_internal_hand() const {
  return hand_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimateHand::hand() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AnimateHand.hand)
  return _internal_hand();
}
inline void AnimateHand::_internal_set_hand(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hand_ = value;
}
inline void AnimateHand::set_hand(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hand(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.AnimateHand.hand)
}

// -------------------------------------------------------------------

// LoadTerrain

// .minecpp.proto.common.v1.ChunkPosition central_chunk = 1;
inline bool LoadTerrain::_internal_has_central_chunk() const {
  return this != internal_default_instance() && central_chunk_ != nullptr;
}
inline bool LoadTerrain::has_central_chunk() const {
  return _internal_has_central_chunk();
}
inline const ::minecpp::proto::common::v1::ChunkPosition& LoadTerrain::_internal_central_chunk() const {
  const ::minecpp::proto::common::v1::ChunkPosition* p = central_chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::common::v1::ChunkPosition&>(
      ::minecpp::proto::common::v1::_ChunkPosition_default_instance_);
}
inline const ::minecpp::proto::common::v1::ChunkPosition& LoadTerrain::central_chunk() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.LoadTerrain.central_chunk)
  return _internal_central_chunk();
}
inline void LoadTerrain::unsafe_arena_set_allocated_central_chunk(
    ::minecpp::proto::common::v1::ChunkPosition* central_chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(central_chunk_);
  }
  central_chunk_ = central_chunk;
  if (central_chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.LoadTerrain.central_chunk)
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::release_central_chunk() {
  
  ::minecpp::proto::common::v1::ChunkPosition* temp = central_chunk_;
  central_chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::unsafe_arena_release_central_chunk() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.LoadTerrain.central_chunk)
  
  ::minecpp::proto::common::v1::ChunkPosition* temp = central_chunk_;
  central_chunk_ = nullptr;
  return temp;
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::_internal_mutable_central_chunk() {
  
  if (central_chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::common::v1::ChunkPosition>(GetArenaForAllocation());
    central_chunk_ = p;
  }
  return central_chunk_;
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::mutable_central_chunk() {
  ::minecpp::proto::common::v1::ChunkPosition* _msg = _internal_mutable_central_chunk();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.LoadTerrain.central_chunk)
  return _msg;
}
inline void LoadTerrain::set_allocated_central_chunk(::minecpp::proto::common::v1::ChunkPosition* central_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(central_chunk_);
  }
  if (central_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(central_chunk));
    if (message_arena != submessage_arena) {
      central_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, central_chunk, submessage_arena);
    }
    
  } else {
    
  }
  central_chunk_ = central_chunk;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.LoadTerrain.central_chunk)
}

// repeated .minecpp.proto.common.v1.ChunkPosition coords = 2;
inline int LoadTerrain::_internal_coords_size() const {
  return coords_.size();
}
inline int LoadTerrain::coords_size() const {
  return _internal_coords_size();
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::mutable_coords(int index) {
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.LoadTerrain.coords)
  return coords_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::common::v1::ChunkPosition >*
LoadTerrain::mutable_coords() {
  // @@protoc_insertion_point(field_mutable_list:minecpp.proto.event.clientbound.v1.LoadTerrain.coords)
  return &coords_;
}
inline const ::minecpp::proto::common::v1::ChunkPosition& LoadTerrain::_internal_coords(int index) const {
  return coords_.Get(index);
}
inline const ::minecpp::proto::common::v1::ChunkPosition& LoadTerrain::coords(int index) const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.LoadTerrain.coords)
  return _internal_coords(index);
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::_internal_add_coords() {
  return coords_.Add();
}
inline ::minecpp::proto::common::v1::ChunkPosition* LoadTerrain::add_coords() {
  ::minecpp::proto::common::v1::ChunkPosition* _add = _internal_add_coords();
  // @@protoc_insertion_point(field_add:minecpp.proto.event.clientbound.v1.LoadTerrain.coords)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::common::v1::ChunkPosition >&
LoadTerrain::coords() const {
  // @@protoc_insertion_point(field_list:minecpp.proto.event.clientbound.v1.LoadTerrain.coords)
  return coords_;
}

// -------------------------------------------------------------------

// TransferPlayer

// uint64 engine_instance_id = 2;
inline void TransferPlayer::clear_engine_instance_id() {
  engine_instance_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferPlayer::_internal_engine_instance_id() const {
  return engine_instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferPlayer::engine_instance_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.TransferPlayer.engine_instance_id)
  return _internal_engine_instance_id();
}
inline void TransferPlayer::_internal_set_engine_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  engine_instance_id_ = value;
}
inline void TransferPlayer::set_engine_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_engine_instance_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.TransferPlayer.engine_instance_id)
}

// -------------------------------------------------------------------

// UpdatePlayerAbilities

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool UpdatePlayerAbilities::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool UpdatePlayerAbilities::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& UpdatePlayerAbilities::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& UpdatePlayerAbilities::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.player_id)
  return _internal_player_id();
}
inline void UpdatePlayerAbilities::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* UpdatePlayerAbilities::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* UpdatePlayerAbilities::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* UpdatePlayerAbilities::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* UpdatePlayerAbilities::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.player_id)
  return _msg;
}
inline void UpdatePlayerAbilities::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.player_id)
}

// bool invulnerable = 2;
inline void UpdatePlayerAbilities::clear_invulnerable() {
  invulnerable_ = false;
}
inline bool UpdatePlayerAbilities::_internal_invulnerable() const {
  return invulnerable_;
}
inline bool UpdatePlayerAbilities::invulnerable() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.invulnerable)
  return _internal_invulnerable();
}
inline void UpdatePlayerAbilities::_internal_set_invulnerable(bool value) {
  
  invulnerable_ = value;
}
inline void UpdatePlayerAbilities::set_invulnerable(bool value) {
  _internal_set_invulnerable(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.invulnerable)
}

// bool is_flying = 3;
inline void UpdatePlayerAbilities::clear_is_flying() {
  is_flying_ = false;
}
inline bool UpdatePlayerAbilities::_internal_is_flying() const {
  return is_flying_;
}
inline bool UpdatePlayerAbilities::is_flying() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.is_flying)
  return _internal_is_flying();
}
inline void UpdatePlayerAbilities::_internal_set_is_flying(bool value) {
  
  is_flying_ = value;
}
inline void UpdatePlayerAbilities::set_is_flying(bool value) {
  _internal_set_is_flying(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.is_flying)
}

// bool allow_flying = 4;
inline void UpdatePlayerAbilities::clear_allow_flying() {
  allow_flying_ = false;
}
inline bool UpdatePlayerAbilities::_internal_allow_flying() const {
  return allow_flying_;
}
inline bool UpdatePlayerAbilities::allow_flying() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.allow_flying)
  return _internal_allow_flying();
}
inline void UpdatePlayerAbilities::_internal_set_allow_flying(bool value) {
  
  allow_flying_ = value;
}
inline void UpdatePlayerAbilities::set_allow_flying(bool value) {
  _internal_set_allow_flying(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.allow_flying)
}

// bool creative_mode = 5;
inline void UpdatePlayerAbilities::clear_creative_mode() {
  creative_mode_ = false;
}
inline bool UpdatePlayerAbilities::_internal_creative_mode() const {
  return creative_mode_;
}
inline bool UpdatePlayerAbilities::creative_mode() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.creative_mode)
  return _internal_creative_mode();
}
inline void UpdatePlayerAbilities::_internal_set_creative_mode(bool value) {
  
  creative_mode_ = value;
}
inline void UpdatePlayerAbilities::set_creative_mode(bool value) {
  _internal_set_creative_mode(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.creative_mode)
}

// float walk_speed = 7;
inline void UpdatePlayerAbilities::clear_walk_speed() {
  walk_speed_ = 0;
}
inline float UpdatePlayerAbilities::_internal_walk_speed() const {
  return walk_speed_;
}
inline float UpdatePlayerAbilities::walk_speed() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.walk_speed)
  return _internal_walk_speed();
}
inline void UpdatePlayerAbilities::_internal_set_walk_speed(float value) {
  
  walk_speed_ = value;
}
inline void UpdatePlayerAbilities::set_walk_speed(float value) {
  _internal_set_walk_speed(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.walk_speed)
}

// float fly_speed = 8;
inline void UpdatePlayerAbilities::clear_fly_speed() {
  fly_speed_ = 0;
}
inline float UpdatePlayerAbilities::_internal_fly_speed() const {
  return fly_speed_;
}
inline float UpdatePlayerAbilities::fly_speed() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.fly_speed)
  return _internal_fly_speed();
}
inline void UpdatePlayerAbilities::_internal_set_fly_speed(float value) {
  
  fly_speed_ = value;
}
inline void UpdatePlayerAbilities::set_fly_speed(float value) {
  _internal_set_fly_speed(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.UpdatePlayerAbilities.fly_speed)
}

// -------------------------------------------------------------------

// UnloadChunk

// .minecpp.proto.player.v1.PlayerId player_id = 1;
inline bool UnloadChunk::_internal_has_player_id() const {
  return this != internal_default_instance() && player_id_ != nullptr;
}
inline bool UnloadChunk::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::minecpp::proto::player::v1::PlayerId& UnloadChunk::_internal_player_id() const {
  const ::minecpp::proto::player::v1::PlayerId* p = player_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::PlayerId&>(
      ::minecpp::proto::player::v1::_PlayerId_default_instance_);
}
inline const ::minecpp::proto::player::v1::PlayerId& UnloadChunk::player_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UnloadChunk.player_id)
  return _internal_player_id();
}
inline void UnloadChunk::unsafe_arena_set_allocated_player_id(
    ::minecpp::proto::player::v1::PlayerId* player_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  player_id_ = player_id;
  if (player_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.UnloadChunk.player_id)
}
inline ::minecpp::proto::player::v1::PlayerId* UnloadChunk::release_player_id() {
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* UnloadChunk::unsafe_arena_release_player_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.UnloadChunk.player_id)
  
  ::minecpp::proto::player::v1::PlayerId* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::PlayerId* UnloadChunk::_internal_mutable_player_id() {
  
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::PlayerId>(GetArenaForAllocation());
    player_id_ = p;
  }
  return player_id_;
}
inline ::minecpp::proto::player::v1::PlayerId* UnloadChunk::mutable_player_id() {
  ::minecpp::proto::player::v1::PlayerId* _msg = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.UnloadChunk.player_id)
  return _msg;
}
inline void UnloadChunk::set_allocated_player_id(::minecpp::proto::player::v1::PlayerId* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id));
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    
  } else {
    
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.UnloadChunk.player_id)
}

// .minecpp.proto.common.v1.ChunkPosition chunk_position = 2;
inline bool UnloadChunk::_internal_has_chunk_position() const {
  return this != internal_default_instance() && chunk_position_ != nullptr;
}
inline bool UnloadChunk::has_chunk_position() const {
  return _internal_has_chunk_position();
}
inline const ::minecpp::proto::common::v1::ChunkPosition& UnloadChunk::_internal_chunk_position() const {
  const ::minecpp::proto::common::v1::ChunkPosition* p = chunk_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::common::v1::ChunkPosition&>(
      ::minecpp::proto::common::v1::_ChunkPosition_default_instance_);
}
inline const ::minecpp::proto::common::v1::ChunkPosition& UnloadChunk::chunk_position() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.UnloadChunk.chunk_position)
  return _internal_chunk_position();
}
inline void UnloadChunk::unsafe_arena_set_allocated_chunk_position(
    ::minecpp::proto::common::v1::ChunkPosition* chunk_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk_position_);
  }
  chunk_position_ = chunk_position;
  if (chunk_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.UnloadChunk.chunk_position)
}
inline ::minecpp::proto::common::v1::ChunkPosition* UnloadChunk::release_chunk_position() {
  
  ::minecpp::proto::common::v1::ChunkPosition* temp = chunk_position_;
  chunk_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::common::v1::ChunkPosition* UnloadChunk::unsafe_arena_release_chunk_position() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.UnloadChunk.chunk_position)
  
  ::minecpp::proto::common::v1::ChunkPosition* temp = chunk_position_;
  chunk_position_ = nullptr;
  return temp;
}
inline ::minecpp::proto::common::v1::ChunkPosition* UnloadChunk::_internal_mutable_chunk_position() {
  
  if (chunk_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::common::v1::ChunkPosition>(GetArenaForAllocation());
    chunk_position_ = p;
  }
  return chunk_position_;
}
inline ::minecpp::proto::common::v1::ChunkPosition* UnloadChunk::mutable_chunk_position() {
  ::minecpp::proto::common::v1::ChunkPosition* _msg = _internal_mutable_chunk_position();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.UnloadChunk.chunk_position)
  return _msg;
}
inline void UnloadChunk::set_allocated_chunk_position(::minecpp::proto::common::v1::ChunkPosition* chunk_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk_position_);
  }
  if (chunk_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chunk_position));
    if (message_arena != submessage_arena) {
      chunk_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk_position, submessage_arena);
    }
    
  } else {
    
  }
  chunk_position_ = chunk_position;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.UnloadChunk.chunk_position)
}

// -------------------------------------------------------------------

// PlayerList

// repeated .minecpp.proto.player.v1.Status list = 1;
inline int PlayerList::_internal_list_size() const {
  return list_.size();
}
inline int PlayerList::list_size() const {
  return _internal_list_size();
}
inline ::minecpp::proto::player::v1::Status* PlayerList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.PlayerList.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::Status >*
PlayerList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:minecpp.proto.event.clientbound.v1.PlayerList.list)
  return &list_;
}
inline const ::minecpp::proto::player::v1::Status& PlayerList::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::minecpp::proto::player::v1::Status& PlayerList::list(int index) const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.PlayerList.list)
  return _internal_list(index);
}
inline ::minecpp::proto::player::v1::Status* PlayerList::_internal_add_list() {
  return list_.Add();
}
inline ::minecpp::proto::player::v1::Status* PlayerList::add_list() {
  ::minecpp::proto::player::v1::Status* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:minecpp.proto.event.clientbound.v1.PlayerList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::player::v1::Status >&
PlayerList::list() const {
  // @@protoc_insertion_point(field_list:minecpp.proto.event.clientbound.v1.PlayerList.list)
  return list_;
}

// -------------------------------------------------------------------

// EntityList

// repeated .minecpp.proto.entity.v1.Entity list = 1;
inline int EntityList::_internal_list_size() const {
  return list_.size();
}
inline int EntityList::list_size() const {
  return _internal_list_size();
}
inline ::minecpp::proto::entity::v1::Entity* EntityList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.EntityList.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::entity::v1::Entity >*
EntityList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:minecpp.proto.event.clientbound.v1.EntityList.list)
  return &list_;
}
inline const ::minecpp::proto::entity::v1::Entity& EntityList::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::minecpp::proto::entity::v1::Entity& EntityList::list(int index) const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.EntityList.list)
  return _internal_list(index);
}
inline ::minecpp::proto::entity::v1::Entity* EntityList::_internal_add_list() {
  return list_.Add();
}
inline ::minecpp::proto::entity::v1::Entity* EntityList::add_list() {
  ::minecpp::proto::entity::v1::Entity* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:minecpp.proto.event.clientbound.v1.EntityList.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::entity::v1::Entity >&
EntityList::list() const {
  // @@protoc_insertion_point(field_list:minecpp.proto.event.clientbound.v1.EntityList.list)
  return list_;
}

// -------------------------------------------------------------------

// AcceptPlayer

// .minecpp.proto.common.v1.Gameplay gameplay = 1;
inline bool AcceptPlayer::_internal_has_gameplay() const {
  return this != internal_default_instance() && gameplay_ != nullptr;
}
inline bool AcceptPlayer::has_gameplay() const {
  return _internal_has_gameplay();
}
inline const ::minecpp::proto::common::v1::Gameplay& AcceptPlayer::_internal_gameplay() const {
  const ::minecpp::proto::common::v1::Gameplay* p = gameplay_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::common::v1::Gameplay&>(
      ::minecpp::proto::common::v1::_Gameplay_default_instance_);
}
inline const ::minecpp::proto::common::v1::Gameplay& AcceptPlayer::gameplay() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AcceptPlayer.gameplay)
  return _internal_gameplay();
}
inline void AcceptPlayer::unsafe_arena_set_allocated_gameplay(
    ::minecpp::proto::common::v1::Gameplay* gameplay) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameplay_);
  }
  gameplay_ = gameplay;
  if (gameplay) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.AcceptPlayer.gameplay)
}
inline ::minecpp::proto::common::v1::Gameplay* AcceptPlayer::release_gameplay() {
  
  ::minecpp::proto::common::v1::Gameplay* temp = gameplay_;
  gameplay_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::common::v1::Gameplay* AcceptPlayer::unsafe_arena_release_gameplay() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.AcceptPlayer.gameplay)
  
  ::minecpp::proto::common::v1::Gameplay* temp = gameplay_;
  gameplay_ = nullptr;
  return temp;
}
inline ::minecpp::proto::common::v1::Gameplay* AcceptPlayer::_internal_mutable_gameplay() {
  
  if (gameplay_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::common::v1::Gameplay>(GetArenaForAllocation());
    gameplay_ = p;
  }
  return gameplay_;
}
inline ::minecpp::proto::common::v1::Gameplay* AcceptPlayer::mutable_gameplay() {
  ::minecpp::proto::common::v1::Gameplay* _msg = _internal_mutable_gameplay();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.AcceptPlayer.gameplay)
  return _msg;
}
inline void AcceptPlayer::set_allocated_gameplay(::minecpp::proto::common::v1::Gameplay* gameplay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameplay_);
  }
  if (gameplay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gameplay));
    if (message_arena != submessage_arena) {
      gameplay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gameplay, submessage_arena);
    }
    
  } else {
    
  }
  gameplay_ = gameplay;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.AcceptPlayer.gameplay)
}

// .minecpp.proto.player.v1.Player player = 2;
inline bool AcceptPlayer::_internal_has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline bool AcceptPlayer::has_player() const {
  return _internal_has_player();
}
inline const ::minecpp::proto::player::v1::Player& AcceptPlayer::_internal_player() const {
  const ::minecpp::proto::player::v1::Player* p = player_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::player::v1::Player&>(
      ::minecpp::proto::player::v1::_Player_default_instance_);
}
inline const ::minecpp::proto::player::v1::Player& AcceptPlayer::player() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.AcceptPlayer.player)
  return _internal_player();
}
inline void AcceptPlayer::unsafe_arena_set_allocated_player(
    ::minecpp::proto::player::v1::Player* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.clientbound.v1.AcceptPlayer.player)
}
inline ::minecpp::proto::player::v1::Player* AcceptPlayer::release_player() {
  
  ::minecpp::proto::player::v1::Player* temp = player_;
  player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::player::v1::Player* AcceptPlayer::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.AcceptPlayer.player)
  
  ::minecpp::proto::player::v1::Player* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::minecpp::proto::player::v1::Player* AcceptPlayer::_internal_mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::player::v1::Player>(GetArenaForAllocation());
    player_ = p;
  }
  return player_;
}
inline ::minecpp::proto::player::v1::Player* AcceptPlayer::mutable_player() {
  ::minecpp::proto::player::v1::Player* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.AcceptPlayer.player)
  return _msg;
}
inline void AcceptPlayer::set_allocated_player(::minecpp::proto::player::v1::Player* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.AcceptPlayer.player)
}

// -------------------------------------------------------------------

// DenyPlayer

// string denial_reason = 1;
inline void DenyPlayer::clear_denial_reason() {
  denial_reason_.ClearToEmpty();
}
inline const std::string& DenyPlayer::denial_reason() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.clientbound.v1.DenyPlayer.denial_reason)
  return _internal_denial_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DenyPlayer::set_denial_reason(ArgT0&& arg0, ArgT... args) {
 
 denial_reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.clientbound.v1.DenyPlayer.denial_reason)
}
inline std::string* DenyPlayer::mutable_denial_reason() {
  std::string* _s = _internal_mutable_denial_reason();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.clientbound.v1.DenyPlayer.denial_reason)
  return _s;
}
inline const std::string& DenyPlayer::_internal_denial_reason() const {
  return denial_reason_.Get();
}
inline void DenyPlayer::_internal_set_denial_reason(const std::string& value) {
  
  denial_reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DenyPlayer::_internal_mutable_denial_reason() {
  
  return denial_reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DenyPlayer::release_denial_reason() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.clientbound.v1.DenyPlayer.denial_reason)
  return denial_reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DenyPlayer::set_allocated_denial_reason(std::string* denial_reason) {
  if (denial_reason != nullptr) {
    
  } else {
    
  }
  denial_reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), denial_reason,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.v1.DenyPlayer.denial_reason)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace clientbound
}  // namespace event
}  // namespace proto
}  // namespace minecpp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fevent_2fclientbound_2fv1_2fclientbound_2eproto
