// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minecpp/proto/event/v1/event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
namespace minecpp {
namespace proto {
namespace event {
namespace v1 {
class AddPlayer;
struct AddPlayerDefaultTypeInternal;
extern AddPlayerDefaultTypeInternal _AddPlayer_default_instance_;
class AnimateHand;
struct AnimateHandDefaultTypeInternal;
extern AnimateHandDefaultTypeInternal _AnimateHand_default_instance_;
class Chat;
struct ChatDefaultTypeInternal;
extern ChatDefaultTypeInternal _Chat_default_instance_;
class ChunkCoord;
struct ChunkCoordDefaultTypeInternal;
extern ChunkCoordDefaultTypeInternal _ChunkCoord_default_instance_;
class EntityLook;
struct EntityLookDefaultTypeInternal;
extern EntityLookDefaultTypeInternal _EntityLook_default_instance_;
class EntityMove;
struct EntityMoveDefaultTypeInternal;
extern EntityMoveDefaultTypeInternal _EntityMove_default_instance_;
class LoadTerrain;
struct LoadTerrainDefaultTypeInternal;
extern LoadTerrainDefaultTypeInternal _LoadTerrain_default_instance_;
class PlayerPositionRotation;
struct PlayerPositionRotationDefaultTypeInternal;
extern PlayerPositionRotationDefaultTypeInternal _PlayerPositionRotation_default_instance_;
class RemovePlayer;
struct RemovePlayerDefaultTypeInternal;
extern RemovePlayerDefaultTypeInternal _RemovePlayer_default_instance_;
class SpawnPlayer;
struct SpawnPlayerDefaultTypeInternal;
extern SpawnPlayerDefaultTypeInternal _SpawnPlayer_default_instance_;
class TransferPlayer;
struct TransferPlayerDefaultTypeInternal;
extern TransferPlayerDefaultTypeInternal _TransferPlayer_default_instance_;
class UnloadChunk;
struct UnloadChunkDefaultTypeInternal;
extern UnloadChunkDefaultTypeInternal _UnloadChunk_default_instance_;
class UpdateBlock;
struct UpdateBlockDefaultTypeInternal;
extern UpdateBlockDefaultTypeInternal _UpdateBlock_default_instance_;
class UpdatePlayerAbilities;
struct UpdatePlayerAbilitiesDefaultTypeInternal;
extern UpdatePlayerAbilitiesDefaultTypeInternal _UpdatePlayerAbilities_default_instance_;
}  // namespace v1
}  // namespace event
}  // namespace proto
}  // namespace minecpp
PROTOBUF_NAMESPACE_OPEN
template<> ::minecpp::proto::event::v1::AddPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::AddPlayer>(Arena*);
template<> ::minecpp::proto::event::v1::AnimateHand* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::AnimateHand>(Arena*);
template<> ::minecpp::proto::event::v1::Chat* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::Chat>(Arena*);
template<> ::minecpp::proto::event::v1::ChunkCoord* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::ChunkCoord>(Arena*);
template<> ::minecpp::proto::event::v1::EntityLook* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::EntityLook>(Arena*);
template<> ::minecpp::proto::event::v1::EntityMove* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::EntityMove>(Arena*);
template<> ::minecpp::proto::event::v1::LoadTerrain* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::LoadTerrain>(Arena*);
template<> ::minecpp::proto::event::v1::PlayerPositionRotation* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::PlayerPositionRotation>(Arena*);
template<> ::minecpp::proto::event::v1::RemovePlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::RemovePlayer>(Arena*);
template<> ::minecpp::proto::event::v1::SpawnPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::SpawnPlayer>(Arena*);
template<> ::minecpp::proto::event::v1::TransferPlayer* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::TransferPlayer>(Arena*);
template<> ::minecpp::proto::event::v1::UnloadChunk* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::UnloadChunk>(Arena*);
template<> ::minecpp::proto::event::v1::UpdateBlock* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::UpdateBlock>(Arena*);
template<> ::minecpp::proto::event::v1::UpdatePlayerAbilities* Arena::CreateMaybeMessage<::minecpp::proto::event::v1::UpdatePlayerAbilities>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minecpp {
namespace proto {
namespace event {
namespace v1 {

// ===================================================================

class AddPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.AddPlayer) */ {
 public:
  inline AddPlayer() : AddPlayer(nullptr) {}
  ~AddPlayer() override;
  explicit constexpr AddPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPlayer(const AddPlayer& from);
  AddPlayer(AddPlayer&& from) noexcept
    : AddPlayer() {
    *this = ::std::move(from);
  }

  inline AddPlayer& operator=(const AddPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPlayer& operator=(AddPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPlayer* internal_default_instance() {
    return reinterpret_cast<const AddPlayer*>(
               &_AddPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AddPlayer& a, AddPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddPlayer* New() const final {
    return new AddPlayer();
  }

  AddPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.AddPlayer";
  }
  protected:
  explicit AddPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kNameFieldNumber = 2,
    kGameModeFieldNumber = 3,
    kPingFieldNumber = 4,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 game_mode = 3;
  void clear_game_mode();
  ::PROTOBUF_NAMESPACE_ID::int32 game_mode() const;
  void set_game_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_game_mode() const;
  void _internal_set_game_mode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ping = 4;
  void clear_ping();
  ::PROTOBUF_NAMESPACE_ID::int32 ping() const;
  void set_ping(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ping() const;
  void _internal_set_ping(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.AddPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 game_mode_;
  ::PROTOBUF_NAMESPACE_ID::int32 ping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class SpawnPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.SpawnPlayer) */ {
 public:
  inline SpawnPlayer() : SpawnPlayer(nullptr) {}
  ~SpawnPlayer() override;
  explicit constexpr SpawnPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpawnPlayer(const SpawnPlayer& from);
  SpawnPlayer(SpawnPlayer&& from) noexcept
    : SpawnPlayer() {
    *this = ::std::move(from);
  }

  inline SpawnPlayer& operator=(const SpawnPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpawnPlayer& operator=(SpawnPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpawnPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpawnPlayer* internal_default_instance() {
    return reinterpret_cast<const SpawnPlayer*>(
               &_SpawnPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpawnPlayer& a, SpawnPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SpawnPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpawnPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpawnPlayer* New() const final {
    return new SpawnPlayer();
  }

  SpawnPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpawnPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpawnPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SpawnPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpawnPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.SpawnPlayer";
  }
  protected:
  explicit SpawnPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kIdFieldNumber = 2,
    kYawFieldNumber = 6,
    kZFieldNumber = 5,
    kPitchFieldNumber = 7,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // double x = 3;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 4;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float yaw = 6;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // double z = 5;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // float pitch = 7;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.SpawnPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  double x_;
  double y_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  float yaw_;
  double z_;
  float pitch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class EntityMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.EntityMove) */ {
 public:
  inline EntityMove() : EntityMove(nullptr) {}
  ~EntityMove() override;
  explicit constexpr EntityMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityMove(const EntityMove& from);
  EntityMove(EntityMove&& from) noexcept
    : EntityMove() {
    *this = ::std::move(from);
  }

  inline EntityMove& operator=(const EntityMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityMove& operator=(EntityMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityMove* internal_default_instance() {
    return reinterpret_cast<const EntityMove*>(
               &_EntityMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EntityMove& a, EntityMove& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityMove* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityMove* New() const final {
    return new EntityMove();
  }

  EntityMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EntityMove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.EntityMove";
  }
  protected:
  explicit EntityMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kIdFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kYawFieldNumber = 6,
    kPitchFieldNumber = 7,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 x = 3;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 y = 4;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 z = 5;
  void clear_z();
  ::PROTOBUF_NAMESPACE_ID::int32 z() const;
  void set_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_z() const;
  void _internal_set_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float yaw = 6;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 7;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.EntityMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  ::PROTOBUF_NAMESPACE_ID::int32 z_;
  float yaw_;
  float pitch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class EntityLook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.EntityLook) */ {
 public:
  inline EntityLook() : EntityLook(nullptr) {}
  ~EntityLook() override;
  explicit constexpr EntityLook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityLook(const EntityLook& from);
  EntityLook(EntityLook&& from) noexcept
    : EntityLook() {
    *this = ::std::move(from);
  }

  inline EntityLook& operator=(const EntityLook& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityLook& operator=(EntityLook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityLook& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityLook* internal_default_instance() {
    return reinterpret_cast<const EntityLook*>(
               &_EntityLook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EntityLook& a, EntityLook& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityLook* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityLook* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EntityLook* New() const final {
    return new EntityLook();
  }

  EntityLook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EntityLook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityLook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EntityLook& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityLook* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.EntityLook";
  }
  protected:
  explicit EntityLook(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kIdFieldNumber = 2,
    kYawFieldNumber = 3,
    kPitchFieldNumber = 4,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float yaw = 3;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // float pitch = 4;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.EntityLook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  float yaw_;
  float pitch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class PlayerPositionRotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.PlayerPositionRotation) */ {
 public:
  inline PlayerPositionRotation() : PlayerPositionRotation(nullptr) {}
  ~PlayerPositionRotation() override;
  explicit constexpr PlayerPositionRotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerPositionRotation(const PlayerPositionRotation& from);
  PlayerPositionRotation(PlayerPositionRotation&& from) noexcept
    : PlayerPositionRotation() {
    *this = ::std::move(from);
  }

  inline PlayerPositionRotation& operator=(const PlayerPositionRotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPositionRotation& operator=(PlayerPositionRotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerPositionRotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerPositionRotation* internal_default_instance() {
    return reinterpret_cast<const PlayerPositionRotation*>(
               &_PlayerPositionRotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerPositionRotation& a, PlayerPositionRotation& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerPositionRotation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerPositionRotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerPositionRotation* New() const final {
    return new PlayerPositionRotation();
  }

  PlayerPositionRotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerPositionRotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerPositionRotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerPositionRotation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerPositionRotation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.PlayerPositionRotation";
  }
  protected:
  explicit PlayerPositionRotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.PlayerPositionRotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class Chat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.Chat) */ {
 public:
  inline Chat() : Chat(nullptr) {}
  ~Chat() override;
  explicit constexpr Chat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chat(const Chat& from);
  Chat(Chat&& from) noexcept
    : Chat() {
    *this = ::std::move(from);
  }

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chat& operator=(Chat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chat* internal_default_instance() {
    return reinterpret_cast<const Chat*>(
               &_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Chat& a, Chat& b) {
    a.Swap(&b);
  }
  inline void Swap(Chat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Chat* New() const final {
    return new Chat();
  }

  Chat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Chat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Chat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.Chat";
  }
  protected:
  explicit Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 type = 2;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.Chat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class RemovePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.RemovePlayer) */ {
 public:
  inline RemovePlayer() : RemovePlayer(nullptr) {}
  ~RemovePlayer() override;
  explicit constexpr RemovePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemovePlayer(const RemovePlayer& from);
  RemovePlayer(RemovePlayer&& from) noexcept
    : RemovePlayer() {
    *this = ::std::move(from);
  }

  inline RemovePlayer& operator=(const RemovePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemovePlayer& operator=(RemovePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemovePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemovePlayer* internal_default_instance() {
    return reinterpret_cast<const RemovePlayer*>(
               &_RemovePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RemovePlayer& a, RemovePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(RemovePlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemovePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemovePlayer* New() const final {
    return new RemovePlayer();
  }

  RemovePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemovePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemovePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemovePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemovePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.RemovePlayer";
  }
  protected:
  explicit RemovePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kEntityIdFieldNumber = 2,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // int32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.RemovePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class UpdateBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.UpdateBlock) */ {
 public:
  inline UpdateBlock() : UpdateBlock(nullptr) {}
  ~UpdateBlock() override;
  explicit constexpr UpdateBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateBlock(const UpdateBlock& from);
  UpdateBlock(UpdateBlock&& from) noexcept
    : UpdateBlock() {
    *this = ::std::move(from);
  }

  inline UpdateBlock& operator=(const UpdateBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateBlock& operator=(UpdateBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateBlock* internal_default_instance() {
    return reinterpret_cast<const UpdateBlock*>(
               &_UpdateBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateBlock& a, UpdateBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateBlock* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateBlock* New() const final {
    return new UpdateBlock();
  }

  UpdateBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateBlock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.UpdateBlock";
  }
  protected:
  explicit UpdateBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockPositionFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // int64 block_position = 1;
  void clear_block_position();
  ::PROTOBUF_NAMESPACE_ID::int64 block_position() const;
  void set_block_position(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_block_position() const;
  void _internal_set_block_position(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 state = 2;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::uint32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.UpdateBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 block_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class AnimateHand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.AnimateHand) */ {
 public:
  inline AnimateHand() : AnimateHand(nullptr) {}
  ~AnimateHand() override;
  explicit constexpr AnimateHand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimateHand(const AnimateHand& from);
  AnimateHand(AnimateHand&& from) noexcept
    : AnimateHand() {
    *this = ::std::move(from);
  }

  inline AnimateHand& operator=(const AnimateHand& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimateHand& operator=(AnimateHand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimateHand& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimateHand* internal_default_instance() {
    return reinterpret_cast<const AnimateHand*>(
               &_AnimateHand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AnimateHand& a, AnimateHand& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimateHand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimateHand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnimateHand* New() const final {
    return new AnimateHand();
  }

  AnimateHand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnimateHand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimateHand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnimateHand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimateHand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.AnimateHand";
  }
  protected:
  explicit AnimateHand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kEntityIdFieldNumber = 2,
    kHandFieldNumber = 3,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // int32 entity_id = 2;
  void clear_entity_id();
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id() const;
  void set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entity_id() const;
  void _internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hand = 3;
  void clear_hand();
  ::PROTOBUF_NAMESPACE_ID::int32 hand() const;
  void set_hand(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hand() const;
  void _internal_set_hand(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.AnimateHand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 entity_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 hand_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class ChunkCoord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.ChunkCoord) */ {
 public:
  inline ChunkCoord() : ChunkCoord(nullptr) {}
  ~ChunkCoord() override;
  explicit constexpr ChunkCoord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChunkCoord(const ChunkCoord& from);
  ChunkCoord(ChunkCoord&& from) noexcept
    : ChunkCoord() {
    *this = ::std::move(from);
  }

  inline ChunkCoord& operator=(const ChunkCoord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkCoord& operator=(ChunkCoord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkCoord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkCoord* internal_default_instance() {
    return reinterpret_cast<const ChunkCoord*>(
               &_ChunkCoord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ChunkCoord& a, ChunkCoord& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkCoord* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkCoord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChunkCoord* New() const final {
    return new ChunkCoord();
  }

  ChunkCoord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChunkCoord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChunkCoord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChunkCoord& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkCoord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.ChunkCoord";
  }
  protected:
  explicit ChunkCoord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kZFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 z = 2;
  void clear_z();
  ::PROTOBUF_NAMESPACE_ID::int32 z() const;
  void set_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_z() const;
  void _internal_set_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.ChunkCoord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class LoadTerrain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.LoadTerrain) */ {
 public:
  inline LoadTerrain() : LoadTerrain(nullptr) {}
  ~LoadTerrain() override;
  explicit constexpr LoadTerrain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadTerrain(const LoadTerrain& from);
  LoadTerrain(LoadTerrain&& from) noexcept
    : LoadTerrain() {
    *this = ::std::move(from);
  }

  inline LoadTerrain& operator=(const LoadTerrain& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadTerrain& operator=(LoadTerrain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadTerrain& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadTerrain* internal_default_instance() {
    return reinterpret_cast<const LoadTerrain*>(
               &_LoadTerrain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LoadTerrain& a, LoadTerrain& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadTerrain* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadTerrain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadTerrain* New() const final {
    return new LoadTerrain();
  }

  LoadTerrain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadTerrain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadTerrain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadTerrain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadTerrain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.LoadTerrain";
  }
  protected:
  explicit LoadTerrain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordsFieldNumber = 3,
    kUuidFieldNumber = 1,
    kCentralChunkFieldNumber = 2,
  };
  // repeated .minecpp.proto.event.v1.ChunkCoord coords = 3;
  int coords_size() const;
  private:
  int _internal_coords_size() const;
  public:
  void clear_coords();
  ::minecpp::proto::event::v1::ChunkCoord* mutable_coords(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::event::v1::ChunkCoord >*
      mutable_coords();
  private:
  const ::minecpp::proto::event::v1::ChunkCoord& _internal_coords(int index) const;
  ::minecpp::proto::event::v1::ChunkCoord* _internal_add_coords();
  public:
  const ::minecpp::proto::event::v1::ChunkCoord& coords(int index) const;
  ::minecpp::proto::event::v1::ChunkCoord* add_coords();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::event::v1::ChunkCoord >&
      coords() const;

  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .minecpp.proto.event.v1.ChunkCoord central_chunk = 2;
  bool has_central_chunk() const;
  private:
  bool _internal_has_central_chunk() const;
  public:
  void clear_central_chunk();
  const ::minecpp::proto::event::v1::ChunkCoord& central_chunk() const;
  PROTOBUF_MUST_USE_RESULT ::minecpp::proto::event::v1::ChunkCoord* release_central_chunk();
  ::minecpp::proto::event::v1::ChunkCoord* mutable_central_chunk();
  void set_allocated_central_chunk(::minecpp::proto::event::v1::ChunkCoord* central_chunk);
  private:
  const ::minecpp::proto::event::v1::ChunkCoord& _internal_central_chunk() const;
  ::minecpp::proto::event::v1::ChunkCoord* _internal_mutable_central_chunk();
  public:
  void unsafe_arena_set_allocated_central_chunk(
      ::minecpp::proto::event::v1::ChunkCoord* central_chunk);
  ::minecpp::proto::event::v1::ChunkCoord* unsafe_arena_release_central_chunk();

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.LoadTerrain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::event::v1::ChunkCoord > coords_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::minecpp::proto::event::v1::ChunkCoord* central_chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class TransferPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.TransferPlayer) */ {
 public:
  inline TransferPlayer() : TransferPlayer(nullptr) {}
  ~TransferPlayer() override;
  explicit constexpr TransferPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferPlayer(const TransferPlayer& from);
  TransferPlayer(TransferPlayer&& from) noexcept
    : TransferPlayer() {
    *this = ::std::move(from);
  }

  inline TransferPlayer& operator=(const TransferPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferPlayer& operator=(TransferPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferPlayer* internal_default_instance() {
    return reinterpret_cast<const TransferPlayer*>(
               &_TransferPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransferPlayer& a, TransferPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferPlayer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferPlayer* New() const final {
    return new TransferPlayer();
  }

  TransferPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.TransferPlayer";
  }
  protected:
  explicit TransferPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kTargetEngineFieldNumber = 2,
  };
  // bytes player = 1;
  void clear_player();
  const std::string& player() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player();
  PROTOBUF_MUST_USE_RESULT std::string* release_player();
  void set_allocated_player(std::string* player);
  private:
  const std::string& _internal_player() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player(const std::string& value);
  std::string* _internal_mutable_player();
  public:

  // bytes target_engine = 2;
  void clear_target_engine();
  const std::string& target_engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_engine();
  PROTOBUF_MUST_USE_RESULT std::string* release_target_engine();
  void set_allocated_target_engine(std::string* target_engine);
  private:
  const std::string& _internal_target_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_engine(const std::string& value);
  std::string* _internal_mutable_target_engine();
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.TransferPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_engine_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayerAbilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.UpdatePlayerAbilities) */ {
 public:
  inline UpdatePlayerAbilities() : UpdatePlayerAbilities(nullptr) {}
  ~UpdatePlayerAbilities() override;
  explicit constexpr UpdatePlayerAbilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePlayerAbilities(const UpdatePlayerAbilities& from);
  UpdatePlayerAbilities(UpdatePlayerAbilities&& from) noexcept
    : UpdatePlayerAbilities() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerAbilities& operator=(const UpdatePlayerAbilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerAbilities& operator=(UpdatePlayerAbilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerAbilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerAbilities* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerAbilities*>(
               &_UpdatePlayerAbilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdatePlayerAbilities& a, UpdatePlayerAbilities& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerAbilities* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerAbilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayerAbilities* New() const final {
    return new UpdatePlayerAbilities();
  }

  UpdatePlayerAbilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayerAbilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerAbilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdatePlayerAbilities& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayerAbilities* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.UpdatePlayerAbilities";
  }
  protected:
  explicit UpdatePlayerAbilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kInvulnerableFieldNumber = 2,
    kIsFlyingFieldNumber = 3,
    kAllowFlyingFieldNumber = 4,
    kCreativeModeFieldNumber = 5,
    kWalkSpeedFieldNumber = 7,
    kFlySpeedFieldNumber = 8,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // bool invulnerable = 2;
  void clear_invulnerable();
  bool invulnerable() const;
  void set_invulnerable(bool value);
  private:
  bool _internal_invulnerable() const;
  void _internal_set_invulnerable(bool value);
  public:

  // bool is_flying = 3;
  void clear_is_flying();
  bool is_flying() const;
  void set_is_flying(bool value);
  private:
  bool _internal_is_flying() const;
  void _internal_set_is_flying(bool value);
  public:

  // bool allow_flying = 4;
  void clear_allow_flying();
  bool allow_flying() const;
  void set_allow_flying(bool value);
  private:
  bool _internal_allow_flying() const;
  void _internal_set_allow_flying(bool value);
  public:

  // bool creative_mode = 5;
  void clear_creative_mode();
  bool creative_mode() const;
  void set_creative_mode(bool value);
  private:
  bool _internal_creative_mode() const;
  void _internal_set_creative_mode(bool value);
  public:

  // float walk_speed = 7;
  void clear_walk_speed();
  float walk_speed() const;
  void set_walk_speed(float value);
  private:
  float _internal_walk_speed() const;
  void _internal_set_walk_speed(float value);
  public:

  // float fly_speed = 8;
  void clear_fly_speed();
  float fly_speed() const;
  void set_fly_speed(float value);
  private:
  float _internal_fly_speed() const;
  void _internal_set_fly_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.UpdatePlayerAbilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  bool invulnerable_;
  bool is_flying_;
  bool allow_flying_;
  bool creative_mode_;
  float walk_speed_;
  float fly_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class UnloadChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.event.v1.UnloadChunk) */ {
 public:
  inline UnloadChunk() : UnloadChunk(nullptr) {}
  ~UnloadChunk() override;
  explicit constexpr UnloadChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnloadChunk(const UnloadChunk& from);
  UnloadChunk(UnloadChunk&& from) noexcept
    : UnloadChunk() {
    *this = ::std::move(from);
  }

  inline UnloadChunk& operator=(const UnloadChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloadChunk& operator=(UnloadChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnloadChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnloadChunk* internal_default_instance() {
    return reinterpret_cast<const UnloadChunk*>(
               &_UnloadChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnloadChunk& a, UnloadChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloadChunk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloadChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnloadChunk* New() const final {
    return new UnloadChunk();
  }

  UnloadChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnloadChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnloadChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnloadChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnloadChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minecpp.proto.event.v1.UnloadChunk";
  }
  protected:
  explicit UnloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kXFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // int32 x = 2;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 z = 3;
  void clear_z();
  ::PROTOBUF_NAMESPACE_ID::int32 z() const;
  void set_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_z() const;
  void _internal_set_z(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minecpp.proto.event.v1.UnloadChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddPlayer

// bytes uuid = 1;
inline void AddPlayer::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& AddPlayer::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AddPlayer.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddPlayer::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AddPlayer.uuid)
}
inline std::string* AddPlayer::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.AddPlayer.uuid)
  return _s;
}
inline const std::string& AddPlayer::_internal_uuid() const {
  return uuid_.Get();
}
inline void AddPlayer::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddPlayer::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddPlayer::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.AddPlayer.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddPlayer::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.AddPlayer.uuid)
}

// string name = 2;
inline void AddPlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AddPlayer::name() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AddPlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddPlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AddPlayer.name)
}
inline std::string* AddPlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.AddPlayer.name)
  return _s;
}
inline const std::string& AddPlayer::_internal_name() const {
  return name_.Get();
}
inline void AddPlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddPlayer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddPlayer::release_name() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.AddPlayer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.AddPlayer.name)
}

// int32 game_mode = 3;
inline void AddPlayer::clear_game_mode() {
  game_mode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddPlayer::_internal_game_mode() const {
  return game_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddPlayer::game_mode() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AddPlayer.game_mode)
  return _internal_game_mode();
}
inline void AddPlayer::_internal_set_game_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  game_mode_ = value;
}
inline void AddPlayer::set_game_mode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_game_mode(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AddPlayer.game_mode)
}

// int32 ping = 4;
inline void AddPlayer::clear_ping() {
  ping_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddPlayer::_internal_ping() const {
  return ping_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddPlayer::ping() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AddPlayer.ping)
  return _internal_ping();
}
inline void AddPlayer::_internal_set_ping(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ping_ = value;
}
inline void AddPlayer::set_ping(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ping(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AddPlayer.ping)
}

// -------------------------------------------------------------------

// SpawnPlayer

// bytes uuid = 1;
inline void SpawnPlayer::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& SpawnPlayer::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpawnPlayer::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.uuid)
}
inline std::string* SpawnPlayer::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.SpawnPlayer.uuid)
  return _s;
}
inline const std::string& SpawnPlayer::_internal_uuid() const {
  return uuid_.Get();
}
inline void SpawnPlayer::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SpawnPlayer::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SpawnPlayer::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.SpawnPlayer.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SpawnPlayer::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.SpawnPlayer.uuid)
}

// int32 id = 2;
inline void SpawnPlayer::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpawnPlayer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpawnPlayer::id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.id)
  return _internal_id();
}
inline void SpawnPlayer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void SpawnPlayer::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.id)
}

// double x = 3;
inline void SpawnPlayer::clear_x() {
  x_ = 0;
}
inline double SpawnPlayer::_internal_x() const {
  return x_;
}
inline double SpawnPlayer::x() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.x)
  return _internal_x();
}
inline void SpawnPlayer::_internal_set_x(double value) {
  
  x_ = value;
}
inline void SpawnPlayer::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.x)
}

// double y = 4;
inline void SpawnPlayer::clear_y() {
  y_ = 0;
}
inline double SpawnPlayer::_internal_y() const {
  return y_;
}
inline double SpawnPlayer::y() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.y)
  return _internal_y();
}
inline void SpawnPlayer::_internal_set_y(double value) {
  
  y_ = value;
}
inline void SpawnPlayer::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.y)
}

// double z = 5;
inline void SpawnPlayer::clear_z() {
  z_ = 0;
}
inline double SpawnPlayer::_internal_z() const {
  return z_;
}
inline double SpawnPlayer::z() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.z)
  return _internal_z();
}
inline void SpawnPlayer::_internal_set_z(double value) {
  
  z_ = value;
}
inline void SpawnPlayer::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.z)
}

// float yaw = 6;
inline void SpawnPlayer::clear_yaw() {
  yaw_ = 0;
}
inline float SpawnPlayer::_internal_yaw() const {
  return yaw_;
}
inline float SpawnPlayer::yaw() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.yaw)
  return _internal_yaw();
}
inline void SpawnPlayer::_internal_set_yaw(float value) {
  
  yaw_ = value;
}
inline void SpawnPlayer::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.yaw)
}

// float pitch = 7;
inline void SpawnPlayer::clear_pitch() {
  pitch_ = 0;
}
inline float SpawnPlayer::_internal_pitch() const {
  return pitch_;
}
inline float SpawnPlayer::pitch() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.SpawnPlayer.pitch)
  return _internal_pitch();
}
inline void SpawnPlayer::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void SpawnPlayer::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.SpawnPlayer.pitch)
}

// -------------------------------------------------------------------

// EntityMove

// bytes uuid = 1;
inline void EntityMove::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& EntityMove::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntityMove::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.uuid)
}
inline std::string* EntityMove::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.EntityMove.uuid)
  return _s;
}
inline const std::string& EntityMove::_internal_uuid() const {
  return uuid_.Get();
}
inline void EntityMove::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EntityMove::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EntityMove::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.EntityMove.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EntityMove::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.EntityMove.uuid)
}

// int32 id = 2;
inline void EntityMove::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.id)
  return _internal_id();
}
inline void EntityMove::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void EntityMove::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.id)
}

// int32 x = 3;
inline void EntityMove::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::x() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.x)
  return _internal_x();
}
inline void EntityMove::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void EntityMove::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.x)
}

// int32 y = 4;
inline void EntityMove::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::y() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.y)
  return _internal_y();
}
inline void EntityMove::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void EntityMove::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.y)
}

// int32 z = 5;
inline void EntityMove::clear_z() {
  z_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::_internal_z() const {
  return z_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityMove::z() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.z)
  return _internal_z();
}
inline void EntityMove::_internal_set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  z_ = value;
}
inline void EntityMove::set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.z)
}

// float yaw = 6;
inline void EntityMove::clear_yaw() {
  yaw_ = 0;
}
inline float EntityMove::_internal_yaw() const {
  return yaw_;
}
inline float EntityMove::yaw() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.yaw)
  return _internal_yaw();
}
inline void EntityMove::_internal_set_yaw(float value) {
  
  yaw_ = value;
}
inline void EntityMove::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.yaw)
}

// float pitch = 7;
inline void EntityMove::clear_pitch() {
  pitch_ = 0;
}
inline float EntityMove::_internal_pitch() const {
  return pitch_;
}
inline float EntityMove::pitch() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityMove.pitch)
  return _internal_pitch();
}
inline void EntityMove::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void EntityMove::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityMove.pitch)
}

// -------------------------------------------------------------------

// EntityLook

// bytes uuid = 1;
inline void EntityLook::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& EntityLook::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityLook.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EntityLook::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityLook.uuid)
}
inline std::string* EntityLook::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.EntityLook.uuid)
  return _s;
}
inline const std::string& EntityLook::_internal_uuid() const {
  return uuid_.Get();
}
inline void EntityLook::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EntityLook::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EntityLook::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.EntityLook.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EntityLook::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.EntityLook.uuid)
}

// int32 id = 2;
inline void EntityLook::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityLook::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EntityLook::id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityLook.id)
  return _internal_id();
}
inline void EntityLook::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void EntityLook::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityLook.id)
}

// float yaw = 3;
inline void EntityLook::clear_yaw() {
  yaw_ = 0;
}
inline float EntityLook::_internal_yaw() const {
  return yaw_;
}
inline float EntityLook::yaw() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityLook.yaw)
  return _internal_yaw();
}
inline void EntityLook::_internal_set_yaw(float value) {
  
  yaw_ = value;
}
inline void EntityLook::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityLook.yaw)
}

// float pitch = 4;
inline void EntityLook::clear_pitch() {
  pitch_ = 0;
}
inline float EntityLook::_internal_pitch() const {
  return pitch_;
}
inline float EntityLook::pitch() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.EntityLook.pitch)
  return _internal_pitch();
}
inline void EntityLook::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void EntityLook::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.EntityLook.pitch)
}

// -------------------------------------------------------------------

// PlayerPositionRotation

// -------------------------------------------------------------------

// Chat

// string message = 1;
inline void Chat::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Chat::message() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.Chat.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chat::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.Chat.message)
}
inline std::string* Chat::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.Chat.message)
  return _s;
}
inline const std::string& Chat::_internal_message() const {
  return message_.Get();
}
inline void Chat::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chat::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chat::release_message() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.Chat.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.Chat.message)
}

// int32 type = 2;
inline void Chat::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Chat::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Chat::type() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.Chat.type)
  return _internal_type();
}
inline void Chat::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void Chat::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.Chat.type)
}

// -------------------------------------------------------------------

// RemovePlayer

// bytes uuid = 1;
inline void RemovePlayer::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& RemovePlayer::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.RemovePlayer.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemovePlayer::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.RemovePlayer.uuid)
}
inline std::string* RemovePlayer::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.RemovePlayer.uuid)
  return _s;
}
inline const std::string& RemovePlayer::_internal_uuid() const {
  return uuid_.Get();
}
inline void RemovePlayer::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemovePlayer::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemovePlayer::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.RemovePlayer.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemovePlayer::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.RemovePlayer.uuid)
}

// int32 entity_id = 2;
inline void RemovePlayer::clear_entity_id() {
  entity_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemovePlayer::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RemovePlayer::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.RemovePlayer.entity_id)
  return _internal_entity_id();
}
inline void RemovePlayer::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entity_id_ = value;
}
inline void RemovePlayer::set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.RemovePlayer.entity_id)
}

// -------------------------------------------------------------------

// UpdateBlock

// int64 block_position = 1;
inline void UpdateBlock::clear_block_position() {
  block_position_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateBlock::_internal_block_position() const {
  return block_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateBlock::block_position() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdateBlock.block_position)
  return _internal_block_position();
}
inline void UpdateBlock::_internal_set_block_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  block_position_ = value;
}
inline void UpdateBlock::set_block_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_block_position(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdateBlock.block_position)
}

// uint32 state = 2;
inline void UpdateBlock::clear_state() {
  state_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateBlock::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpdateBlock::state() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdateBlock.state)
  return _internal_state();
}
inline void UpdateBlock::_internal_set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  state_ = value;
}
inline void UpdateBlock::set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdateBlock.state)
}

// -------------------------------------------------------------------

// AnimateHand

// bytes uuid = 1;
inline void AnimateHand::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& AnimateHand::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AnimateHand.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnimateHand::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AnimateHand.uuid)
}
inline std::string* AnimateHand::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.AnimateHand.uuid)
  return _s;
}
inline const std::string& AnimateHand::_internal_uuid() const {
  return uuid_.Get();
}
inline void AnimateHand::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AnimateHand::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AnimateHand::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.AnimateHand.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AnimateHand::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.AnimateHand.uuid)
}

// int32 entity_id = 2;
inline void AnimateHand::clear_entity_id() {
  entity_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnimateHand::_internal_entity_id() const {
  return entity_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnimateHand::entity_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AnimateHand.entity_id)
  return _internal_entity_id();
}
inline void AnimateHand::_internal_set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entity_id_ = value;
}
inline void AnimateHand::set_entity_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AnimateHand.entity_id)
}

// int32 hand = 3;
inline void AnimateHand::clear_hand() {
  hand_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnimateHand::_internal_hand() const {
  return hand_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnimateHand::hand() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.AnimateHand.hand)
  return _internal_hand();
}
inline void AnimateHand::_internal_set_hand(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hand_ = value;
}
inline void AnimateHand::set_hand(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hand(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.AnimateHand.hand)
}

// -------------------------------------------------------------------

// ChunkCoord

// int32 x = 1;
inline void ChunkCoord::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChunkCoord::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChunkCoord::x() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.ChunkCoord.x)
  return _internal_x();
}
inline void ChunkCoord::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void ChunkCoord::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.ChunkCoord.x)
}

// int32 z = 2;
inline void ChunkCoord::clear_z() {
  z_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChunkCoord::_internal_z() const {
  return z_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChunkCoord::z() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.ChunkCoord.z)
  return _internal_z();
}
inline void ChunkCoord::_internal_set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  z_ = value;
}
inline void ChunkCoord::set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.ChunkCoord.z)
}

// -------------------------------------------------------------------

// LoadTerrain

// bytes uuid = 1;
inline void LoadTerrain::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& LoadTerrain::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.LoadTerrain.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadTerrain::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.LoadTerrain.uuid)
}
inline std::string* LoadTerrain::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.LoadTerrain.uuid)
  return _s;
}
inline const std::string& LoadTerrain::_internal_uuid() const {
  return uuid_.Get();
}
inline void LoadTerrain::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadTerrain::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadTerrain::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.LoadTerrain.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadTerrain::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.LoadTerrain.uuid)
}

// .minecpp.proto.event.v1.ChunkCoord central_chunk = 2;
inline bool LoadTerrain::_internal_has_central_chunk() const {
  return this != internal_default_instance() && central_chunk_ != nullptr;
}
inline bool LoadTerrain::has_central_chunk() const {
  return _internal_has_central_chunk();
}
inline void LoadTerrain::clear_central_chunk() {
  if (GetArenaForAllocation() == nullptr && central_chunk_ != nullptr) {
    delete central_chunk_;
  }
  central_chunk_ = nullptr;
}
inline const ::minecpp::proto::event::v1::ChunkCoord& LoadTerrain::_internal_central_chunk() const {
  const ::minecpp::proto::event::v1::ChunkCoord* p = central_chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::event::v1::ChunkCoord&>(
      ::minecpp::proto::event::v1::_ChunkCoord_default_instance_);
}
inline const ::minecpp::proto::event::v1::ChunkCoord& LoadTerrain::central_chunk() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.LoadTerrain.central_chunk)
  return _internal_central_chunk();
}
inline void LoadTerrain::unsafe_arena_set_allocated_central_chunk(
    ::minecpp::proto::event::v1::ChunkCoord* central_chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(central_chunk_);
  }
  central_chunk_ = central_chunk;
  if (central_chunk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.event.v1.LoadTerrain.central_chunk)
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::release_central_chunk() {
  
  ::minecpp::proto::event::v1::ChunkCoord* temp = central_chunk_;
  central_chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::unsafe_arena_release_central_chunk() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.LoadTerrain.central_chunk)
  
  ::minecpp::proto::event::v1::ChunkCoord* temp = central_chunk_;
  central_chunk_ = nullptr;
  return temp;
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::_internal_mutable_central_chunk() {
  
  if (central_chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::event::v1::ChunkCoord>(GetArenaForAllocation());
    central_chunk_ = p;
  }
  return central_chunk_;
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::mutable_central_chunk() {
  ::minecpp::proto::event::v1::ChunkCoord* _msg = _internal_mutable_central_chunk();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.LoadTerrain.central_chunk)
  return _msg;
}
inline void LoadTerrain::set_allocated_central_chunk(::minecpp::proto::event::v1::ChunkCoord* central_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete central_chunk_;
  }
  if (central_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::minecpp::proto::event::v1::ChunkCoord>::GetOwningArena(central_chunk);
    if (message_arena != submessage_arena) {
      central_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, central_chunk, submessage_arena);
    }
    
  } else {
    
  }
  central_chunk_ = central_chunk;
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.LoadTerrain.central_chunk)
}

// repeated .minecpp.proto.event.v1.ChunkCoord coords = 3;
inline int LoadTerrain::_internal_coords_size() const {
  return coords_.size();
}
inline int LoadTerrain::coords_size() const {
  return _internal_coords_size();
}
inline void LoadTerrain::clear_coords() {
  coords_.Clear();
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::mutable_coords(int index) {
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.LoadTerrain.coords)
  return coords_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::event::v1::ChunkCoord >*
LoadTerrain::mutable_coords() {
  // @@protoc_insertion_point(field_mutable_list:minecpp.proto.event.v1.LoadTerrain.coords)
  return &coords_;
}
inline const ::minecpp::proto::event::v1::ChunkCoord& LoadTerrain::_internal_coords(int index) const {
  return coords_.Get(index);
}
inline const ::minecpp::proto::event::v1::ChunkCoord& LoadTerrain::coords(int index) const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.LoadTerrain.coords)
  return _internal_coords(index);
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::_internal_add_coords() {
  return coords_.Add();
}
inline ::minecpp::proto::event::v1::ChunkCoord* LoadTerrain::add_coords() {
  ::minecpp::proto::event::v1::ChunkCoord* _add = _internal_add_coords();
  // @@protoc_insertion_point(field_add:minecpp.proto.event.v1.LoadTerrain.coords)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minecpp::proto::event::v1::ChunkCoord >&
LoadTerrain::coords() const {
  // @@protoc_insertion_point(field_list:minecpp.proto.event.v1.LoadTerrain.coords)
  return coords_;
}

// -------------------------------------------------------------------

// TransferPlayer

// bytes player = 1;
inline void TransferPlayer::clear_player() {
  player_.ClearToEmpty();
}
inline const std::string& TransferPlayer::player() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.TransferPlayer.player)
  return _internal_player();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferPlayer::set_player(ArgT0&& arg0, ArgT... args) {
 
 player_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.TransferPlayer.player)
}
inline std::string* TransferPlayer::mutable_player() {
  std::string* _s = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.TransferPlayer.player)
  return _s;
}
inline const std::string& TransferPlayer::_internal_player() const {
  return player_.Get();
}
inline void TransferPlayer::_internal_set_player(const std::string& value) {
  
  player_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferPlayer::_internal_mutable_player() {
  
  return player_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferPlayer::release_player() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.TransferPlayer.player)
  return player_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferPlayer::set_allocated_player(std::string* player) {
  if (player != nullptr) {
    
  } else {
    
  }
  player_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.TransferPlayer.player)
}

// bytes target_engine = 2;
inline void TransferPlayer::clear_target_engine() {
  target_engine_.ClearToEmpty();
}
inline const std::string& TransferPlayer::target_engine() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.TransferPlayer.target_engine)
  return _internal_target_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferPlayer::set_target_engine(ArgT0&& arg0, ArgT... args) {
 
 target_engine_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.TransferPlayer.target_engine)
}
inline std::string* TransferPlayer::mutable_target_engine() {
  std::string* _s = _internal_mutable_target_engine();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.TransferPlayer.target_engine)
  return _s;
}
inline const std::string& TransferPlayer::_internal_target_engine() const {
  return target_engine_.Get();
}
inline void TransferPlayer::_internal_set_target_engine(const std::string& value) {
  
  target_engine_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferPlayer::_internal_mutable_target_engine() {
  
  return target_engine_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferPlayer::release_target_engine() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.TransferPlayer.target_engine)
  return target_engine_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferPlayer::set_allocated_target_engine(std::string* target_engine) {
  if (target_engine != nullptr) {
    
  } else {
    
  }
  target_engine_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_engine,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.TransferPlayer.target_engine)
}

// -------------------------------------------------------------------

// UpdatePlayerAbilities

// bytes uuid = 1;
inline void UpdatePlayerAbilities::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& UpdatePlayerAbilities::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePlayerAbilities::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.uuid)
}
inline std::string* UpdatePlayerAbilities::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.UpdatePlayerAbilities.uuid)
  return _s;
}
inline const std::string& UpdatePlayerAbilities::_internal_uuid() const {
  return uuid_.Get();
}
inline void UpdatePlayerAbilities::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdatePlayerAbilities::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdatePlayerAbilities::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.UpdatePlayerAbilities.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdatePlayerAbilities::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.UpdatePlayerAbilities.uuid)
}

// bool invulnerable = 2;
inline void UpdatePlayerAbilities::clear_invulnerable() {
  invulnerable_ = false;
}
inline bool UpdatePlayerAbilities::_internal_invulnerable() const {
  return invulnerable_;
}
inline bool UpdatePlayerAbilities::invulnerable() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.invulnerable)
  return _internal_invulnerable();
}
inline void UpdatePlayerAbilities::_internal_set_invulnerable(bool value) {
  
  invulnerable_ = value;
}
inline void UpdatePlayerAbilities::set_invulnerable(bool value) {
  _internal_set_invulnerable(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.invulnerable)
}

// bool is_flying = 3;
inline void UpdatePlayerAbilities::clear_is_flying() {
  is_flying_ = false;
}
inline bool UpdatePlayerAbilities::_internal_is_flying() const {
  return is_flying_;
}
inline bool UpdatePlayerAbilities::is_flying() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.is_flying)
  return _internal_is_flying();
}
inline void UpdatePlayerAbilities::_internal_set_is_flying(bool value) {
  
  is_flying_ = value;
}
inline void UpdatePlayerAbilities::set_is_flying(bool value) {
  _internal_set_is_flying(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.is_flying)
}

// bool allow_flying = 4;
inline void UpdatePlayerAbilities::clear_allow_flying() {
  allow_flying_ = false;
}
inline bool UpdatePlayerAbilities::_internal_allow_flying() const {
  return allow_flying_;
}
inline bool UpdatePlayerAbilities::allow_flying() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.allow_flying)
  return _internal_allow_flying();
}
inline void UpdatePlayerAbilities::_internal_set_allow_flying(bool value) {
  
  allow_flying_ = value;
}
inline void UpdatePlayerAbilities::set_allow_flying(bool value) {
  _internal_set_allow_flying(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.allow_flying)
}

// bool creative_mode = 5;
inline void UpdatePlayerAbilities::clear_creative_mode() {
  creative_mode_ = false;
}
inline bool UpdatePlayerAbilities::_internal_creative_mode() const {
  return creative_mode_;
}
inline bool UpdatePlayerAbilities::creative_mode() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.creative_mode)
  return _internal_creative_mode();
}
inline void UpdatePlayerAbilities::_internal_set_creative_mode(bool value) {
  
  creative_mode_ = value;
}
inline void UpdatePlayerAbilities::set_creative_mode(bool value) {
  _internal_set_creative_mode(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.creative_mode)
}

// float walk_speed = 7;
inline void UpdatePlayerAbilities::clear_walk_speed() {
  walk_speed_ = 0;
}
inline float UpdatePlayerAbilities::_internal_walk_speed() const {
  return walk_speed_;
}
inline float UpdatePlayerAbilities::walk_speed() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.walk_speed)
  return _internal_walk_speed();
}
inline void UpdatePlayerAbilities::_internal_set_walk_speed(float value) {
  
  walk_speed_ = value;
}
inline void UpdatePlayerAbilities::set_walk_speed(float value) {
  _internal_set_walk_speed(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.walk_speed)
}

// float fly_speed = 8;
inline void UpdatePlayerAbilities::clear_fly_speed() {
  fly_speed_ = 0;
}
inline float UpdatePlayerAbilities::_internal_fly_speed() const {
  return fly_speed_;
}
inline float UpdatePlayerAbilities::fly_speed() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UpdatePlayerAbilities.fly_speed)
  return _internal_fly_speed();
}
inline void UpdatePlayerAbilities::_internal_set_fly_speed(float value) {
  
  fly_speed_ = value;
}
inline void UpdatePlayerAbilities::set_fly_speed(float value) {
  _internal_set_fly_speed(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UpdatePlayerAbilities.fly_speed)
}

// -------------------------------------------------------------------

// UnloadChunk

// bytes uuid = 1;
inline void UnloadChunk::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& UnloadChunk::uuid() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UnloadChunk.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnloadChunk::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UnloadChunk.uuid)
}
inline std::string* UnloadChunk::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.event.v1.UnloadChunk.uuid)
  return _s;
}
inline const std::string& UnloadChunk::_internal_uuid() const {
  return uuid_.Get();
}
inline void UnloadChunk::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnloadChunk::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnloadChunk::release_uuid() {
  // @@protoc_insertion_point(field_release:minecpp.proto.event.v1.UnloadChunk.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnloadChunk::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.v1.UnloadChunk.uuid)
}

// int32 x = 2;
inline void UnloadChunk::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UnloadChunk::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UnloadChunk::x() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UnloadChunk.x)
  return _internal_x();
}
inline void UnloadChunk::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void UnloadChunk::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UnloadChunk.x)
}

// int32 z = 3;
inline void UnloadChunk::clear_z() {
  z_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UnloadChunk::_internal_z() const {
  return z_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UnloadChunk::z() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.event.v1.UnloadChunk.z)
  return _internal_z();
}
inline void UnloadChunk::_internal_set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  z_ = value;
}
inline void UnloadChunk::set_z(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.event.v1.UnloadChunk.z)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace event
}  // namespace proto
}  // namespace minecpp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fevent_2fv1_2fevent_2eproto
