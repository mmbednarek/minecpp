// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minecpp/proto/service/storage/Storage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include <minecpp/proto/common/Common.pb.h>
#include <minecpp/proto/chunk/Chunk.pb.h>
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
namespace minecpp {
namespace proto {
namespace service {
namespace storage {
class ChunkSubscription;
struct ChunkSubscriptionDefaultTypeInternal;
extern ChunkSubscriptionDefaultTypeInternal _ChunkSubscription_default_instance_;
class ClientId;
struct ClientIdDefaultTypeInternal;
extern ClientIdDefaultTypeInternal _ClientId_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestChunkData;
struct RequestChunkDataDefaultTypeInternal;
extern RequestChunkDataDefaultTypeInternal _RequestChunkData_default_instance_;
class RequestChunkSubscription;
struct RequestChunkSubscriptionDefaultTypeInternal;
extern RequestChunkSubscriptionDefaultTypeInternal _RequestChunkSubscription_default_instance_;
class RequestSetClientId;
struct RequestSetClientIdDefaultTypeInternal;
extern RequestSetClientIdDefaultTypeInternal _RequestSetClientId_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseChunkData;
struct ResponseChunkDataDefaultTypeInternal;
extern ResponseChunkDataDefaultTypeInternal _ResponseChunkData_default_instance_;
class ResponseEmptyChunk;
struct ResponseEmptyChunkDefaultTypeInternal;
extern ResponseEmptyChunkDefaultTypeInternal _ResponseEmptyChunk_default_instance_;
}  // namespace storage
}  // namespace service
}  // namespace proto
}  // namespace minecpp
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace minecpp {
namespace proto {
namespace service {
namespace storage {

// ===================================================================


// -------------------------------------------------------------------

class ClientId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.ClientId) */ {
 public:
  inline ClientId() : ClientId(nullptr) {}
  ~ClientId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientId(::google::protobuf::internal::ConstantInitialized);

  ClientId(const ClientId& from);
  ClientId(ClientId&& from) noexcept
    : ClientId() {
    *this = ::std::move(from);
  }

  inline ClientId& operator=(const ClientId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientId& operator=(ClientId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientId* internal_default_instance() {
    return reinterpret_cast<const ClientId*>(
               &_ClientId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientId& a, ClientId& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClientId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ClientId& from) {
    ClientId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientId* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.ClientId";
  }
  protected:
  explicit ClientId(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1;
  void clear_value() ;
  ::uint64_t value() const;
  void set_value(::uint64_t value);

  private:
  ::uint64_t _internal_value() const;
  void _internal_set_value(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.ClientId)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class Request final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Request(::google::protobuf::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kChunkSubscription = 1,
    kChunkData = 2,
    kSetClientId = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.Request";
  }
  protected:
  explicit Request(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkSubscriptionFieldNumber = 1,
    kChunkDataFieldNumber = 2,
    kSetClientIdFieldNumber = 3,
  };
  // .minecpp.proto.service.storage.RequestChunkSubscription chunk_subscription = 1;
  bool has_chunk_subscription() const;
  private:
  bool _internal_has_chunk_subscription() const;

  public:
  void clear_chunk_subscription() ;
  const ::minecpp::proto::service::storage::RequestChunkSubscription& chunk_subscription() const;
  PROTOBUF_NODISCARD ::minecpp::proto::service::storage::RequestChunkSubscription* release_chunk_subscription();
  ::minecpp::proto::service::storage::RequestChunkSubscription* mutable_chunk_subscription();
  void set_allocated_chunk_subscription(::minecpp::proto::service::storage::RequestChunkSubscription* value);
  void unsafe_arena_set_allocated_chunk_subscription(::minecpp::proto::service::storage::RequestChunkSubscription* value);
  ::minecpp::proto::service::storage::RequestChunkSubscription* unsafe_arena_release_chunk_subscription();

  private:
  const ::minecpp::proto::service::storage::RequestChunkSubscription& _internal_chunk_subscription() const;
  ::minecpp::proto::service::storage::RequestChunkSubscription* _internal_mutable_chunk_subscription();

  public:
  // .minecpp.proto.service.storage.RequestChunkData chunk_data = 2;
  bool has_chunk_data() const;
  private:
  bool _internal_has_chunk_data() const;

  public:
  void clear_chunk_data() ;
  const ::minecpp::proto::service::storage::RequestChunkData& chunk_data() const;
  PROTOBUF_NODISCARD ::minecpp::proto::service::storage::RequestChunkData* release_chunk_data();
  ::minecpp::proto::service::storage::RequestChunkData* mutable_chunk_data();
  void set_allocated_chunk_data(::minecpp::proto::service::storage::RequestChunkData* value);
  void unsafe_arena_set_allocated_chunk_data(::minecpp::proto::service::storage::RequestChunkData* value);
  ::minecpp::proto::service::storage::RequestChunkData* unsafe_arena_release_chunk_data();

  private:
  const ::minecpp::proto::service::storage::RequestChunkData& _internal_chunk_data() const;
  ::minecpp::proto::service::storage::RequestChunkData* _internal_mutable_chunk_data();

  public:
  // .minecpp.proto.service.storage.RequestSetClientId set_client_id = 3;
  bool has_set_client_id() const;
  private:
  bool _internal_has_set_client_id() const;

  public:
  void clear_set_client_id() ;
  const ::minecpp::proto::service::storage::RequestSetClientId& set_client_id() const;
  PROTOBUF_NODISCARD ::minecpp::proto::service::storage::RequestSetClientId* release_set_client_id();
  ::minecpp::proto::service::storage::RequestSetClientId* mutable_set_client_id();
  void set_allocated_set_client_id(::minecpp::proto::service::storage::RequestSetClientId* value);
  void unsafe_arena_set_allocated_set_client_id(::minecpp::proto::service::storage::RequestSetClientId* value);
  ::minecpp::proto::service::storage::RequestSetClientId* unsafe_arena_release_set_client_id();

  private:
  const ::minecpp::proto::service::storage::RequestSetClientId& _internal_set_client_id() const;
  ::minecpp::proto::service::storage::RequestSetClientId* _internal_mutable_set_client_id();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.Request)
 private:
  class _Internal;
  void set_has_chunk_subscription();
  void set_has_chunk_data();
  void set_has_set_client_id();

  inline bool has_message() const;
  inline void clear_has_message();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::minecpp::proto::service::storage::RequestChunkSubscription* chunk_subscription_;
      ::minecpp::proto::service::storage::RequestChunkData* chunk_data_;
      ::minecpp::proto::service::storage::RequestSetClientId* set_client_id_;
    } message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class RequestChunkSubscription final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.RequestChunkSubscription) */ {
 public:
  inline RequestChunkSubscription() : RequestChunkSubscription(nullptr) {}
  ~RequestChunkSubscription() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestChunkSubscription(::google::protobuf::internal::ConstantInitialized);

  RequestChunkSubscription(const RequestChunkSubscription& from);
  RequestChunkSubscription(RequestChunkSubscription&& from) noexcept
    : RequestChunkSubscription() {
    *this = ::std::move(from);
  }

  inline RequestChunkSubscription& operator=(const RequestChunkSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestChunkSubscription& operator=(RequestChunkSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestChunkSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestChunkSubscription* internal_default_instance() {
    return reinterpret_cast<const RequestChunkSubscription*>(
               &_RequestChunkSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestChunkSubscription& a, RequestChunkSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestChunkSubscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestChunkSubscription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestChunkSubscription* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestChunkSubscription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestChunkSubscription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestChunkSubscription& from) {
    RequestChunkSubscription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestChunkSubscription* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.RequestChunkSubscription";
  }
  protected:
  explicit RequestChunkSubscription(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // .minecpp.proto.common.ChunkPosition position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::minecpp::proto::common::ChunkPosition& position() const;
  PROTOBUF_NODISCARD ::minecpp::proto::common::ChunkPosition* release_position();
  ::minecpp::proto::common::ChunkPosition* mutable_position();
  void set_allocated_position(::minecpp::proto::common::ChunkPosition* value);
  void unsafe_arena_set_allocated_position(::minecpp::proto::common::ChunkPosition* value);
  ::minecpp::proto::common::ChunkPosition* unsafe_arena_release_position();

  private:
  const ::minecpp::proto::common::ChunkPosition& _internal_position() const;
  ::minecpp::proto::common::ChunkPosition* _internal_mutable_position();

  public:
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.RequestChunkSubscription)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::minecpp::proto::common::ChunkPosition* position_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class RequestChunkData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.RequestChunkData) */ {
 public:
  inline RequestChunkData() : RequestChunkData(nullptr) {}
  ~RequestChunkData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestChunkData(::google::protobuf::internal::ConstantInitialized);

  RequestChunkData(const RequestChunkData& from);
  RequestChunkData(RequestChunkData&& from) noexcept
    : RequestChunkData() {
    *this = ::std::move(from);
  }

  inline RequestChunkData& operator=(const RequestChunkData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestChunkData& operator=(RequestChunkData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestChunkData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestChunkData* internal_default_instance() {
    return reinterpret_cast<const RequestChunkData*>(
               &_RequestChunkData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestChunkData& a, RequestChunkData& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestChunkData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestChunkData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestChunkData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestChunkData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestChunkData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestChunkData& from) {
    RequestChunkData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestChunkData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.RequestChunkData";
  }
  protected:
  explicit RequestChunkData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 1,
  };
  // .minecpp.proto.chunk.Chunk chunk_data = 1;
  bool has_chunk_data() const;
  void clear_chunk_data() ;
  const ::minecpp::proto::chunk::Chunk& chunk_data() const;
  PROTOBUF_NODISCARD ::minecpp::proto::chunk::Chunk* release_chunk_data();
  ::minecpp::proto::chunk::Chunk* mutable_chunk_data();
  void set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value);
  void unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value);
  ::minecpp::proto::chunk::Chunk* unsafe_arena_release_chunk_data();

  private:
  const ::minecpp::proto::chunk::Chunk& _internal_chunk_data() const;
  ::minecpp::proto::chunk::Chunk* _internal_mutable_chunk_data();

  public:
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.RequestChunkData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::minecpp::proto::chunk::Chunk* chunk_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class RequestSetClientId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.RequestSetClientId) */ {
 public:
  inline RequestSetClientId() : RequestSetClientId(nullptr) {}
  ~RequestSetClientId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RequestSetClientId(::google::protobuf::internal::ConstantInitialized);

  RequestSetClientId(const RequestSetClientId& from);
  RequestSetClientId(RequestSetClientId&& from) noexcept
    : RequestSetClientId() {
    *this = ::std::move(from);
  }

  inline RequestSetClientId& operator=(const RequestSetClientId& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSetClientId& operator=(RequestSetClientId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSetClientId& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSetClientId* internal_default_instance() {
    return reinterpret_cast<const RequestSetClientId*>(
               &_RequestSetClientId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestSetClientId& a, RequestSetClientId& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSetClientId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSetClientId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSetClientId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSetClientId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestSetClientId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RequestSetClientId& from) {
    RequestSetClientId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSetClientId* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.RequestSetClientId";
  }
  protected:
  explicit RequestSetClientId(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // .minecpp.proto.service.storage.ClientId client_id = 1;
  bool has_client_id() const;
  void clear_client_id() ;
  const ::minecpp::proto::service::storage::ClientId& client_id() const;
  PROTOBUF_NODISCARD ::minecpp::proto::service::storage::ClientId* release_client_id();
  ::minecpp::proto::service::storage::ClientId* mutable_client_id();
  void set_allocated_client_id(::minecpp::proto::service::storage::ClientId* value);
  void unsafe_arena_set_allocated_client_id(::minecpp::proto::service::storage::ClientId* value);
  ::minecpp::proto::service::storage::ClientId* unsafe_arena_release_client_id();

  private:
  const ::minecpp::proto::service::storage::ClientId& _internal_client_id() const;
  ::minecpp::proto::service::storage::ClientId* _internal_mutable_client_id();

  public:
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.RequestSetClientId)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::minecpp::proto::service::storage::ClientId* client_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class Response final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Response(::google::protobuf::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kChunkData = 1,
    kEmptyChunk = 2,
    MESSAGE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.Response";
  }
  protected:
  explicit Response(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 1,
    kEmptyChunkFieldNumber = 2,
  };
  // .minecpp.proto.service.storage.ResponseChunkData chunk_data = 1;
  bool has_chunk_data() const;
  private:
  bool _internal_has_chunk_data() const;

  public:
  void clear_chunk_data() ;
  const ::minecpp::proto::service::storage::ResponseChunkData& chunk_data() const;
  PROTOBUF_NODISCARD ::minecpp::proto::service::storage::ResponseChunkData* release_chunk_data();
  ::minecpp::proto::service::storage::ResponseChunkData* mutable_chunk_data();
  void set_allocated_chunk_data(::minecpp::proto::service::storage::ResponseChunkData* value);
  void unsafe_arena_set_allocated_chunk_data(::minecpp::proto::service::storage::ResponseChunkData* value);
  ::minecpp::proto::service::storage::ResponseChunkData* unsafe_arena_release_chunk_data();

  private:
  const ::minecpp::proto::service::storage::ResponseChunkData& _internal_chunk_data() const;
  ::minecpp::proto::service::storage::ResponseChunkData* _internal_mutable_chunk_data();

  public:
  // .minecpp.proto.service.storage.ResponseEmptyChunk empty_chunk = 2;
  bool has_empty_chunk() const;
  private:
  bool _internal_has_empty_chunk() const;

  public:
  void clear_empty_chunk() ;
  const ::minecpp::proto::service::storage::ResponseEmptyChunk& empty_chunk() const;
  PROTOBUF_NODISCARD ::minecpp::proto::service::storage::ResponseEmptyChunk* release_empty_chunk();
  ::minecpp::proto::service::storage::ResponseEmptyChunk* mutable_empty_chunk();
  void set_allocated_empty_chunk(::minecpp::proto::service::storage::ResponseEmptyChunk* value);
  void unsafe_arena_set_allocated_empty_chunk(::minecpp::proto::service::storage::ResponseEmptyChunk* value);
  ::minecpp::proto::service::storage::ResponseEmptyChunk* unsafe_arena_release_empty_chunk();

  private:
  const ::minecpp::proto::service::storage::ResponseEmptyChunk& _internal_empty_chunk() const;
  ::minecpp::proto::service::storage::ResponseEmptyChunk* _internal_mutable_empty_chunk();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.Response)
 private:
  class _Internal;
  void set_has_chunk_data();
  void set_has_empty_chunk();

  inline bool has_message() const;
  inline void clear_has_message();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::minecpp::proto::service::storage::ResponseChunkData* chunk_data_;
      ::minecpp::proto::service::storage::ResponseEmptyChunk* empty_chunk_;
    } message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class ResponseEmptyChunk final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.ResponseEmptyChunk) */ {
 public:
  inline ResponseEmptyChunk() : ResponseEmptyChunk(nullptr) {}
  ~ResponseEmptyChunk() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseEmptyChunk(::google::protobuf::internal::ConstantInitialized);

  ResponseEmptyChunk(const ResponseEmptyChunk& from);
  ResponseEmptyChunk(ResponseEmptyChunk&& from) noexcept
    : ResponseEmptyChunk() {
    *this = ::std::move(from);
  }

  inline ResponseEmptyChunk& operator=(const ResponseEmptyChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEmptyChunk& operator=(ResponseEmptyChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEmptyChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEmptyChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseEmptyChunk*>(
               &_ResponseEmptyChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResponseEmptyChunk& a, ResponseEmptyChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEmptyChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEmptyChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEmptyChunk* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEmptyChunk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResponseEmptyChunk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResponseEmptyChunk& from) {
    ResponseEmptyChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEmptyChunk* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.ResponseEmptyChunk";
  }
  protected:
  explicit ResponseEmptyChunk(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // .minecpp.proto.common.ChunkPosition position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::minecpp::proto::common::ChunkPosition& position() const;
  PROTOBUF_NODISCARD ::minecpp::proto::common::ChunkPosition* release_position();
  ::minecpp::proto::common::ChunkPosition* mutable_position();
  void set_allocated_position(::minecpp::proto::common::ChunkPosition* value);
  void unsafe_arena_set_allocated_position(::minecpp::proto::common::ChunkPosition* value);
  ::minecpp::proto::common::ChunkPosition* unsafe_arena_release_position();

  private:
  const ::minecpp::proto::common::ChunkPosition& _internal_position() const;
  ::minecpp::proto::common::ChunkPosition* _internal_mutable_position();

  public:
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.ResponseEmptyChunk)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::minecpp::proto::common::ChunkPosition* position_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class ResponseChunkData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.ResponseChunkData) */ {
 public:
  inline ResponseChunkData() : ResponseChunkData(nullptr) {}
  ~ResponseChunkData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseChunkData(::google::protobuf::internal::ConstantInitialized);

  ResponseChunkData(const ResponseChunkData& from);
  ResponseChunkData(ResponseChunkData&& from) noexcept
    : ResponseChunkData() {
    *this = ::std::move(from);
  }

  inline ResponseChunkData& operator=(const ResponseChunkData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseChunkData& operator=(ResponseChunkData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseChunkData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseChunkData* internal_default_instance() {
    return reinterpret_cast<const ResponseChunkData*>(
               &_ResponseChunkData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResponseChunkData& a, ResponseChunkData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseChunkData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseChunkData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseChunkData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseChunkData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResponseChunkData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ResponseChunkData& from) {
    ResponseChunkData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseChunkData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.ResponseChunkData";
  }
  protected:
  explicit ResponseChunkData(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 1,
  };
  // .minecpp.proto.chunk.Chunk chunk_data = 1;
  bool has_chunk_data() const;
  void clear_chunk_data() ;
  const ::minecpp::proto::chunk::Chunk& chunk_data() const;
  PROTOBUF_NODISCARD ::minecpp::proto::chunk::Chunk* release_chunk_data();
  ::minecpp::proto::chunk::Chunk* mutable_chunk_data();
  void set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value);
  void unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value);
  ::minecpp::proto::chunk::Chunk* unsafe_arena_release_chunk_data();

  private:
  const ::minecpp::proto::chunk::Chunk& _internal_chunk_data() const;
  ::minecpp::proto::chunk::Chunk* _internal_mutable_chunk_data();

  public:
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.ResponseChunkData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::minecpp::proto::chunk::Chunk* chunk_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};// -------------------------------------------------------------------

class ChunkSubscription final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.ChunkSubscription) */ {
 public:
  inline ChunkSubscription() : ChunkSubscription(nullptr) {}
  ~ChunkSubscription() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChunkSubscription(::google::protobuf::internal::ConstantInitialized);

  ChunkSubscription(const ChunkSubscription& from);
  ChunkSubscription(ChunkSubscription&& from) noexcept
    : ChunkSubscription() {
    *this = ::std::move(from);
  }

  inline ChunkSubscription& operator=(const ChunkSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkSubscription& operator=(ChunkSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkSubscription* internal_default_instance() {
    return reinterpret_cast<const ChunkSubscription*>(
               &_ChunkSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChunkSubscription& a, ChunkSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(ChunkSubscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkSubscription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkSubscription* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChunkSubscription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChunkSubscription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChunkSubscription& from) {
    ChunkSubscription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChunkSubscription* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "minecpp.proto.service.storage.ChunkSubscription";
  }
  protected:
  explicit ChunkSubscription(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 1,
  };
  // repeated .minecpp.proto.service.storage.ClientId client_ids = 1;
  int client_ids_size() const;
  private:
  int _internal_client_ids_size() const;

  public:
  void clear_client_ids() ;
  ::minecpp::proto::service::storage::ClientId* mutable_client_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::minecpp::proto::service::storage::ClientId >*
      mutable_client_ids();
  private:
  const ::google::protobuf::RepeatedPtrField<::minecpp::proto::service::storage::ClientId>& _internal_client_ids() const;
  ::google::protobuf::RepeatedPtrField<::minecpp::proto::service::storage::ClientId>* _internal_mutable_client_ids();
  public:
  const ::minecpp::proto::service::storage::ClientId& client_ids(int index) const;
  ::minecpp::proto::service::storage::ClientId* add_client_ids();
  const ::google::protobuf::RepeatedPtrField< ::minecpp::proto::service::storage::ClientId >&
      client_ids() const;
  // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.ChunkSubscription)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::minecpp::proto::service::storage::ClientId > client_ids_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ClientId

// uint64 value = 1;
inline void ClientId::clear_value() {
  _impl_.value_ = ::uint64_t{0u};
}
inline ::uint64_t ClientId::value() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.ClientId.value)
  return _internal_value();
}
inline void ClientId::set_value(::uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:minecpp.proto.service.storage.ClientId.value)
}
inline ::uint64_t ClientId::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void ClientId::_internal_set_value(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Request

// .minecpp.proto.service.storage.RequestChunkSubscription chunk_subscription = 1;
inline bool Request::has_chunk_subscription() const {
  return message_case() == kChunkSubscription;
}
inline bool Request::_internal_has_chunk_subscription() const {
  return message_case() == kChunkSubscription;
}
inline void Request::set_has_chunk_subscription() {
  _impl_._oneof_case_[0] = kChunkSubscription;
}
inline void Request::clear_chunk_subscription() {
  if (message_case() == kChunkSubscription) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.chunk_subscription_;
    }
    clear_has_message();
  }
}
inline ::minecpp::proto::service::storage::RequestChunkSubscription* Request::release_chunk_subscription() {
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.Request.chunk_subscription)
  if (message_case() == kChunkSubscription) {
    clear_has_message();
    ::minecpp::proto::service::storage::RequestChunkSubscription* temp = _impl_.message_.chunk_subscription_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.chunk_subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::service::storage::RequestChunkSubscription& Request::_internal_chunk_subscription() const {
  return message_case() == kChunkSubscription
      ? *_impl_.message_.chunk_subscription_
      : reinterpret_cast<::minecpp::proto::service::storage::RequestChunkSubscription&>(::minecpp::proto::service::storage::_RequestChunkSubscription_default_instance_);
}
inline const ::minecpp::proto::service::storage::RequestChunkSubscription& Request::chunk_subscription() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.Request.chunk_subscription)
  return _internal_chunk_subscription();
}
inline ::minecpp::proto::service::storage::RequestChunkSubscription* Request::unsafe_arena_release_chunk_subscription() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.Request.chunk_subscription)
  if (message_case() == kChunkSubscription) {
    clear_has_message();
    ::minecpp::proto::service::storage::RequestChunkSubscription* temp = _impl_.message_.chunk_subscription_;
    _impl_.message_.chunk_subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_chunk_subscription(::minecpp::proto::service::storage::RequestChunkSubscription* chunk_subscription) {
  clear_message();
  if (chunk_subscription) {
    set_has_chunk_subscription();
    _impl_.message_.chunk_subscription_ = chunk_subscription;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.Request.chunk_subscription)
}
inline ::minecpp::proto::service::storage::RequestChunkSubscription* Request::_internal_mutable_chunk_subscription() {
  if (message_case() != kChunkSubscription) {
    clear_message();
    set_has_chunk_subscription();
    _impl_.message_.chunk_subscription_ = CreateMaybeMessage< ::minecpp::proto::service::storage::RequestChunkSubscription >(GetArenaForAllocation());
  }
  return _impl_.message_.chunk_subscription_;
}
inline ::minecpp::proto::service::storage::RequestChunkSubscription* Request::mutable_chunk_subscription() {
  ::minecpp::proto::service::storage::RequestChunkSubscription* _msg = _internal_mutable_chunk_subscription();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.Request.chunk_subscription)
  return _msg;
}

// .minecpp.proto.service.storage.RequestChunkData chunk_data = 2;
inline bool Request::has_chunk_data() const {
  return message_case() == kChunkData;
}
inline bool Request::_internal_has_chunk_data() const {
  return message_case() == kChunkData;
}
inline void Request::set_has_chunk_data() {
  _impl_._oneof_case_[0] = kChunkData;
}
inline void Request::clear_chunk_data() {
  if (message_case() == kChunkData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.chunk_data_;
    }
    clear_has_message();
  }
}
inline ::minecpp::proto::service::storage::RequestChunkData* Request::release_chunk_data() {
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.Request.chunk_data)
  if (message_case() == kChunkData) {
    clear_has_message();
    ::minecpp::proto::service::storage::RequestChunkData* temp = _impl_.message_.chunk_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.chunk_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::service::storage::RequestChunkData& Request::_internal_chunk_data() const {
  return message_case() == kChunkData
      ? *_impl_.message_.chunk_data_
      : reinterpret_cast<::minecpp::proto::service::storage::RequestChunkData&>(::minecpp::proto::service::storage::_RequestChunkData_default_instance_);
}
inline const ::minecpp::proto::service::storage::RequestChunkData& Request::chunk_data() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.Request.chunk_data)
  return _internal_chunk_data();
}
inline ::minecpp::proto::service::storage::RequestChunkData* Request::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.Request.chunk_data)
  if (message_case() == kChunkData) {
    clear_has_message();
    ::minecpp::proto::service::storage::RequestChunkData* temp = _impl_.message_.chunk_data_;
    _impl_.message_.chunk_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_chunk_data(::minecpp::proto::service::storage::RequestChunkData* chunk_data) {
  clear_message();
  if (chunk_data) {
    set_has_chunk_data();
    _impl_.message_.chunk_data_ = chunk_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.Request.chunk_data)
}
inline ::minecpp::proto::service::storage::RequestChunkData* Request::_internal_mutable_chunk_data() {
  if (message_case() != kChunkData) {
    clear_message();
    set_has_chunk_data();
    _impl_.message_.chunk_data_ = CreateMaybeMessage< ::minecpp::proto::service::storage::RequestChunkData >(GetArenaForAllocation());
  }
  return _impl_.message_.chunk_data_;
}
inline ::minecpp::proto::service::storage::RequestChunkData* Request::mutable_chunk_data() {
  ::minecpp::proto::service::storage::RequestChunkData* _msg = _internal_mutable_chunk_data();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.Request.chunk_data)
  return _msg;
}

// .minecpp.proto.service.storage.RequestSetClientId set_client_id = 3;
inline bool Request::has_set_client_id() const {
  return message_case() == kSetClientId;
}
inline bool Request::_internal_has_set_client_id() const {
  return message_case() == kSetClientId;
}
inline void Request::set_has_set_client_id() {
  _impl_._oneof_case_[0] = kSetClientId;
}
inline void Request::clear_set_client_id() {
  if (message_case() == kSetClientId) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.set_client_id_;
    }
    clear_has_message();
  }
}
inline ::minecpp::proto::service::storage::RequestSetClientId* Request::release_set_client_id() {
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.Request.set_client_id)
  if (message_case() == kSetClientId) {
    clear_has_message();
    ::minecpp::proto::service::storage::RequestSetClientId* temp = _impl_.message_.set_client_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.set_client_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::service::storage::RequestSetClientId& Request::_internal_set_client_id() const {
  return message_case() == kSetClientId
      ? *_impl_.message_.set_client_id_
      : reinterpret_cast<::minecpp::proto::service::storage::RequestSetClientId&>(::minecpp::proto::service::storage::_RequestSetClientId_default_instance_);
}
inline const ::minecpp::proto::service::storage::RequestSetClientId& Request::set_client_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.Request.set_client_id)
  return _internal_set_client_id();
}
inline ::minecpp::proto::service::storage::RequestSetClientId* Request::unsafe_arena_release_set_client_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.Request.set_client_id)
  if (message_case() == kSetClientId) {
    clear_has_message();
    ::minecpp::proto::service::storage::RequestSetClientId* temp = _impl_.message_.set_client_id_;
    _impl_.message_.set_client_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_set_client_id(::minecpp::proto::service::storage::RequestSetClientId* set_client_id) {
  clear_message();
  if (set_client_id) {
    set_has_set_client_id();
    _impl_.message_.set_client_id_ = set_client_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.Request.set_client_id)
}
inline ::minecpp::proto::service::storage::RequestSetClientId* Request::_internal_mutable_set_client_id() {
  if (message_case() != kSetClientId) {
    clear_message();
    set_has_set_client_id();
    _impl_.message_.set_client_id_ = CreateMaybeMessage< ::minecpp::proto::service::storage::RequestSetClientId >(GetArenaForAllocation());
  }
  return _impl_.message_.set_client_id_;
}
inline ::minecpp::proto::service::storage::RequestSetClientId* Request::mutable_set_client_id() {
  ::minecpp::proto::service::storage::RequestSetClientId* _msg = _internal_mutable_set_client_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.Request.set_client_id)
  return _msg;
}

inline bool Request::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Request::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Request::MessageCase Request::message_case() const {
  return Request::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestChunkSubscription

// .minecpp.proto.common.ChunkPosition position = 1;
inline bool RequestChunkSubscription::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::minecpp::proto::common::ChunkPosition& RequestChunkSubscription::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::minecpp::proto::common::ChunkPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::common::ChunkPosition&>(::minecpp::proto::common::_ChunkPosition_default_instance_);
}
inline const ::minecpp::proto::common::ChunkPosition& RequestChunkSubscription::position() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.RequestChunkSubscription.position)
  return _internal_position();
}
inline void RequestChunkSubscription::unsafe_arena_set_allocated_position(::minecpp::proto::common::ChunkPosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::minecpp::proto::common::ChunkPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.RequestChunkSubscription.position)
}
inline ::minecpp::proto::common::ChunkPosition* RequestChunkSubscription::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::common::ChunkPosition* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::minecpp::proto::common::ChunkPosition* RequestChunkSubscription::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.RequestChunkSubscription.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::common::ChunkPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::minecpp::proto::common::ChunkPosition* RequestChunkSubscription::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::common::ChunkPosition>(GetArenaForAllocation());
    _impl_.position_ = reinterpret_cast<::minecpp::proto::common::ChunkPosition*>(p);
  }
  return _impl_.position_;
}
inline ::minecpp::proto::common::ChunkPosition* RequestChunkSubscription::mutable_position() {
  ::minecpp::proto::common::ChunkPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.RequestChunkSubscription.position)
  return _msg;
}
inline void RequestChunkSubscription::set_allocated_position(::minecpp::proto::common::ChunkPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::minecpp::proto::common::ChunkPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.RequestChunkSubscription.position)
}

// -------------------------------------------------------------------

// RequestChunkData

// .minecpp.proto.chunk.Chunk chunk_data = 1;
inline bool RequestChunkData::has_chunk_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunk_data_ != nullptr);
  return value;
}
inline const ::minecpp::proto::chunk::Chunk& RequestChunkData::_internal_chunk_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::minecpp::proto::chunk::Chunk* p = _impl_.chunk_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::chunk::Chunk&>(::minecpp::proto::chunk::_Chunk_default_instance_);
}
inline const ::minecpp::proto::chunk::Chunk& RequestChunkData::chunk_data() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.RequestChunkData.chunk_data)
  return _internal_chunk_data();
}
inline void RequestChunkData::unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chunk_data_);
  }
  _impl_.chunk_data_ = reinterpret_cast<::minecpp::proto::chunk::Chunk*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.RequestChunkData.chunk_data)
}
inline ::minecpp::proto::chunk::Chunk* RequestChunkData::release_chunk_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::chunk::Chunk* released = _impl_.chunk_data_;
  _impl_.chunk_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::minecpp::proto::chunk::Chunk* RequestChunkData::unsafe_arena_release_chunk_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.RequestChunkData.chunk_data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::chunk::Chunk* temp = _impl_.chunk_data_;
  _impl_.chunk_data_ = nullptr;
  return temp;
}
inline ::minecpp::proto::chunk::Chunk* RequestChunkData::_internal_mutable_chunk_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.chunk_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::chunk::Chunk>(GetArenaForAllocation());
    _impl_.chunk_data_ = reinterpret_cast<::minecpp::proto::chunk::Chunk*>(p);
  }
  return _impl_.chunk_data_;
}
inline ::minecpp::proto::chunk::Chunk* RequestChunkData::mutable_chunk_data() {
  ::minecpp::proto::chunk::Chunk* _msg = _internal_mutable_chunk_data();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.RequestChunkData.chunk_data)
  return _msg;
}
inline void RequestChunkData::set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chunk_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.chunk_data_ = reinterpret_cast<::minecpp::proto::chunk::Chunk*>(value);
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.RequestChunkData.chunk_data)
}

// -------------------------------------------------------------------

// RequestSetClientId

// .minecpp.proto.service.storage.ClientId client_id = 1;
inline bool RequestSetClientId::has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_id_ != nullptr);
  return value;
}
inline void RequestSetClientId::clear_client_id() {
  if (_impl_.client_id_ != nullptr) _impl_.client_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::minecpp::proto::service::storage::ClientId& RequestSetClientId::_internal_client_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::minecpp::proto::service::storage::ClientId* p = _impl_.client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::service::storage::ClientId&>(::minecpp::proto::service::storage::_ClientId_default_instance_);
}
inline const ::minecpp::proto::service::storage::ClientId& RequestSetClientId::client_id() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.RequestSetClientId.client_id)
  return _internal_client_id();
}
inline void RequestSetClientId::unsafe_arena_set_allocated_client_id(::minecpp::proto::service::storage::ClientId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.client_id_);
  }
  _impl_.client_id_ = reinterpret_cast<::minecpp::proto::service::storage::ClientId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.RequestSetClientId.client_id)
}
inline ::minecpp::proto::service::storage::ClientId* RequestSetClientId::release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::service::storage::ClientId* released = _impl_.client_id_;
  _impl_.client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::minecpp::proto::service::storage::ClientId* RequestSetClientId::unsafe_arena_release_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.RequestSetClientId.client_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::service::storage::ClientId* temp = _impl_.client_id_;
  _impl_.client_id_ = nullptr;
  return temp;
}
inline ::minecpp::proto::service::storage::ClientId* RequestSetClientId::_internal_mutable_client_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::service::storage::ClientId>(GetArenaForAllocation());
    _impl_.client_id_ = reinterpret_cast<::minecpp::proto::service::storage::ClientId*>(p);
  }
  return _impl_.client_id_;
}
inline ::minecpp::proto::service::storage::ClientId* RequestSetClientId::mutable_client_id() {
  ::minecpp::proto::service::storage::ClientId* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.RequestSetClientId.client_id)
  return _msg;
}
inline void RequestSetClientId::set_allocated_client_id(::minecpp::proto::service::storage::ClientId* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::minecpp::proto::service::storage::ClientId*>(_impl_.client_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::minecpp::proto::service::storage::ClientId*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.client_id_ = reinterpret_cast<::minecpp::proto::service::storage::ClientId*>(value);
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.RequestSetClientId.client_id)
}

// -------------------------------------------------------------------

// Response

// .minecpp.proto.service.storage.ResponseChunkData chunk_data = 1;
inline bool Response::has_chunk_data() const {
  return message_case() == kChunkData;
}
inline bool Response::_internal_has_chunk_data() const {
  return message_case() == kChunkData;
}
inline void Response::set_has_chunk_data() {
  _impl_._oneof_case_[0] = kChunkData;
}
inline void Response::clear_chunk_data() {
  if (message_case() == kChunkData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.chunk_data_;
    }
    clear_has_message();
  }
}
inline ::minecpp::proto::service::storage::ResponseChunkData* Response::release_chunk_data() {
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.Response.chunk_data)
  if (message_case() == kChunkData) {
    clear_has_message();
    ::minecpp::proto::service::storage::ResponseChunkData* temp = _impl_.message_.chunk_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.chunk_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::service::storage::ResponseChunkData& Response::_internal_chunk_data() const {
  return message_case() == kChunkData
      ? *_impl_.message_.chunk_data_
      : reinterpret_cast<::minecpp::proto::service::storage::ResponseChunkData&>(::minecpp::proto::service::storage::_ResponseChunkData_default_instance_);
}
inline const ::minecpp::proto::service::storage::ResponseChunkData& Response::chunk_data() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.Response.chunk_data)
  return _internal_chunk_data();
}
inline ::minecpp::proto::service::storage::ResponseChunkData* Response::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.Response.chunk_data)
  if (message_case() == kChunkData) {
    clear_has_message();
    ::minecpp::proto::service::storage::ResponseChunkData* temp = _impl_.message_.chunk_data_;
    _impl_.message_.chunk_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_chunk_data(::minecpp::proto::service::storage::ResponseChunkData* chunk_data) {
  clear_message();
  if (chunk_data) {
    set_has_chunk_data();
    _impl_.message_.chunk_data_ = chunk_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.Response.chunk_data)
}
inline ::minecpp::proto::service::storage::ResponseChunkData* Response::_internal_mutable_chunk_data() {
  if (message_case() != kChunkData) {
    clear_message();
    set_has_chunk_data();
    _impl_.message_.chunk_data_ = CreateMaybeMessage< ::minecpp::proto::service::storage::ResponseChunkData >(GetArenaForAllocation());
  }
  return _impl_.message_.chunk_data_;
}
inline ::minecpp::proto::service::storage::ResponseChunkData* Response::mutable_chunk_data() {
  ::minecpp::proto::service::storage::ResponseChunkData* _msg = _internal_mutable_chunk_data();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.Response.chunk_data)
  return _msg;
}

// .minecpp.proto.service.storage.ResponseEmptyChunk empty_chunk = 2;
inline bool Response::has_empty_chunk() const {
  return message_case() == kEmptyChunk;
}
inline bool Response::_internal_has_empty_chunk() const {
  return message_case() == kEmptyChunk;
}
inline void Response::set_has_empty_chunk() {
  _impl_._oneof_case_[0] = kEmptyChunk;
}
inline void Response::clear_empty_chunk() {
  if (message_case() == kEmptyChunk) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.empty_chunk_;
    }
    clear_has_message();
  }
}
inline ::minecpp::proto::service::storage::ResponseEmptyChunk* Response::release_empty_chunk() {
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.Response.empty_chunk)
  if (message_case() == kEmptyChunk) {
    clear_has_message();
    ::minecpp::proto::service::storage::ResponseEmptyChunk* temp = _impl_.message_.empty_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.empty_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::minecpp::proto::service::storage::ResponseEmptyChunk& Response::_internal_empty_chunk() const {
  return message_case() == kEmptyChunk
      ? *_impl_.message_.empty_chunk_
      : reinterpret_cast<::minecpp::proto::service::storage::ResponseEmptyChunk&>(::minecpp::proto::service::storage::_ResponseEmptyChunk_default_instance_);
}
inline const ::minecpp::proto::service::storage::ResponseEmptyChunk& Response::empty_chunk() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.Response.empty_chunk)
  return _internal_empty_chunk();
}
inline ::minecpp::proto::service::storage::ResponseEmptyChunk* Response::unsafe_arena_release_empty_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.Response.empty_chunk)
  if (message_case() == kEmptyChunk) {
    clear_has_message();
    ::minecpp::proto::service::storage::ResponseEmptyChunk* temp = _impl_.message_.empty_chunk_;
    _impl_.message_.empty_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_empty_chunk(::minecpp::proto::service::storage::ResponseEmptyChunk* empty_chunk) {
  clear_message();
  if (empty_chunk) {
    set_has_empty_chunk();
    _impl_.message_.empty_chunk_ = empty_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.Response.empty_chunk)
}
inline ::minecpp::proto::service::storage::ResponseEmptyChunk* Response::_internal_mutable_empty_chunk() {
  if (message_case() != kEmptyChunk) {
    clear_message();
    set_has_empty_chunk();
    _impl_.message_.empty_chunk_ = CreateMaybeMessage< ::minecpp::proto::service::storage::ResponseEmptyChunk >(GetArenaForAllocation());
  }
  return _impl_.message_.empty_chunk_;
}
inline ::minecpp::proto::service::storage::ResponseEmptyChunk* Response::mutable_empty_chunk() {
  ::minecpp::proto::service::storage::ResponseEmptyChunk* _msg = _internal_mutable_empty_chunk();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.Response.empty_chunk)
  return _msg;
}

inline bool Response::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Response::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Response::MessageCase Response::message_case() const {
  return Response::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseEmptyChunk

// .minecpp.proto.common.ChunkPosition position = 1;
inline bool ResponseEmptyChunk::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::minecpp::proto::common::ChunkPosition& ResponseEmptyChunk::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::minecpp::proto::common::ChunkPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::common::ChunkPosition&>(::minecpp::proto::common::_ChunkPosition_default_instance_);
}
inline const ::minecpp::proto::common::ChunkPosition& ResponseEmptyChunk::position() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.ResponseEmptyChunk.position)
  return _internal_position();
}
inline void ResponseEmptyChunk::unsafe_arena_set_allocated_position(::minecpp::proto::common::ChunkPosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::minecpp::proto::common::ChunkPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.ResponseEmptyChunk.position)
}
inline ::minecpp::proto::common::ChunkPosition* ResponseEmptyChunk::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::common::ChunkPosition* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::minecpp::proto::common::ChunkPosition* ResponseEmptyChunk::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.ResponseEmptyChunk.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::common::ChunkPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::minecpp::proto::common::ChunkPosition* ResponseEmptyChunk::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::common::ChunkPosition>(GetArenaForAllocation());
    _impl_.position_ = reinterpret_cast<::minecpp::proto::common::ChunkPosition*>(p);
  }
  return _impl_.position_;
}
inline ::minecpp::proto::common::ChunkPosition* ResponseEmptyChunk::mutable_position() {
  ::minecpp::proto::common::ChunkPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.ResponseEmptyChunk.position)
  return _msg;
}
inline void ResponseEmptyChunk::set_allocated_position(::minecpp::proto::common::ChunkPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::minecpp::proto::common::ChunkPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.ResponseEmptyChunk.position)
}

// -------------------------------------------------------------------

// ResponseChunkData

// .minecpp.proto.chunk.Chunk chunk_data = 1;
inline bool ResponseChunkData::has_chunk_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunk_data_ != nullptr);
  return value;
}
inline const ::minecpp::proto::chunk::Chunk& ResponseChunkData::_internal_chunk_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::minecpp::proto::chunk::Chunk* p = _impl_.chunk_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::minecpp::proto::chunk::Chunk&>(::minecpp::proto::chunk::_Chunk_default_instance_);
}
inline const ::minecpp::proto::chunk::Chunk& ResponseChunkData::chunk_data() const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.ResponseChunkData.chunk_data)
  return _internal_chunk_data();
}
inline void ResponseChunkData::unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chunk_data_);
  }
  _impl_.chunk_data_ = reinterpret_cast<::minecpp::proto::chunk::Chunk*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.ResponseChunkData.chunk_data)
}
inline ::minecpp::proto::chunk::Chunk* ResponseChunkData::release_chunk_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::chunk::Chunk* released = _impl_.chunk_data_;
  _impl_.chunk_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::minecpp::proto::chunk::Chunk* ResponseChunkData::unsafe_arena_release_chunk_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.ResponseChunkData.chunk_data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::minecpp::proto::chunk::Chunk* temp = _impl_.chunk_data_;
  _impl_.chunk_data_ = nullptr;
  return temp;
}
inline ::minecpp::proto::chunk::Chunk* ResponseChunkData::_internal_mutable_chunk_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.chunk_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::minecpp::proto::chunk::Chunk>(GetArenaForAllocation());
    _impl_.chunk_data_ = reinterpret_cast<::minecpp::proto::chunk::Chunk*>(p);
  }
  return _impl_.chunk_data_;
}
inline ::minecpp::proto::chunk::Chunk* ResponseChunkData::mutable_chunk_data() {
  ::minecpp::proto::chunk::Chunk* _msg = _internal_mutable_chunk_data();
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.ResponseChunkData.chunk_data)
  return _msg;
}
inline void ResponseChunkData::set_allocated_chunk_data(::minecpp::proto::chunk::Chunk* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chunk_data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.chunk_data_ = reinterpret_cast<::minecpp::proto::chunk::Chunk*>(value);
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.ResponseChunkData.chunk_data)
}

// -------------------------------------------------------------------

// ChunkSubscription

// repeated .minecpp.proto.service.storage.ClientId client_ids = 1;
inline int ChunkSubscription::_internal_client_ids_size() const {
  return _internal_client_ids().size();
}
inline int ChunkSubscription::client_ids_size() const {
  return _internal_client_ids_size();
}
inline void ChunkSubscription::clear_client_ids() {
  _internal_mutable_client_ids()->Clear();
}
inline ::minecpp::proto::service::storage::ClientId* ChunkSubscription::mutable_client_ids(int index) {
  // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.ChunkSubscription.client_ids)
  return _internal_mutable_client_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::minecpp::proto::service::storage::ClientId >*
ChunkSubscription::mutable_client_ids() {
  // @@protoc_insertion_point(field_mutable_list:minecpp.proto.service.storage.ChunkSubscription.client_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_client_ids();
}
inline const ::minecpp::proto::service::storage::ClientId& ChunkSubscription::client_ids(int index) const {
  // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.ChunkSubscription.client_ids)
    return _internal_client_ids().Get(index);
}
inline ::minecpp::proto::service::storage::ClientId* ChunkSubscription::add_client_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::minecpp::proto::service::storage::ClientId* _add = _internal_mutable_client_ids()->Add();
  // @@protoc_insertion_point(field_add:minecpp.proto.service.storage.ChunkSubscription.client_ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::minecpp::proto::service::storage::ClientId >&
ChunkSubscription::client_ids() const {
  // @@protoc_insertion_point(field_list:minecpp.proto.service.storage.ChunkSubscription.client_ids)
  return _internal_client_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::minecpp::proto::service::storage::ClientId>&
ChunkSubscription::_internal_client_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::minecpp::proto::service::storage::ClientId>*
ChunkSubscription::_internal_mutable_client_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.client_ids_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace storage
}  // namespace service
}  // namespace proto
}  // namespace minecpp


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fservice_2fstorage_2fStorage_2eproto_2epb_2eh
