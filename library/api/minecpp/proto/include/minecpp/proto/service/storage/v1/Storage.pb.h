// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minecpp/proto/service/storage/v1/Storage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h>// IWYU pragma: export
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/port_undef.inc>
#include <google/protobuf/repeated_field.h>// IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <minecpp/proto/chunk/v1/Chunk.pb.h>
#include <minecpp/proto/common/v1/Common.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto
PROTOBUF_NAMESPACE_OPEN

namespace internal {
class AnyMetadata;
}// namespace internal

PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto
{
   static const uint32_t offsets[];
};

extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
        descriptor_table_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;

namespace minecpp { namespace proto { namespace service { namespace storage { namespace v1 {
class ChunkSubscription;
struct ChunkSubscriptionDefaultTypeInternal;
extern ChunkSubscriptionDefaultTypeInternal _ChunkSubscription_default_instance_;
class ClientId;
struct ClientIdDefaultTypeInternal;
extern ClientIdDefaultTypeInternal _ClientId_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestChunkData;
struct RequestChunkDataDefaultTypeInternal;
extern RequestChunkDataDefaultTypeInternal _RequestChunkData_default_instance_;
class RequestChunkSubscription;
struct RequestChunkSubscriptionDefaultTypeInternal;
extern RequestChunkSubscriptionDefaultTypeInternal _RequestChunkSubscription_default_instance_;
class RequestSetClientId;
struct RequestSetClientIdDefaultTypeInternal;
extern RequestSetClientIdDefaultTypeInternal _RequestSetClientId_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseChunkData;
struct ResponseChunkDataDefaultTypeInternal;
extern ResponseChunkDataDefaultTypeInternal _ResponseChunkData_default_instance_;
class ResponseEmptyChunk;
struct ResponseEmptyChunkDefaultTypeInternal;
extern ResponseEmptyChunkDefaultTypeInternal _ResponseEmptyChunk_default_instance_;
}}}}}// namespace minecpp::proto::service::storage::v1

PROTOBUF_NAMESPACE_OPEN
template<>
::minecpp::proto::service::storage::v1::ChunkSubscription *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::ChunkSubscription>(Arena *);
template<>
::minecpp::proto::service::storage::v1::ClientId *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::ClientId>(Arena *);
template<>
::minecpp::proto::service::storage::v1::Request *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::Request>(Arena *);
template<>
::minecpp::proto::service::storage::v1::RequestChunkData *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::RequestChunkData>(Arena *);
template<>
::minecpp::proto::service::storage::v1::RequestChunkSubscription *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::RequestChunkSubscription>(Arena *);
template<>
::minecpp::proto::service::storage::v1::RequestSetClientId *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::RequestSetClientId>(Arena *);
template<>
::minecpp::proto::service::storage::v1::Response *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::Response>(Arena *);
template<>
::minecpp::proto::service::storage::v1::ResponseChunkData *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::ResponseChunkData>(Arena *);
template<>
::minecpp::proto::service::storage::v1::ResponseEmptyChunk *
Arena::CreateMaybeMessage<::minecpp::proto::service::storage::v1::ResponseEmptyChunk>(Arena *);
PROTOBUF_NAMESPACE_CLOSE

namespace minecpp { namespace proto { namespace service { namespace storage { namespace v1 {

// ===================================================================

class ClientId final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.ClientId) */
{
 public:
   inline ClientId() :
       ClientId(nullptr)
   {
   }

   ~ClientId() override;
   explicit PROTOBUF_CONSTEXPR ClientId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   ClientId(const ClientId &from);

   ClientId(ClientId &&from) noexcept :
       ClientId()
   {
      *this = ::std::move(from);
   }

   inline ClientId &operator=(const ClientId &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline ClientId &operator=(ClientId &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const ClientId &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const ClientId *internal_default_instance()
   {
      return reinterpret_cast<const ClientId *>(&_ClientId_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 0;

   friend void swap(ClientId &a, ClientId &b)
   {
      a.Swap(&b);
   }

   inline void Swap(ClientId *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(ClientId *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   ClientId *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<ClientId>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const ClientId &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const ClientId &from)
   {
      ClientId::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(ClientId *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.ClientId";
   }

 protected:
   explicit ClientId(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kValueFieldNumber = 1,
   };

   // uint64 value = 1;
   void clear_value();
   uint64_t value() const;
   void set_value(uint64_t value);

 private:
   uint64_t _internal_value() const;
   void _internal_set_value(uint64_t value);

 public:
   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.ClientId)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      uint64_t value_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class Request final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.Request) */
{
 public:
   inline Request() :
       Request(nullptr)
   {
   }

   ~Request() override;
   explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   Request(const Request &from);

   Request(Request &&from) noexcept :
       Request()
   {
      *this = ::std::move(from);
   }

   inline Request &operator=(const Request &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline Request &operator=(Request &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const Request &default_instance()
   {
      return *internal_default_instance();
   }

   enum MessageCase
   {
      kChunkSubscription = 1,
      kChunkData         = 2,
      kSetClientId       = 3,
      MESSAGE_NOT_SET    = 0,
   };

   static inline const Request *internal_default_instance()
   {
      return reinterpret_cast<const Request *>(&_Request_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 1;

   friend void swap(Request &a, Request &b)
   {
      a.Swap(&b);
   }

   inline void Swap(Request *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(Request *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   Request *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<Request>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const Request &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const Request &from)
   {
      Request::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(Request *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.Request";
   }

 protected:
   explicit Request(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kChunkSubscriptionFieldNumber = 1,
      kChunkDataFieldNumber         = 2,
      kSetClientIdFieldNumber       = 3,
   };

   // .minecpp.proto.service.storage.v1.RequestChunkSubscription chunk_subscription = 1;
   bool has_chunk_subscription() const;

 private:
   bool _internal_has_chunk_subscription() const;

 public:
   void clear_chunk_subscription();
   const ::minecpp::proto::service::storage::v1::RequestChunkSubscription &chunk_subscription() const;
   PROTOBUF_NODISCARD ::minecpp::proto::service::storage::v1::RequestChunkSubscription *
   release_chunk_subscription();
   ::minecpp::proto::service::storage::v1::RequestChunkSubscription *mutable_chunk_subscription();
   void set_allocated_chunk_subscription(
           ::minecpp::proto::service::storage::v1::RequestChunkSubscription *chunk_subscription);

 private:
   const ::minecpp::proto::service::storage::v1::RequestChunkSubscription &
   _internal_chunk_subscription() const;
   ::minecpp::proto::service::storage::v1::RequestChunkSubscription *_internal_mutable_chunk_subscription();

 public:
   void unsafe_arena_set_allocated_chunk_subscription(
           ::minecpp::proto::service::storage::v1::RequestChunkSubscription *chunk_subscription);
   ::minecpp::proto::service::storage::v1::RequestChunkSubscription *
   unsafe_arena_release_chunk_subscription();

   // .minecpp.proto.service.storage.v1.RequestChunkData chunk_data = 2;
   bool has_chunk_data() const;

 private:
   bool _internal_has_chunk_data() const;

 public:
   void clear_chunk_data();
   const ::minecpp::proto::service::storage::v1::RequestChunkData &chunk_data() const;
   PROTOBUF_NODISCARD ::minecpp::proto::service::storage::v1::RequestChunkData *release_chunk_data();
   ::minecpp::proto::service::storage::v1::RequestChunkData *mutable_chunk_data();
   void set_allocated_chunk_data(::minecpp::proto::service::storage::v1::RequestChunkData *chunk_data);

 private:
   const ::minecpp::proto::service::storage::v1::RequestChunkData &_internal_chunk_data() const;
   ::minecpp::proto::service::storage::v1::RequestChunkData *_internal_mutable_chunk_data();

 public:
   void unsafe_arena_set_allocated_chunk_data(
           ::minecpp::proto::service::storage::v1::RequestChunkData *chunk_data);
   ::minecpp::proto::service::storage::v1::RequestChunkData *unsafe_arena_release_chunk_data();

   // .minecpp.proto.service.storage.v1.RequestSetClientId set_client_id = 3;
   bool has_set_client_id() const;

 private:
   bool _internal_has_set_client_id() const;

 public:
   void clear_set_client_id();
   const ::minecpp::proto::service::storage::v1::RequestSetClientId &set_client_id() const;
   PROTOBUF_NODISCARD ::minecpp::proto::service::storage::v1::RequestSetClientId *release_set_client_id();
   ::minecpp::proto::service::storage::v1::RequestSetClientId *mutable_set_client_id();
   void
   set_allocated_set_client_id(::minecpp::proto::service::storage::v1::RequestSetClientId *set_client_id);

 private:
   const ::minecpp::proto::service::storage::v1::RequestSetClientId &_internal_set_client_id() const;
   ::minecpp::proto::service::storage::v1::RequestSetClientId *_internal_mutable_set_client_id();

 public:
   void unsafe_arena_set_allocated_set_client_id(
           ::minecpp::proto::service::storage::v1::RequestSetClientId *set_client_id);
   ::minecpp::proto::service::storage::v1::RequestSetClientId *unsafe_arena_release_set_client_id();

   void clear_message();
   MessageCase message_case() const;
   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.Request)
 private:
   class _Internal;
   void set_has_chunk_subscription();
   void set_has_chunk_data();
   void set_has_set_client_id();

   inline bool has_message() const;
   inline void clear_has_message();

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      union MessageUnion
      {
         constexpr MessageUnion() :
             _constinit_{}
         {
         }

         ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
         ::minecpp::proto::service::storage::v1::RequestChunkSubscription *chunk_subscription_;
         ::minecpp::proto::service::storage::v1::RequestChunkData *chunk_data_;
         ::minecpp::proto::service::storage::v1::RequestSetClientId *set_client_id_;
      } message_;

      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
      uint32_t _oneof_case_[1];
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class RequestChunkSubscription final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.RequestChunkSubscription) */
{
 public:
   inline RequestChunkSubscription() :
       RequestChunkSubscription(nullptr)
   {
   }

   ~RequestChunkSubscription() override;
   explicit PROTOBUF_CONSTEXPR
           RequestChunkSubscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   RequestChunkSubscription(const RequestChunkSubscription &from);

   RequestChunkSubscription(RequestChunkSubscription &&from) noexcept :
       RequestChunkSubscription()
   {
      *this = ::std::move(from);
   }

   inline RequestChunkSubscription &operator=(const RequestChunkSubscription &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline RequestChunkSubscription &operator=(RequestChunkSubscription &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const RequestChunkSubscription &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const RequestChunkSubscription *internal_default_instance()
   {
      return reinterpret_cast<const RequestChunkSubscription *>(&_RequestChunkSubscription_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 2;

   friend void swap(RequestChunkSubscription &a, RequestChunkSubscription &b)
   {
      a.Swap(&b);
   }

   inline void Swap(RequestChunkSubscription *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(RequestChunkSubscription *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   RequestChunkSubscription *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<RequestChunkSubscription>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const RequestChunkSubscription &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const RequestChunkSubscription &from)
   {
      RequestChunkSubscription::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(RequestChunkSubscription *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.RequestChunkSubscription";
   }

 protected:
   explicit RequestChunkSubscription(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kPositionFieldNumber = 1,
   };

   // .minecpp.proto.common.v1.ChunkPosition position = 1;
   bool has_position() const;

 private:
   bool _internal_has_position() const;

 public:
   void clear_position();
   const ::minecpp::proto::common::v1::ChunkPosition &position() const;
   PROTOBUF_NODISCARD ::minecpp::proto::common::v1::ChunkPosition *release_position();
   ::minecpp::proto::common::v1::ChunkPosition *mutable_position();
   void set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position);

 private:
   const ::minecpp::proto::common::v1::ChunkPosition &_internal_position() const;
   ::minecpp::proto::common::v1::ChunkPosition *_internal_mutable_position();

 public:
   void unsafe_arena_set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position);
   ::minecpp::proto::common::v1::ChunkPosition *unsafe_arena_release_position();

   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.RequestChunkSubscription)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      ::minecpp::proto::common::v1::ChunkPosition *position_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class RequestChunkData final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.RequestChunkData) */
{
 public:
   inline RequestChunkData() :
       RequestChunkData(nullptr)
   {
   }

   ~RequestChunkData() override;
   explicit PROTOBUF_CONSTEXPR RequestChunkData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   RequestChunkData(const RequestChunkData &from);

   RequestChunkData(RequestChunkData &&from) noexcept :
       RequestChunkData()
   {
      *this = ::std::move(from);
   }

   inline RequestChunkData &operator=(const RequestChunkData &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline RequestChunkData &operator=(RequestChunkData &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const RequestChunkData &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const RequestChunkData *internal_default_instance()
   {
      return reinterpret_cast<const RequestChunkData *>(&_RequestChunkData_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 3;

   friend void swap(RequestChunkData &a, RequestChunkData &b)
   {
      a.Swap(&b);
   }

   inline void Swap(RequestChunkData *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(RequestChunkData *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   RequestChunkData *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<RequestChunkData>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const RequestChunkData &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const RequestChunkData &from)
   {
      RequestChunkData::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(RequestChunkData *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.RequestChunkData";
   }

 protected:
   explicit RequestChunkData(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kChunkDataFieldNumber = 1,
   };

   // .minecpp.proto.chunk.v1.Chunk chunk_data = 1;
   bool has_chunk_data() const;

 private:
   bool _internal_has_chunk_data() const;

 public:
   void clear_chunk_data();
   const ::minecpp::proto::chunk::v1::Chunk &chunk_data() const;
   PROTOBUF_NODISCARD ::minecpp::proto::chunk::v1::Chunk *release_chunk_data();
   ::minecpp::proto::chunk::v1::Chunk *mutable_chunk_data();
   void set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data);

 private:
   const ::minecpp::proto::chunk::v1::Chunk &_internal_chunk_data() const;
   ::minecpp::proto::chunk::v1::Chunk *_internal_mutable_chunk_data();

 public:
   void unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data);
   ::minecpp::proto::chunk::v1::Chunk *unsafe_arena_release_chunk_data();

   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.RequestChunkData)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      ::minecpp::proto::chunk::v1::Chunk *chunk_data_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class RequestSetClientId final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.RequestSetClientId) */
{
 public:
   inline RequestSetClientId() :
       RequestSetClientId(nullptr)
   {
   }

   ~RequestSetClientId() override;
   explicit PROTOBUF_CONSTEXPR RequestSetClientId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   RequestSetClientId(const RequestSetClientId &from);

   RequestSetClientId(RequestSetClientId &&from) noexcept :
       RequestSetClientId()
   {
      *this = ::std::move(from);
   }

   inline RequestSetClientId &operator=(const RequestSetClientId &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline RequestSetClientId &operator=(RequestSetClientId &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const RequestSetClientId &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const RequestSetClientId *internal_default_instance()
   {
      return reinterpret_cast<const RequestSetClientId *>(&_RequestSetClientId_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 4;

   friend void swap(RequestSetClientId &a, RequestSetClientId &b)
   {
      a.Swap(&b);
   }

   inline void Swap(RequestSetClientId *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(RequestSetClientId *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   RequestSetClientId *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<RequestSetClientId>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const RequestSetClientId &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const RequestSetClientId &from)
   {
      RequestSetClientId::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(RequestSetClientId *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.RequestSetClientId";
   }

 protected:
   explicit RequestSetClientId(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kClientIdFieldNumber = 1,
   };

   // .minecpp.proto.service.storage.v1.ClientId client_id = 1;
   bool has_client_id() const;

 private:
   bool _internal_has_client_id() const;

 public:
   void clear_client_id();
   const ::minecpp::proto::service::storage::v1::ClientId &client_id() const;
   PROTOBUF_NODISCARD ::minecpp::proto::service::storage::v1::ClientId *release_client_id();
   ::minecpp::proto::service::storage::v1::ClientId *mutable_client_id();
   void set_allocated_client_id(::minecpp::proto::service::storage::v1::ClientId *client_id);

 private:
   const ::minecpp::proto::service::storage::v1::ClientId &_internal_client_id() const;
   ::minecpp::proto::service::storage::v1::ClientId *_internal_mutable_client_id();

 public:
   void unsafe_arena_set_allocated_client_id(::minecpp::proto::service::storage::v1::ClientId *client_id);
   ::minecpp::proto::service::storage::v1::ClientId *unsafe_arena_release_client_id();

   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.RequestSetClientId)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      ::minecpp::proto::service::storage::v1::ClientId *client_id_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class Response final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.Response) */
{
 public:
   inline Response() :
       Response(nullptr)
   {
   }

   ~Response() override;
   explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   Response(const Response &from);

   Response(Response &&from) noexcept :
       Response()
   {
      *this = ::std::move(from);
   }

   inline Response &operator=(const Response &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline Response &operator=(Response &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const Response &default_instance()
   {
      return *internal_default_instance();
   }

   enum MessageCase
   {
      kChunkData      = 1,
      kEmptyChunk     = 2,
      MESSAGE_NOT_SET = 0,
   };

   static inline const Response *internal_default_instance()
   {
      return reinterpret_cast<const Response *>(&_Response_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 5;

   friend void swap(Response &a, Response &b)
   {
      a.Swap(&b);
   }

   inline void Swap(Response *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(Response *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   Response *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<Response>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const Response &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const Response &from)
   {
      Response::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(Response *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.Response";
   }

 protected:
   explicit Response(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kChunkDataFieldNumber  = 1,
      kEmptyChunkFieldNumber = 2,
   };

   // .minecpp.proto.service.storage.v1.ResponseChunkData chunk_data = 1;
   bool has_chunk_data() const;

 private:
   bool _internal_has_chunk_data() const;

 public:
   void clear_chunk_data();
   const ::minecpp::proto::service::storage::v1::ResponseChunkData &chunk_data() const;
   PROTOBUF_NODISCARD ::minecpp::proto::service::storage::v1::ResponseChunkData *release_chunk_data();
   ::minecpp::proto::service::storage::v1::ResponseChunkData *mutable_chunk_data();
   void set_allocated_chunk_data(::minecpp::proto::service::storage::v1::ResponseChunkData *chunk_data);

 private:
   const ::minecpp::proto::service::storage::v1::ResponseChunkData &_internal_chunk_data() const;
   ::minecpp::proto::service::storage::v1::ResponseChunkData *_internal_mutable_chunk_data();

 public:
   void unsafe_arena_set_allocated_chunk_data(
           ::minecpp::proto::service::storage::v1::ResponseChunkData *chunk_data);
   ::minecpp::proto::service::storage::v1::ResponseChunkData *unsafe_arena_release_chunk_data();

   // .minecpp.proto.service.storage.v1.ResponseEmptyChunk empty_chunk = 2;
   bool has_empty_chunk() const;

 private:
   bool _internal_has_empty_chunk() const;

 public:
   void clear_empty_chunk();
   const ::minecpp::proto::service::storage::v1::ResponseEmptyChunk &empty_chunk() const;
   PROTOBUF_NODISCARD ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *release_empty_chunk();
   ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *mutable_empty_chunk();
   void set_allocated_empty_chunk(::minecpp::proto::service::storage::v1::ResponseEmptyChunk *empty_chunk);

 private:
   const ::minecpp::proto::service::storage::v1::ResponseEmptyChunk &_internal_empty_chunk() const;
   ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *_internal_mutable_empty_chunk();

 public:
   void unsafe_arena_set_allocated_empty_chunk(
           ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *empty_chunk);
   ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *unsafe_arena_release_empty_chunk();

   void clear_message();
   MessageCase message_case() const;
   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.Response)
 private:
   class _Internal;
   void set_has_chunk_data();
   void set_has_empty_chunk();

   inline bool has_message() const;
   inline void clear_has_message();

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      union MessageUnion
      {
         constexpr MessageUnion() :
             _constinit_{}
         {
         }

         ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
         ::minecpp::proto::service::storage::v1::ResponseChunkData *chunk_data_;
         ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *empty_chunk_;
      } message_;

      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
      uint32_t _oneof_case_[1];
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class ResponseEmptyChunk final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.ResponseEmptyChunk) */
{
 public:
   inline ResponseEmptyChunk() :
       ResponseEmptyChunk(nullptr)
   {
   }

   ~ResponseEmptyChunk() override;
   explicit PROTOBUF_CONSTEXPR ResponseEmptyChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   ResponseEmptyChunk(const ResponseEmptyChunk &from);

   ResponseEmptyChunk(ResponseEmptyChunk &&from) noexcept :
       ResponseEmptyChunk()
   {
      *this = ::std::move(from);
   }

   inline ResponseEmptyChunk &operator=(const ResponseEmptyChunk &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline ResponseEmptyChunk &operator=(ResponseEmptyChunk &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const ResponseEmptyChunk &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const ResponseEmptyChunk *internal_default_instance()
   {
      return reinterpret_cast<const ResponseEmptyChunk *>(&_ResponseEmptyChunk_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 6;

   friend void swap(ResponseEmptyChunk &a, ResponseEmptyChunk &b)
   {
      a.Swap(&b);
   }

   inline void Swap(ResponseEmptyChunk *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(ResponseEmptyChunk *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   ResponseEmptyChunk *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<ResponseEmptyChunk>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const ResponseEmptyChunk &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const ResponseEmptyChunk &from)
   {
      ResponseEmptyChunk::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(ResponseEmptyChunk *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.ResponseEmptyChunk";
   }

 protected:
   explicit ResponseEmptyChunk(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kPositionFieldNumber = 1,
   };

   // .minecpp.proto.common.v1.ChunkPosition position = 1;
   bool has_position() const;

 private:
   bool _internal_has_position() const;

 public:
   void clear_position();
   const ::minecpp::proto::common::v1::ChunkPosition &position() const;
   PROTOBUF_NODISCARD ::minecpp::proto::common::v1::ChunkPosition *release_position();
   ::minecpp::proto::common::v1::ChunkPosition *mutable_position();
   void set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position);

 private:
   const ::minecpp::proto::common::v1::ChunkPosition &_internal_position() const;
   ::minecpp::proto::common::v1::ChunkPosition *_internal_mutable_position();

 public:
   void unsafe_arena_set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position);
   ::minecpp::proto::common::v1::ChunkPosition *unsafe_arena_release_position();

   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.ResponseEmptyChunk)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      ::minecpp::proto::common::v1::ChunkPosition *position_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class ResponseChunkData final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.ResponseChunkData) */
{
 public:
   inline ResponseChunkData() :
       ResponseChunkData(nullptr)
   {
   }

   ~ResponseChunkData() override;
   explicit PROTOBUF_CONSTEXPR ResponseChunkData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   ResponseChunkData(const ResponseChunkData &from);

   ResponseChunkData(ResponseChunkData &&from) noexcept :
       ResponseChunkData()
   {
      *this = ::std::move(from);
   }

   inline ResponseChunkData &operator=(const ResponseChunkData &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline ResponseChunkData &operator=(ResponseChunkData &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const ResponseChunkData &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const ResponseChunkData *internal_default_instance()
   {
      return reinterpret_cast<const ResponseChunkData *>(&_ResponseChunkData_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 7;

   friend void swap(ResponseChunkData &a, ResponseChunkData &b)
   {
      a.Swap(&b);
   }

   inline void Swap(ResponseChunkData *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(ResponseChunkData *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   ResponseChunkData *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<ResponseChunkData>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const ResponseChunkData &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const ResponseChunkData &from)
   {
      ResponseChunkData::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(ResponseChunkData *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.ResponseChunkData";
   }

 protected:
   explicit ResponseChunkData(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kChunkDataFieldNumber = 1,
   };

   // .minecpp.proto.chunk.v1.Chunk chunk_data = 1;
   bool has_chunk_data() const;

 private:
   bool _internal_has_chunk_data() const;

 public:
   void clear_chunk_data();
   const ::minecpp::proto::chunk::v1::Chunk &chunk_data() const;
   PROTOBUF_NODISCARD ::minecpp::proto::chunk::v1::Chunk *release_chunk_data();
   ::minecpp::proto::chunk::v1::Chunk *mutable_chunk_data();
   void set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data);

 private:
   const ::minecpp::proto::chunk::v1::Chunk &_internal_chunk_data() const;
   ::minecpp::proto::chunk::v1::Chunk *_internal_mutable_chunk_data();

 public:
   void unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data);
   ::minecpp::proto::chunk::v1::Chunk *unsafe_arena_release_chunk_data();

   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.ResponseChunkData)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      ::minecpp::proto::chunk::v1::Chunk *chunk_data_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// -------------------------------------------------------------------

class ChunkSubscription final
    : public ::PROTOBUF_NAMESPACE_ID::
              Message /* @@protoc_insertion_point(class_definition:minecpp.proto.service.storage.v1.ChunkSubscription) */
{
 public:
   inline ChunkSubscription() :
       ChunkSubscription(nullptr)
   {
   }

   ~ChunkSubscription() override;
   explicit PROTOBUF_CONSTEXPR ChunkSubscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

   ChunkSubscription(const ChunkSubscription &from);

   ChunkSubscription(ChunkSubscription &&from) noexcept :
       ChunkSubscription()
   {
      *this = ::std::move(from);
   }

   inline ChunkSubscription &operator=(const ChunkSubscription &from)
   {
      CopyFrom(from);
      return *this;
   }

   inline ChunkSubscription &operator=(ChunkSubscription &&from) noexcept
   {
      if (this == &from)
         return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif// !PROTOBUF_FORCE_COPY_IN_MOVE
      ) {
         InternalSwap(&from);
      } else {
         CopyFrom(from);
      }
      return *this;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
   {
      return GetDescriptor();
   }

   static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
   {
      return default_instance().GetMetadata().descriptor;
   }

   static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
   {
      return default_instance().GetMetadata().reflection;
   }

   static const ChunkSubscription &default_instance()
   {
      return *internal_default_instance();
   }

   static inline const ChunkSubscription *internal_default_instance()
   {
      return reinterpret_cast<const ChunkSubscription *>(&_ChunkSubscription_default_instance_);
   }

   static constexpr int kIndexInFileMessages = 8;

   friend void swap(ChunkSubscription &a, ChunkSubscription &b)
   {
      a.Swap(&b);
   }

   inline void Swap(ChunkSubscription *other)
   {
      if (other == this)
         return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena()) {
#endif// !PROTOBUF_FORCE_COPY_IN_SWAP
         InternalSwap(other);
      } else {
         ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
   }

   void UnsafeArenaSwap(ChunkSubscription *other)
   {
      if (other == this)
         return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
   }

   // implements Message ----------------------------------------------

   ChunkSubscription *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
   {
      return CreateMaybeMessage<ChunkSubscription>(arena);
   }

   using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
   void CopyFrom(const ChunkSubscription &from);
   using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

   void MergeFrom(const ChunkSubscription &from)
   {
      ChunkSubscription::MergeImpl(*this, from);
   }

 private:
   static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message &to_msg,
                         const ::PROTOBUF_NAMESPACE_ID::Message &from_msg);

 public:
   PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
   bool IsInitialized() const final;

   size_t ByteSizeLong() const final;
   const char *_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;
   uint8_t *_InternalSerialize(uint8_t *target,
                               ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

   int GetCachedSize() const final
   {
      return _impl_._cached_size_.Get();
   }

 private:
   void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned);
   void SharedDtor();
   void SetCachedSize(int size) const final;
   void InternalSwap(ChunkSubscription *other);

 private:
   friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

   static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
   {
      return "minecpp.proto.service.storage.v1.ChunkSubscription";
   }

 protected:
   explicit ChunkSubscription(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned = false);

 public:
   static const ClassData _class_data_;
   const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

   ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

   // nested types ----------------------------------------------------

   // accessors -------------------------------------------------------

   enum : int
   {
      kClientIdsFieldNumber = 1,
   };

   // repeated .minecpp.proto.service.storage.v1.ClientId client_ids = 1;
   int client_ids_size() const;

 private:
   int _internal_client_ids_size() const;

 public:
   void clear_client_ids();
   ::minecpp::proto::service::storage::v1::ClientId *mutable_client_ids(int index);
   ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::minecpp::proto::service::storage::v1::ClientId> *
   mutable_client_ids();

 private:
   const ::minecpp::proto::service::storage::v1::ClientId &_internal_client_ids(int index) const;
   ::minecpp::proto::service::storage::v1::ClientId *_internal_add_client_ids();

 public:
   const ::minecpp::proto::service::storage::v1::ClientId &client_ids(int index) const;
   ::minecpp::proto::service::storage::v1::ClientId *add_client_ids();
   const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::minecpp::proto::service::storage::v1::ClientId> &
   client_ids() const;

   // @@protoc_insertion_point(class_scope:minecpp.proto.service.storage.v1.ChunkSubscription)
 private:
   class _Internal;

   template<typename T>
   friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
   typedef void InternalArenaConstructable_;
   typedef void DestructorSkippable_;

   struct Impl_
   {
      ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::minecpp::proto::service::storage::v1::ClientId> client_ids_;
      mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
   };

   union
   {
      Impl_ _impl_;
   };
   friend struct ::TableStruct_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto;
};

// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif// __GNUC__
// ClientId

// uint64 value = 1;
inline void ClientId::clear_value()
{
   _impl_.value_ = uint64_t{0u};
}

inline uint64_t ClientId::_internal_value() const
{
   return _impl_.value_;
}

inline uint64_t ClientId::value() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.ClientId.value)
   return _internal_value();
}

inline void ClientId::_internal_set_value(uint64_t value)
{

   _impl_.value_ = value;
}

inline void ClientId::set_value(uint64_t value)
{
   _internal_set_value(value);
   // @@protoc_insertion_point(field_set:minecpp.proto.service.storage.v1.ClientId.value)
}

// -------------------------------------------------------------------

// Request

// .minecpp.proto.service.storage.v1.RequestChunkSubscription chunk_subscription = 1;
inline bool Request::_internal_has_chunk_subscription() const
{
   return message_case() == kChunkSubscription;
}

inline bool Request::has_chunk_subscription() const
{
   return _internal_has_chunk_subscription();
}

inline void Request::set_has_chunk_subscription()
{
   _impl_._oneof_case_[0] = kChunkSubscription;
}

inline void Request::clear_chunk_subscription()
{
   if (_internal_has_chunk_subscription()) {
      if (GetArenaForAllocation() == nullptr) {
         delete _impl_.message_.chunk_subscription_;
      }
      clear_has_message();
   }
}

inline ::minecpp::proto::service::storage::v1::RequestChunkSubscription *Request::release_chunk_subscription()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.Request.chunk_subscription)
   if (_internal_has_chunk_subscription()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::RequestChunkSubscription *temp =
              _impl_.message_.chunk_subscription_;
      if (GetArenaForAllocation() != nullptr) {
         temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
      }
      _impl_.message_.chunk_subscription_ = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline const ::minecpp::proto::service::storage::v1::RequestChunkSubscription &
Request::_internal_chunk_subscription() const
{
   return _internal_has_chunk_subscription()
                  ? *_impl_.message_.chunk_subscription_
                  : reinterpret_cast<::minecpp::proto::service::storage::v1::RequestChunkSubscription &>(
                            ::minecpp::proto::service::storage::v1::
                                    _RequestChunkSubscription_default_instance_);
}

inline const ::minecpp::proto::service::storage::v1::RequestChunkSubscription &
Request::chunk_subscription() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.Request.chunk_subscription)
   return _internal_chunk_subscription();
}

inline ::minecpp::proto::service::storage::v1::RequestChunkSubscription *
Request::unsafe_arena_release_chunk_subscription()
{
   // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.v1.Request.chunk_subscription)
   if (_internal_has_chunk_subscription()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::RequestChunkSubscription *temp =
              _impl_.message_.chunk_subscription_;
      _impl_.message_.chunk_subscription_ = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline void Request::unsafe_arena_set_allocated_chunk_subscription(
        ::minecpp::proto::service::storage::v1::RequestChunkSubscription *chunk_subscription)
{
   clear_message();
   if (chunk_subscription) {
      set_has_chunk_subscription();
      _impl_.message_.chunk_subscription_ = chunk_subscription;
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.Request.chunk_subscription)
}

inline ::minecpp::proto::service::storage::v1::RequestChunkSubscription *
Request::_internal_mutable_chunk_subscription()
{
   if (!_internal_has_chunk_subscription()) {
      clear_message();
      set_has_chunk_subscription();
      _impl_.message_.chunk_subscription_ =
              CreateMaybeMessage<::minecpp::proto::service::storage::v1::RequestChunkSubscription>(
                      GetArenaForAllocation());
   }
   return _impl_.message_.chunk_subscription_;
}

inline ::minecpp::proto::service::storage::v1::RequestChunkSubscription *Request::mutable_chunk_subscription()
{
   ::minecpp::proto::service::storage::v1::RequestChunkSubscription *_msg =
           _internal_mutable_chunk_subscription();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.Request.chunk_subscription)
   return _msg;
}

// .minecpp.proto.service.storage.v1.RequestChunkData chunk_data = 2;
inline bool Request::_internal_has_chunk_data() const
{
   return message_case() == kChunkData;
}

inline bool Request::has_chunk_data() const
{
   return _internal_has_chunk_data();
}

inline void Request::set_has_chunk_data()
{
   _impl_._oneof_case_[0] = kChunkData;
}

inline void Request::clear_chunk_data()
{
   if (_internal_has_chunk_data()) {
      if (GetArenaForAllocation() == nullptr) {
         delete _impl_.message_.chunk_data_;
      }
      clear_has_message();
   }
}

inline ::minecpp::proto::service::storage::v1::RequestChunkData *Request::release_chunk_data()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.Request.chunk_data)
   if (_internal_has_chunk_data()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::RequestChunkData *temp = _impl_.message_.chunk_data_;
      if (GetArenaForAllocation() != nullptr) {
         temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
      }
      _impl_.message_.chunk_data_ = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline const ::minecpp::proto::service::storage::v1::RequestChunkData &Request::_internal_chunk_data() const
{
   return _internal_has_chunk_data()
                  ? *_impl_.message_.chunk_data_
                  : reinterpret_cast<::minecpp::proto::service::storage::v1::RequestChunkData &>(
                            ::minecpp::proto::service::storage::v1::_RequestChunkData_default_instance_);
}

inline const ::minecpp::proto::service::storage::v1::RequestChunkData &Request::chunk_data() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.Request.chunk_data)
   return _internal_chunk_data();
}

inline ::minecpp::proto::service::storage::v1::RequestChunkData *Request::unsafe_arena_release_chunk_data()
{
   // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.v1.Request.chunk_data)
   if (_internal_has_chunk_data()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::RequestChunkData *temp = _impl_.message_.chunk_data_;
      _impl_.message_.chunk_data_                                    = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline void Request::unsafe_arena_set_allocated_chunk_data(
        ::minecpp::proto::service::storage::v1::RequestChunkData *chunk_data)
{
   clear_message();
   if (chunk_data) {
      set_has_chunk_data();
      _impl_.message_.chunk_data_ = chunk_data;
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.Request.chunk_data)
}

inline ::minecpp::proto::service::storage::v1::RequestChunkData *Request::_internal_mutable_chunk_data()
{
   if (!_internal_has_chunk_data()) {
      clear_message();
      set_has_chunk_data();
      _impl_.message_.chunk_data_ =
              CreateMaybeMessage<::minecpp::proto::service::storage::v1::RequestChunkData>(
                      GetArenaForAllocation());
   }
   return _impl_.message_.chunk_data_;
}

inline ::minecpp::proto::service::storage::v1::RequestChunkData *Request::mutable_chunk_data()
{
   ::minecpp::proto::service::storage::v1::RequestChunkData *_msg = _internal_mutable_chunk_data();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.Request.chunk_data)
   return _msg;
}

// .minecpp.proto.service.storage.v1.RequestSetClientId set_client_id = 3;
inline bool Request::_internal_has_set_client_id() const
{
   return message_case() == kSetClientId;
}

inline bool Request::has_set_client_id() const
{
   return _internal_has_set_client_id();
}

inline void Request::set_has_set_client_id()
{
   _impl_._oneof_case_[0] = kSetClientId;
}

inline void Request::clear_set_client_id()
{
   if (_internal_has_set_client_id()) {
      if (GetArenaForAllocation() == nullptr) {
         delete _impl_.message_.set_client_id_;
      }
      clear_has_message();
   }
}

inline ::minecpp::proto::service::storage::v1::RequestSetClientId *Request::release_set_client_id()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.Request.set_client_id)
   if (_internal_has_set_client_id()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::RequestSetClientId *temp = _impl_.message_.set_client_id_;
      if (GetArenaForAllocation() != nullptr) {
         temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
      }
      _impl_.message_.set_client_id_ = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline const ::minecpp::proto::service::storage::v1::RequestSetClientId &
Request::_internal_set_client_id() const
{
   return _internal_has_set_client_id()
                  ? *_impl_.message_.set_client_id_
                  : reinterpret_cast<::minecpp::proto::service::storage::v1::RequestSetClientId &>(
                            ::minecpp::proto::service::storage::v1::_RequestSetClientId_default_instance_);
}

inline const ::minecpp::proto::service::storage::v1::RequestSetClientId &Request::set_client_id() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.Request.set_client_id)
   return _internal_set_client_id();
}

inline ::minecpp::proto::service::storage::v1::RequestSetClientId *
Request::unsafe_arena_release_set_client_id()
{
   // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.v1.Request.set_client_id)
   if (_internal_has_set_client_id()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::RequestSetClientId *temp = _impl_.message_.set_client_id_;
      _impl_.message_.set_client_id_                                   = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline void Request::unsafe_arena_set_allocated_set_client_id(
        ::minecpp::proto::service::storage::v1::RequestSetClientId *set_client_id)
{
   clear_message();
   if (set_client_id) {
      set_has_set_client_id();
      _impl_.message_.set_client_id_ = set_client_id;
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.Request.set_client_id)
}

inline ::minecpp::proto::service::storage::v1::RequestSetClientId *Request::_internal_mutable_set_client_id()
{
   if (!_internal_has_set_client_id()) {
      clear_message();
      set_has_set_client_id();
      _impl_.message_.set_client_id_ =
              CreateMaybeMessage<::minecpp::proto::service::storage::v1::RequestSetClientId>(
                      GetArenaForAllocation());
   }
   return _impl_.message_.set_client_id_;
}

inline ::minecpp::proto::service::storage::v1::RequestSetClientId *Request::mutable_set_client_id()
{
   ::minecpp::proto::service::storage::v1::RequestSetClientId *_msg = _internal_mutable_set_client_id();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.Request.set_client_id)
   return _msg;
}

inline bool Request::has_message() const
{
   return message_case() != MESSAGE_NOT_SET;
}

inline void Request::clear_has_message()
{
   _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}

inline Request::MessageCase Request::message_case() const
{
   return Request::MessageCase(_impl_._oneof_case_[0]);
}

// -------------------------------------------------------------------

// RequestChunkSubscription

// .minecpp.proto.common.v1.ChunkPosition position = 1;
inline bool RequestChunkSubscription::_internal_has_position() const
{
   return this != internal_default_instance() && _impl_.position_ != nullptr;
}

inline bool RequestChunkSubscription::has_position() const
{
   return _internal_has_position();
}

inline const ::minecpp::proto::common::v1::ChunkPosition &RequestChunkSubscription::_internal_position() const
{
   const ::minecpp::proto::common::v1::ChunkPosition *p = _impl_.position_;
   return p != nullptr ? *p
                       : reinterpret_cast<const ::minecpp::proto::common::v1::ChunkPosition &>(
                                 ::minecpp::proto::common::v1::_ChunkPosition_default_instance_);
}

inline const ::minecpp::proto::common::v1::ChunkPosition &RequestChunkSubscription::position() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.RequestChunkSubscription.position)
   return _internal_position();
}

inline void RequestChunkSubscription::unsafe_arena_set_allocated_position(
        ::minecpp::proto::common::v1::ChunkPosition *position)
{
   if (GetArenaForAllocation() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.position_);
   }
   _impl_.position_ = position;
   if (position) {

   } else {
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.RequestChunkSubscription.position)
}

inline ::minecpp::proto::common::v1::ChunkPosition *RequestChunkSubscription::release_position()
{

   ::minecpp::proto::common::v1::ChunkPosition *temp = _impl_.position_;
   _impl_.position_                                  = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
   auto *old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(temp);
   temp      = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   if (GetArenaForAllocation() == nullptr) {
      delete old;
   }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
   if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   }
#endif// !PROTOBUF_FORCE_COPY_IN_RELEASE
   return temp;
}

inline ::minecpp::proto::common::v1::ChunkPosition *RequestChunkSubscription::unsafe_arena_release_position()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.RequestChunkSubscription.position)

   ::minecpp::proto::common::v1::ChunkPosition *temp = _impl_.position_;
   _impl_.position_                                  = nullptr;
   return temp;
}

inline ::minecpp::proto::common::v1::ChunkPosition *RequestChunkSubscription::_internal_mutable_position()
{

   if (_impl_.position_ == nullptr) {
      auto *p = CreateMaybeMessage<::minecpp::proto::common::v1::ChunkPosition>(GetArenaForAllocation());
      _impl_.position_ = p;
   }
   return _impl_.position_;
}

inline ::minecpp::proto::common::v1::ChunkPosition *RequestChunkSubscription::mutable_position()
{
   ::minecpp::proto::common::v1::ChunkPosition *_msg = _internal_mutable_position();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.RequestChunkSubscription.position)
   return _msg;
}

inline void
RequestChunkSubscription::set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position)
{
   ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
   if (message_arena == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.position_);
   }
   if (position) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(position));
      if (message_arena != submessage_arena) {
         position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, position,
                                                                       submessage_arena);
      }

   } else {
   }
   _impl_.position_ = position;
   // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.v1.RequestChunkSubscription.position)
}

// -------------------------------------------------------------------

// RequestChunkData

// .minecpp.proto.chunk.v1.Chunk chunk_data = 1;
inline bool RequestChunkData::_internal_has_chunk_data() const
{
   return this != internal_default_instance() && _impl_.chunk_data_ != nullptr;
}

inline bool RequestChunkData::has_chunk_data() const
{
   return _internal_has_chunk_data();
}

inline const ::minecpp::proto::chunk::v1::Chunk &RequestChunkData::_internal_chunk_data() const
{
   const ::minecpp::proto::chunk::v1::Chunk *p = _impl_.chunk_data_;
   return p != nullptr ? *p
                       : reinterpret_cast<const ::minecpp::proto::chunk::v1::Chunk &>(
                                 ::minecpp::proto::chunk::v1::_Chunk_default_instance_);
}

inline const ::minecpp::proto::chunk::v1::Chunk &RequestChunkData::chunk_data() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.RequestChunkData.chunk_data)
   return _internal_chunk_data();
}

inline void
RequestChunkData::unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data)
{
   if (GetArenaForAllocation() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.chunk_data_);
   }
   _impl_.chunk_data_ = chunk_data;
   if (chunk_data) {

   } else {
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.RequestChunkData.chunk_data)
}

inline ::minecpp::proto::chunk::v1::Chunk *RequestChunkData::release_chunk_data()
{

   ::minecpp::proto::chunk::v1::Chunk *temp = _impl_.chunk_data_;
   _impl_.chunk_data_                       = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
   auto *old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(temp);
   temp      = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   if (GetArenaForAllocation() == nullptr) {
      delete old;
   }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
   if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   }
#endif// !PROTOBUF_FORCE_COPY_IN_RELEASE
   return temp;
}

inline ::minecpp::proto::chunk::v1::Chunk *RequestChunkData::unsafe_arena_release_chunk_data()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.RequestChunkData.chunk_data)

   ::minecpp::proto::chunk::v1::Chunk *temp = _impl_.chunk_data_;
   _impl_.chunk_data_                       = nullptr;
   return temp;
}

inline ::minecpp::proto::chunk::v1::Chunk *RequestChunkData::_internal_mutable_chunk_data()
{

   if (_impl_.chunk_data_ == nullptr) {
      auto *p            = CreateMaybeMessage<::minecpp::proto::chunk::v1::Chunk>(GetArenaForAllocation());
      _impl_.chunk_data_ = p;
   }
   return _impl_.chunk_data_;
}

inline ::minecpp::proto::chunk::v1::Chunk *RequestChunkData::mutable_chunk_data()
{
   ::minecpp::proto::chunk::v1::Chunk *_msg = _internal_mutable_chunk_data();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.RequestChunkData.chunk_data)
   return _msg;
}

inline void RequestChunkData::set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data)
{
   ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
   if (message_arena == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.chunk_data_);
   }
   if (chunk_data) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(chunk_data));
      if (message_arena != submessage_arena) {
         chunk_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, chunk_data,
                                                                         submessage_arena);
      }

   } else {
   }
   _impl_.chunk_data_ = chunk_data;
   // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.v1.RequestChunkData.chunk_data)
}

// -------------------------------------------------------------------

// RequestSetClientId

// .minecpp.proto.service.storage.v1.ClientId client_id = 1;
inline bool RequestSetClientId::_internal_has_client_id() const
{
   return this != internal_default_instance() && _impl_.client_id_ != nullptr;
}

inline bool RequestSetClientId::has_client_id() const
{
   return _internal_has_client_id();
}

inline void RequestSetClientId::clear_client_id()
{
   if (GetArenaForAllocation() == nullptr && _impl_.client_id_ != nullptr) {
      delete _impl_.client_id_;
   }
   _impl_.client_id_ = nullptr;
}

inline const ::minecpp::proto::service::storage::v1::ClientId &RequestSetClientId::_internal_client_id() const
{
   const ::minecpp::proto::service::storage::v1::ClientId *p = _impl_.client_id_;
   return p != nullptr ? *p
                       : reinterpret_cast<const ::minecpp::proto::service::storage::v1::ClientId &>(
                                 ::minecpp::proto::service::storage::v1::_ClientId_default_instance_);
}

inline const ::minecpp::proto::service::storage::v1::ClientId &RequestSetClientId::client_id() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.RequestSetClientId.client_id)
   return _internal_client_id();
}

inline void RequestSetClientId::unsafe_arena_set_allocated_client_id(
        ::minecpp::proto::service::storage::v1::ClientId *client_id)
{
   if (GetArenaForAllocation() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.client_id_);
   }
   _impl_.client_id_ = client_id;
   if (client_id) {

   } else {
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.RequestSetClientId.client_id)
}

inline ::minecpp::proto::service::storage::v1::ClientId *RequestSetClientId::release_client_id()
{

   ::minecpp::proto::service::storage::v1::ClientId *temp = _impl_.client_id_;
   _impl_.client_id_                                      = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
   auto *old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(temp);
   temp      = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   if (GetArenaForAllocation() == nullptr) {
      delete old;
   }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
   if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   }
#endif// !PROTOBUF_FORCE_COPY_IN_RELEASE
   return temp;
}

inline ::minecpp::proto::service::storage::v1::ClientId *RequestSetClientId::unsafe_arena_release_client_id()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.RequestSetClientId.client_id)

   ::minecpp::proto::service::storage::v1::ClientId *temp = _impl_.client_id_;
   _impl_.client_id_                                      = nullptr;
   return temp;
}

inline ::minecpp::proto::service::storage::v1::ClientId *RequestSetClientId::_internal_mutable_client_id()
{

   if (_impl_.client_id_ == nullptr) {
      auto *p = CreateMaybeMessage<::minecpp::proto::service::storage::v1::ClientId>(GetArenaForAllocation());
      _impl_.client_id_ = p;
   }
   return _impl_.client_id_;
}

inline ::minecpp::proto::service::storage::v1::ClientId *RequestSetClientId::mutable_client_id()
{
   ::minecpp::proto::service::storage::v1::ClientId *_msg = _internal_mutable_client_id();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.RequestSetClientId.client_id)
   return _msg;
}

inline void
RequestSetClientId::set_allocated_client_id(::minecpp::proto::service::storage::v1::ClientId *client_id)
{
   ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
   if (message_arena == nullptr) {
      delete _impl_.client_id_;
   }
   if (client_id) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
      if (message_arena != submessage_arena) {
         client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, client_id,
                                                                        submessage_arena);
      }

   } else {
   }
   _impl_.client_id_ = client_id;
   // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.v1.RequestSetClientId.client_id)
}

// -------------------------------------------------------------------

// Response

// .minecpp.proto.service.storage.v1.ResponseChunkData chunk_data = 1;
inline bool Response::_internal_has_chunk_data() const
{
   return message_case() == kChunkData;
}

inline bool Response::has_chunk_data() const
{
   return _internal_has_chunk_data();
}

inline void Response::set_has_chunk_data()
{
   _impl_._oneof_case_[0] = kChunkData;
}

inline void Response::clear_chunk_data()
{
   if (_internal_has_chunk_data()) {
      if (GetArenaForAllocation() == nullptr) {
         delete _impl_.message_.chunk_data_;
      }
      clear_has_message();
   }
}

inline ::minecpp::proto::service::storage::v1::ResponseChunkData *Response::release_chunk_data()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.Response.chunk_data)
   if (_internal_has_chunk_data()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::ResponseChunkData *temp = _impl_.message_.chunk_data_;
      if (GetArenaForAllocation() != nullptr) {
         temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
      }
      _impl_.message_.chunk_data_ = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline const ::minecpp::proto::service::storage::v1::ResponseChunkData &Response::_internal_chunk_data() const
{
   return _internal_has_chunk_data()
                  ? *_impl_.message_.chunk_data_
                  : reinterpret_cast<::minecpp::proto::service::storage::v1::ResponseChunkData &>(
                            ::minecpp::proto::service::storage::v1::_ResponseChunkData_default_instance_);
}

inline const ::minecpp::proto::service::storage::v1::ResponseChunkData &Response::chunk_data() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.Response.chunk_data)
   return _internal_chunk_data();
}

inline ::minecpp::proto::service::storage::v1::ResponseChunkData *Response::unsafe_arena_release_chunk_data()
{
   // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.v1.Response.chunk_data)
   if (_internal_has_chunk_data()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::ResponseChunkData *temp = _impl_.message_.chunk_data_;
      _impl_.message_.chunk_data_                                     = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline void Response::unsafe_arena_set_allocated_chunk_data(
        ::minecpp::proto::service::storage::v1::ResponseChunkData *chunk_data)
{
   clear_message();
   if (chunk_data) {
      set_has_chunk_data();
      _impl_.message_.chunk_data_ = chunk_data;
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.Response.chunk_data)
}

inline ::minecpp::proto::service::storage::v1::ResponseChunkData *Response::_internal_mutable_chunk_data()
{
   if (!_internal_has_chunk_data()) {
      clear_message();
      set_has_chunk_data();
      _impl_.message_.chunk_data_ =
              CreateMaybeMessage<::minecpp::proto::service::storage::v1::ResponseChunkData>(
                      GetArenaForAllocation());
   }
   return _impl_.message_.chunk_data_;
}

inline ::minecpp::proto::service::storage::v1::ResponseChunkData *Response::mutable_chunk_data()
{
   ::minecpp::proto::service::storage::v1::ResponseChunkData *_msg = _internal_mutable_chunk_data();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.Response.chunk_data)
   return _msg;
}

// .minecpp.proto.service.storage.v1.ResponseEmptyChunk empty_chunk = 2;
inline bool Response::_internal_has_empty_chunk() const
{
   return message_case() == kEmptyChunk;
}

inline bool Response::has_empty_chunk() const
{
   return _internal_has_empty_chunk();
}

inline void Response::set_has_empty_chunk()
{
   _impl_._oneof_case_[0] = kEmptyChunk;
}

inline void Response::clear_empty_chunk()
{
   if (_internal_has_empty_chunk()) {
      if (GetArenaForAllocation() == nullptr) {
         delete _impl_.message_.empty_chunk_;
      }
      clear_has_message();
   }
}

inline ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *Response::release_empty_chunk()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.Response.empty_chunk)
   if (_internal_has_empty_chunk()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *temp = _impl_.message_.empty_chunk_;
      if (GetArenaForAllocation() != nullptr) {
         temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
      }
      _impl_.message_.empty_chunk_ = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline const ::minecpp::proto::service::storage::v1::ResponseEmptyChunk &
Response::_internal_empty_chunk() const
{
   return _internal_has_empty_chunk()
                  ? *_impl_.message_.empty_chunk_
                  : reinterpret_cast<::minecpp::proto::service::storage::v1::ResponseEmptyChunk &>(
                            ::minecpp::proto::service::storage::v1::_ResponseEmptyChunk_default_instance_);
}

inline const ::minecpp::proto::service::storage::v1::ResponseEmptyChunk &Response::empty_chunk() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.Response.empty_chunk)
   return _internal_empty_chunk();
}

inline ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *
Response::unsafe_arena_release_empty_chunk()
{
   // @@protoc_insertion_point(field_unsafe_arena_release:minecpp.proto.service.storage.v1.Response.empty_chunk)
   if (_internal_has_empty_chunk()) {
      clear_has_message();
      ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *temp = _impl_.message_.empty_chunk_;
      _impl_.message_.empty_chunk_                                     = nullptr;
      return temp;
   } else {
      return nullptr;
   }
}

inline void Response::unsafe_arena_set_allocated_empty_chunk(
        ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *empty_chunk)
{
   clear_message();
   if (empty_chunk) {
      set_has_empty_chunk();
      _impl_.message_.empty_chunk_ = empty_chunk;
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.Response.empty_chunk)
}

inline ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *Response::_internal_mutable_empty_chunk()
{
   if (!_internal_has_empty_chunk()) {
      clear_message();
      set_has_empty_chunk();
      _impl_.message_.empty_chunk_ =
              CreateMaybeMessage<::minecpp::proto::service::storage::v1::ResponseEmptyChunk>(
                      GetArenaForAllocation());
   }
   return _impl_.message_.empty_chunk_;
}

inline ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *Response::mutable_empty_chunk()
{
   ::minecpp::proto::service::storage::v1::ResponseEmptyChunk *_msg = _internal_mutable_empty_chunk();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.Response.empty_chunk)
   return _msg;
}

inline bool Response::has_message() const
{
   return message_case() != MESSAGE_NOT_SET;
}

inline void Response::clear_has_message()
{
   _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}

inline Response::MessageCase Response::message_case() const
{
   return Response::MessageCase(_impl_._oneof_case_[0]);
}

// -------------------------------------------------------------------

// ResponseEmptyChunk

// .minecpp.proto.common.v1.ChunkPosition position = 1;
inline bool ResponseEmptyChunk::_internal_has_position() const
{
   return this != internal_default_instance() && _impl_.position_ != nullptr;
}

inline bool ResponseEmptyChunk::has_position() const
{
   return _internal_has_position();
}

inline const ::minecpp::proto::common::v1::ChunkPosition &ResponseEmptyChunk::_internal_position() const
{
   const ::minecpp::proto::common::v1::ChunkPosition *p = _impl_.position_;
   return p != nullptr ? *p
                       : reinterpret_cast<const ::minecpp::proto::common::v1::ChunkPosition &>(
                                 ::minecpp::proto::common::v1::_ChunkPosition_default_instance_);
}

inline const ::minecpp::proto::common::v1::ChunkPosition &ResponseEmptyChunk::position() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.ResponseEmptyChunk.position)
   return _internal_position();
}

inline void
ResponseEmptyChunk::unsafe_arena_set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position)
{
   if (GetArenaForAllocation() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.position_);
   }
   _impl_.position_ = position;
   if (position) {

   } else {
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.ResponseEmptyChunk.position)
}

inline ::minecpp::proto::common::v1::ChunkPosition *ResponseEmptyChunk::release_position()
{

   ::minecpp::proto::common::v1::ChunkPosition *temp = _impl_.position_;
   _impl_.position_                                  = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
   auto *old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(temp);
   temp      = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   if (GetArenaForAllocation() == nullptr) {
      delete old;
   }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
   if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   }
#endif// !PROTOBUF_FORCE_COPY_IN_RELEASE
   return temp;
}

inline ::minecpp::proto::common::v1::ChunkPosition *ResponseEmptyChunk::unsafe_arena_release_position()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.ResponseEmptyChunk.position)

   ::minecpp::proto::common::v1::ChunkPosition *temp = _impl_.position_;
   _impl_.position_                                  = nullptr;
   return temp;
}

inline ::minecpp::proto::common::v1::ChunkPosition *ResponseEmptyChunk::_internal_mutable_position()
{

   if (_impl_.position_ == nullptr) {
      auto *p = CreateMaybeMessage<::minecpp::proto::common::v1::ChunkPosition>(GetArenaForAllocation());
      _impl_.position_ = p;
   }
   return _impl_.position_;
}

inline ::minecpp::proto::common::v1::ChunkPosition *ResponseEmptyChunk::mutable_position()
{
   ::minecpp::proto::common::v1::ChunkPosition *_msg = _internal_mutable_position();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.ResponseEmptyChunk.position)
   return _msg;
}

inline void ResponseEmptyChunk::set_allocated_position(::minecpp::proto::common::v1::ChunkPosition *position)
{
   ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
   if (message_arena == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.position_);
   }
   if (position) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(position));
      if (message_arena != submessage_arena) {
         position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, position,
                                                                       submessage_arena);
      }

   } else {
   }
   _impl_.position_ = position;
   // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.v1.ResponseEmptyChunk.position)
}

// -------------------------------------------------------------------

// ResponseChunkData

// .minecpp.proto.chunk.v1.Chunk chunk_data = 1;
inline bool ResponseChunkData::_internal_has_chunk_data() const
{
   return this != internal_default_instance() && _impl_.chunk_data_ != nullptr;
}

inline bool ResponseChunkData::has_chunk_data() const
{
   return _internal_has_chunk_data();
}

inline const ::minecpp::proto::chunk::v1::Chunk &ResponseChunkData::_internal_chunk_data() const
{
   const ::minecpp::proto::chunk::v1::Chunk *p = _impl_.chunk_data_;
   return p != nullptr ? *p
                       : reinterpret_cast<const ::minecpp::proto::chunk::v1::Chunk &>(
                                 ::minecpp::proto::chunk::v1::_Chunk_default_instance_);
}

inline const ::minecpp::proto::chunk::v1::Chunk &ResponseChunkData::chunk_data() const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.ResponseChunkData.chunk_data)
   return _internal_chunk_data();
}

inline void
ResponseChunkData::unsafe_arena_set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data)
{
   if (GetArenaForAllocation() == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.chunk_data_);
   }
   _impl_.chunk_data_ = chunk_data;
   if (chunk_data) {

   } else {
   }
   // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minecpp.proto.service.storage.v1.ResponseChunkData.chunk_data)
}

inline ::minecpp::proto::chunk::v1::Chunk *ResponseChunkData::release_chunk_data()
{

   ::minecpp::proto::chunk::v1::Chunk *temp = _impl_.chunk_data_;
   _impl_.chunk_data_                       = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
   auto *old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(temp);
   temp      = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   if (GetArenaForAllocation() == nullptr) {
      delete old;
   }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
   if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
   }
#endif// !PROTOBUF_FORCE_COPY_IN_RELEASE
   return temp;
}

inline ::minecpp::proto::chunk::v1::Chunk *ResponseChunkData::unsafe_arena_release_chunk_data()
{
   // @@protoc_insertion_point(field_release:minecpp.proto.service.storage.v1.ResponseChunkData.chunk_data)

   ::minecpp::proto::chunk::v1::Chunk *temp = _impl_.chunk_data_;
   _impl_.chunk_data_                       = nullptr;
   return temp;
}

inline ::minecpp::proto::chunk::v1::Chunk *ResponseChunkData::_internal_mutable_chunk_data()
{

   if (_impl_.chunk_data_ == nullptr) {
      auto *p            = CreateMaybeMessage<::minecpp::proto::chunk::v1::Chunk>(GetArenaForAllocation());
      _impl_.chunk_data_ = p;
   }
   return _impl_.chunk_data_;
}

inline ::minecpp::proto::chunk::v1::Chunk *ResponseChunkData::mutable_chunk_data()
{
   ::minecpp::proto::chunk::v1::Chunk *_msg = _internal_mutable_chunk_data();
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.ResponseChunkData.chunk_data)
   return _msg;
}

inline void ResponseChunkData::set_allocated_chunk_data(::minecpp::proto::chunk::v1::Chunk *chunk_data)
{
   ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
   if (message_arena == nullptr) {
      delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(_impl_.chunk_data_);
   }
   if (chunk_data) {
      ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
              ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(chunk_data));
      if (message_arena != submessage_arena) {
         chunk_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, chunk_data,
                                                                         submessage_arena);
      }

   } else {
   }
   _impl_.chunk_data_ = chunk_data;
   // @@protoc_insertion_point(field_set_allocated:minecpp.proto.service.storage.v1.ResponseChunkData.chunk_data)
}

// -------------------------------------------------------------------

// ChunkSubscription

// repeated .minecpp.proto.service.storage.v1.ClientId client_ids = 1;
inline int ChunkSubscription::_internal_client_ids_size() const
{
   return _impl_.client_ids_.size();
}

inline int ChunkSubscription::client_ids_size() const
{
   return _internal_client_ids_size();
}

inline void ChunkSubscription::clear_client_ids()
{
   _impl_.client_ids_.Clear();
}

inline ::minecpp::proto::service::storage::v1::ClientId *ChunkSubscription::mutable_client_ids(int index)
{
   // @@protoc_insertion_point(field_mutable:minecpp.proto.service.storage.v1.ChunkSubscription.client_ids)
   return _impl_.client_ids_.Mutable(index);
}

inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::minecpp::proto::service::storage::v1::ClientId> *
ChunkSubscription::mutable_client_ids()
{
   // @@protoc_insertion_point(field_mutable_list:minecpp.proto.service.storage.v1.ChunkSubscription.client_ids)
   return &_impl_.client_ids_;
}

inline const ::minecpp::proto::service::storage::v1::ClientId &
ChunkSubscription::_internal_client_ids(int index) const
{
   return _impl_.client_ids_.Get(index);
}

inline const ::minecpp::proto::service::storage::v1::ClientId &ChunkSubscription::client_ids(int index) const
{
   // @@protoc_insertion_point(field_get:minecpp.proto.service.storage.v1.ChunkSubscription.client_ids)
   return _internal_client_ids(index);
}

inline ::minecpp::proto::service::storage::v1::ClientId *ChunkSubscription::_internal_add_client_ids()
{
   return _impl_.client_ids_.Add();
}

inline ::minecpp::proto::service::storage::v1::ClientId *ChunkSubscription::add_client_ids()
{
   ::minecpp::proto::service::storage::v1::ClientId *_add = _internal_add_client_ids();
   // @@protoc_insertion_point(field_add:minecpp.proto.service.storage.v1.ChunkSubscription.client_ids)
   return _add;
}

inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::minecpp::proto::service::storage::v1::ClientId> &
ChunkSubscription::client_ids() const
{
   // @@protoc_insertion_point(field_list:minecpp.proto.service.storage.v1.ChunkSubscription.client_ids)
   return _impl_.client_ids_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif// __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}}}}}// namespace minecpp::proto::service::storage::v1

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif// GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_minecpp_2fproto_2fservice_2fstorage_2fv1_2fStorage_2eproto
