// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: minecpp/proto/event/clientbound/Clientbound.proto

#include <minecpp/proto/event/clientbound/Clientbound.pb.h>

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace minecpp {
namespace proto {
namespace event {
namespace clientbound {
template <typename>
PROTOBUF_CONSTEXPR Event::Event(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.payload_)*/nullptr
  , /*decltype(_impl_.recipient_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDefaultTypeInternal _Event_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RecipientSinglePlayer::RecipientSinglePlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr} {}
struct RecipientSinglePlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecipientSinglePlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecipientSinglePlayerDefaultTypeInternal() {}
  union {
    RecipientSinglePlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecipientSinglePlayerDefaultTypeInternal _RecipientSinglePlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RecipientMultiplePlayers::RecipientMultiplePlayers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecipientMultiplePlayersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecipientMultiplePlayersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecipientMultiplePlayersDefaultTypeInternal() {}
  union {
    RecipientMultiplePlayers _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecipientMultiplePlayersDefaultTypeInternal _RecipientMultiplePlayers_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RecipientAllPlayers::RecipientAllPlayers(
    ::_pbi::ConstantInitialized) {}
struct RecipientAllPlayersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecipientAllPlayersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecipientAllPlayersDefaultTypeInternal() {}
  union {
    RecipientAllPlayers _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecipientAllPlayersDefaultTypeInternal _RecipientAllPlayers_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RecipientExcluding::RecipientExcluding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr} {}
struct RecipientExcludingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecipientExcludingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecipientExcludingDefaultTypeInternal() {}
  union {
    RecipientExcluding _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecipientExcludingDefaultTypeInternal _RecipientExcluding_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AddPlayer::AddPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.player_id_)*/nullptr
  , /*decltype(_impl_.game_mode_)*/ 0

  , /*decltype(_impl_.ping_)*/ 0u
} {}
struct AddPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddPlayerDefaultTypeInternal() {}
  union {
    AddPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddPlayerDefaultTypeInternal _AddPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpawnEntity::SpawnEntity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_)*/nullptr} {}
struct SpawnEntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpawnEntityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpawnEntityDefaultTypeInternal() {}
  union {
    SpawnEntity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpawnEntityDefaultTypeInternal _SpawnEntity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SpawnPlayer::SpawnPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr
  , /*decltype(_impl_.entity_)*/nullptr} {}
struct SpawnPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpawnPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpawnPlayerDefaultTypeInternal() {}
  union {
    SpawnPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpawnPlayerDefaultTypeInternal _SpawnPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EntityMove::EntityMove(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.movement_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.entity_id_)*/ 0u

  , /*decltype(_impl_.is_on_ground_)*/ false
} {}
struct EntityMoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntityMoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntityMoveDefaultTypeInternal() {}
  union {
    EntityMove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntityMoveDefaultTypeInternal _EntityMove_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EntityLook::EntityLook(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.entity_id_)*/ 0u
} {}
struct EntityLookDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntityLookDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntityLookDefaultTypeInternal() {}
  union {
    EntityLook _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntityLookDefaultTypeInternal _EntityLook_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlayerPositionRotation::PlayerPositionRotation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr} {}
struct PlayerPositionRotationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerPositionRotationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerPositionRotationDefaultTypeInternal() {}
  union {
    PlayerPositionRotation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerPositionRotationDefaultTypeInternal _PlayerPositionRotation_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetSpawnPosition::SetSpawnPosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.position_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.angle_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetSpawnPositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetSpawnPositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetSpawnPositionDefaultTypeInternal() {}
  union {
    SetSpawnPosition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetSpawnPositionDefaultTypeInternal _SetSpawnPosition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Chat::Chat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ChatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChatDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChatDefaultTypeInternal() {}
  union {
    Chat _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChatDefaultTypeInternal _Chat_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RemovePlayer::RemovePlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr
  , /*decltype(_impl_.entity_id_)*/ 0u
} {}
struct RemovePlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemovePlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemovePlayerDefaultTypeInternal() {}
  union {
    RemovePlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemovePlayerDefaultTypeInternal _RemovePlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdateBlock::UpdateBlock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_position_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.state_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateBlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateBlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateBlockDefaultTypeInternal() {}
  union {
    UpdateBlock _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateBlockDefaultTypeInternal _UpdateBlock_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AnimateEntity::AnimateEntity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entity_id_)*/ 0u

  , /*decltype(_impl_.animation_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnimateEntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnimateEntityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnimateEntityDefaultTypeInternal() {}
  union {
    AnimateEntity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnimateEntityDefaultTypeInternal _AnimateEntity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AcknowledgeBlockChange::AcknowledgeBlockChange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sequence_id_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AcknowledgeBlockChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcknowledgeBlockChangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcknowledgeBlockChangeDefaultTypeInternal() {}
  union {
    AcknowledgeBlockChange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcknowledgeBlockChangeDefaultTypeInternal _AcknowledgeBlockChange_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LoadTerrain::LoadTerrain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.coords_)*/{}
  , /*decltype(_impl_.central_chunk_)*/nullptr} {}
struct LoadTerrainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadTerrainDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadTerrainDefaultTypeInternal() {}
  union {
    LoadTerrain _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadTerrainDefaultTypeInternal _LoadTerrain_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TransferPlayer::TransferPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.engine_instance_id_)*/ ::uint64_t{0u}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransferPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransferPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransferPlayerDefaultTypeInternal() {}
  union {
    TransferPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransferPlayerDefaultTypeInternal _TransferPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdatePlayerAbilities::UpdatePlayerAbilities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr
  , /*decltype(_impl_.invulnerable_)*/ false

  , /*decltype(_impl_.is_flying_)*/ false

  , /*decltype(_impl_.allow_flying_)*/ false

  , /*decltype(_impl_.creative_mode_)*/ false

  , /*decltype(_impl_.walk_speed_)*/ 0

  , /*decltype(_impl_.fly_speed_)*/ 0
} {}
struct UpdatePlayerAbilitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdatePlayerAbilitiesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdatePlayerAbilitiesDefaultTypeInternal() {}
  union {
    UpdatePlayerAbilities _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdatePlayerAbilitiesDefaultTypeInternal _UpdatePlayerAbilities_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UnloadChunk::UnloadChunk(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_id_)*/nullptr
  , /*decltype(_impl_.chunk_position_)*/nullptr} {}
struct UnloadChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnloadChunkDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnloadChunkDefaultTypeInternal() {}
  union {
    UnloadChunk _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnloadChunkDefaultTypeInternal _UnloadChunk_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PlayerList::PlayerList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.list_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerListDefaultTypeInternal() {}
  union {
    PlayerList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerListDefaultTypeInternal _PlayerList_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EntityList::EntityList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entities_)*/{}
  , /*decltype(_impl_.player_entities_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EntityListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntityListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntityListDefaultTypeInternal() {}
  union {
    EntityList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntityListDefaultTypeInternal _EntityList_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetEntityVelocity::SetEntityVelocity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.entity_id_)*/ 0u
} {}
struct SetEntityVelocityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetEntityVelocityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetEntityVelocityDefaultTypeInternal() {}
  union {
    SetEntityVelocity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetEntityVelocityDefaultTypeInternal _SetEntityVelocity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AcceptPlayer::AcceptPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gameplay_)*/nullptr
  , /*decltype(_impl_.abilities_)*/nullptr
  , /*decltype(_impl_.player_)*/nullptr} {}
struct AcceptPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcceptPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcceptPlayerDefaultTypeInternal() {}
  union {
    AcceptPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcceptPlayerDefaultTypeInternal _AcceptPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DenyPlayer::DenyPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denial_reason_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DenyPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DenyPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DenyPlayerDefaultTypeInternal() {}
  union {
    DenyPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DenyPlayerDefaultTypeInternal _DenyPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetInventorySlot::SetInventorySlot(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_)*/nullptr
  , /*decltype(_impl_.slot_id_)*/ 0u
} {}
struct SetInventorySlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetInventorySlotDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetInventorySlotDefaultTypeInternal() {}
  union {
    SetInventorySlot _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetInventorySlotDefaultTypeInternal _SetInventorySlot_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SectionBlockLight::SectionBlockLight(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_light_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SectionBlockLightDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SectionBlockLightDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SectionBlockLightDefaultTypeInternal() {}
  union {
    SectionBlockLight _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SectionBlockLightDefaultTypeInternal _SectionBlockLight_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChunkBlockLight::ChunkBlockLight(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sections_)*/{}
  , /*decltype(_impl_.position_)*/nullptr} {}
struct ChunkBlockLightDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkBlockLightDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkBlockLightDefaultTypeInternal() {}
  union {
    ChunkBlockLight _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkBlockLightDefaultTypeInternal _ChunkBlockLight_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdateBlockLight::UpdateBlockLight(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_light_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateBlockLightDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateBlockLightDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateBlockLightDefaultTypeInternal() {}
  union {
    UpdateBlockLight _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateBlockLightDefaultTypeInternal _UpdateBlockLight_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ChunkData::ChunkData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chunk_)*/nullptr
  , /*decltype(_impl_.is_initial_chunk_)*/ false
} {}
struct ChunkDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkDataDefaultTypeInternal() {}
  union {
    ChunkData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkDataDefaultTypeInternal _ChunkData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetCenterChunk::SetCenterChunk(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr} {}
struct SetCenterChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetCenterChunkDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetCenterChunkDefaultTypeInternal() {}
  union {
    SetCenterChunk _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetCenterChunkDefaultTypeInternal _SetCenterChunk_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetEntityEquipment::SetEntityEquipment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.item_)*/nullptr
  , /*decltype(_impl_.entity_id_)*/ 0u

  , /*decltype(_impl_.equipment_slot_)*/ 0
} {}
struct SetEntityEquipmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetEntityEquipmentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetEntityEquipmentDefaultTypeInternal() {}
  union {
    SetEntityEquipment _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetEntityEquipmentDefaultTypeInternal _SetEntityEquipment_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetHealth::SetHealth(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.health_)*/ 0

  , /*decltype(_impl_.food_)*/ 0

  , /*decltype(_impl_.food_saturation_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetHealthDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetHealthDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetHealthDefaultTypeInternal() {}
  union {
    SetHealth _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetHealthDefaultTypeInternal _SetHealth_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CollectItem::CollectItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.collected_entity_id_)*/ 0u

  , /*decltype(_impl_.collector_entity_id_)*/ 0u

  , /*decltype(_impl_.count_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CollectItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CollectItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CollectItemDefaultTypeInternal() {}
  union {
    CollectItem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CollectItemDefaultTypeInternal _CollectItem_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RemoveEntity::RemoveEntity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entity_id_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RemoveEntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveEntityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveEntityDefaultTypeInternal() {}
  union {
    RemoveEntity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveEntityDefaultTypeInternal _RemoveEntity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TeleportEntity::TeleportEntity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.entity_id_)*/ 0u

  , /*decltype(_impl_.is_on_ground_)*/ false
} {}
struct TeleportEntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TeleportEntityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TeleportEntityDefaultTypeInternal() {}
  union {
    TeleportEntity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TeleportEntityDefaultTypeInternal _TeleportEntity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DisplayDeathScreen::DisplayDeathScreen(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.death_message_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.victim_entity_id_)*/ 0u

  , /*decltype(_impl_.killer_entity_id_)*/ 0u

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DisplayDeathScreenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisplayDeathScreenDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisplayDeathScreenDefaultTypeInternal() {}
  union {
    DisplayDeathScreen _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplayDeathScreenDefaultTypeInternal _DisplayDeathScreen_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Respawn::Respawn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dimension_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dimension_name_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.death_dimension_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.death_position_)*/nullptr
  , /*decltype(_impl_.hashed_seed_)*/ ::int64_t{0}

  , /*decltype(_impl_.game_mode_)*/ 0

  , /*decltype(_impl_.previous_game_mode_)*/ 0

  , /*decltype(_impl_.is_debug_)*/ false

  , /*decltype(_impl_.is_flat_)*/ false

  , /*decltype(_impl_.copy_metadata_)*/ false

  , /*decltype(_impl_.has_death_location_)*/ false
} {}
struct RespawnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RespawnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RespawnDefaultTypeInternal() {}
  union {
    Respawn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RespawnDefaultTypeInternal _Respawn_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SetAbilities::SetAbilities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.abilities_)*/nullptr} {}
struct SetAbilitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetAbilitiesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetAbilitiesDefaultTypeInternal() {}
  union {
    SetAbilities _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetAbilitiesDefaultTypeInternal _SetAbilities_default_instance_;
}  // namespace clientbound
}  // namespace event
}  // namespace proto
}  // namespace minecpp
static ::_pb::Metadata file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[40];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto = nullptr;
const ::uint32_t TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Event, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Event, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Event, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Event, _impl_.payload_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Event, _impl_.recipient_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientSinglePlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientSinglePlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientSinglePlayer, _impl_.player_id_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientMultiplePlayers, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientMultiplePlayers, _impl_.player_ids_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientAllPlayers, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientExcluding, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientExcluding, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RecipientExcluding, _impl_.player_id_),
    0,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AddPlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AddPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AddPlayer, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AddPlayer, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AddPlayer, _impl_.game_mode_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AddPlayer, _impl_.ping_),
    0,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnEntity, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnEntity, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnEntity, _impl_.entity_),
    0,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnPlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnPlayer, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SpawnPlayer, _impl_.entity_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityMove, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityMove, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityMove, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityMove, _impl_.movement_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityMove, _impl_.rotation_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityMove, _impl_.is_on_ground_),
    ~0u,
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityLook, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityLook, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityLook, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityLook, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityLook, _impl_.rotation_),
    0,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::PlayerPositionRotation, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::PlayerPositionRotation, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::PlayerPositionRotation, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::PlayerPositionRotation, _impl_.rotation_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetSpawnPosition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetSpawnPosition, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetSpawnPosition, _impl_.angle_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Chat, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Chat, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Chat, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RemovePlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RemovePlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RemovePlayer, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RemovePlayer, _impl_.entity_id_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdateBlock, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdateBlock, _impl_.block_position_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdateBlock, _impl_.state_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AnimateEntity, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AnimateEntity, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AnimateEntity, _impl_.animation_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcknowledgeBlockChange, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcknowledgeBlockChange, _impl_.sequence_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::LoadTerrain, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::LoadTerrain, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::LoadTerrain, _impl_.central_chunk_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::LoadTerrain, _impl_.coords_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TransferPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TransferPlayer, _impl_.engine_instance_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.invulnerable_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.is_flying_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.allow_flying_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.creative_mode_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.walk_speed_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdatePlayerAbilities, _impl_.fly_speed_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UnloadChunk, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UnloadChunk, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UnloadChunk, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UnloadChunk, _impl_.chunk_position_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::PlayerList, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::PlayerList, _impl_.list_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityList, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityList, _impl_.entities_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::EntityList, _impl_.player_entities_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityVelocity, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityVelocity, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityVelocity, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityVelocity, _impl_.velocity_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcceptPlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcceptPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcceptPlayer, _impl_.gameplay_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcceptPlayer, _impl_.abilities_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::AcceptPlayer, _impl_.player_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::DenyPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::DenyPlayer, _impl_.denial_reason_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetInventorySlot, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetInventorySlot, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetInventorySlot, _impl_.slot_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetInventorySlot, _impl_.slot_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SectionBlockLight, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SectionBlockLight, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SectionBlockLight, _impl_.block_light_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkBlockLight, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkBlockLight, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkBlockLight, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkBlockLight, _impl_.sections_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdateBlockLight, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::UpdateBlockLight, _impl_.block_light_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkData, _impl_.chunk_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::ChunkData, _impl_.is_initial_chunk_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetCenterChunk, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetCenterChunk, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetCenterChunk, _impl_.position_),
    0,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityEquipment, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityEquipment, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityEquipment, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityEquipment, _impl_.equipment_slot_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetEntityEquipment, _impl_.item_),
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetHealth, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetHealth, _impl_.health_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetHealth, _impl_.food_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetHealth, _impl_.food_saturation_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::CollectItem, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::CollectItem, _impl_.collected_entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::CollectItem, _impl_.collector_entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::CollectItem, _impl_.count_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RemoveEntity, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::RemoveEntity, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TeleportEntity, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TeleportEntity, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TeleportEntity, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TeleportEntity, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TeleportEntity, _impl_.rotation_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::TeleportEntity, _impl_.is_on_ground_),
    ~0u,
    0,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::DisplayDeathScreen, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::DisplayDeathScreen, _impl_.victim_entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::DisplayDeathScreen, _impl_.killer_entity_id_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::DisplayDeathScreen, _impl_.death_message_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.dimension_type_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.dimension_name_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.hashed_seed_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.game_mode_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.previous_game_mode_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.is_debug_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.is_flat_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.copy_metadata_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.has_death_location_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.death_dimension_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Respawn, _impl_.death_position_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetAbilities, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetAbilities, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::SetAbilities, _impl_.abilities_),
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 14, -1, sizeof(::minecpp::proto::event::clientbound::Event)},
        { 19, 28, -1, sizeof(::minecpp::proto::event::clientbound::RecipientSinglePlayer)},
        { 29, -1, -1, sizeof(::minecpp::proto::event::clientbound::RecipientMultiplePlayers)},
        { 38, -1, -1, sizeof(::minecpp::proto::event::clientbound::RecipientAllPlayers)},
        { 46, 55, -1, sizeof(::minecpp::proto::event::clientbound::RecipientExcluding)},
        { 56, 68, -1, sizeof(::minecpp::proto::event::clientbound::AddPlayer)},
        { 72, 81, -1, sizeof(::minecpp::proto::event::clientbound::SpawnEntity)},
        { 82, 92, -1, sizeof(::minecpp::proto::event::clientbound::SpawnPlayer)},
        { 94, 106, -1, sizeof(::minecpp::proto::event::clientbound::EntityMove)},
        { 110, 121, -1, sizeof(::minecpp::proto::event::clientbound::EntityLook)},
        { 124, 134, -1, sizeof(::minecpp::proto::event::clientbound::PlayerPositionRotation)},
        { 136, -1, -1, sizeof(::minecpp::proto::event::clientbound::SetSpawnPosition)},
        { 146, -1, -1, sizeof(::minecpp::proto::event::clientbound::Chat)},
        { 156, 166, -1, sizeof(::minecpp::proto::event::clientbound::RemovePlayer)},
        { 168, -1, -1, sizeof(::minecpp::proto::event::clientbound::UpdateBlock)},
        { 178, -1, -1, sizeof(::minecpp::proto::event::clientbound::AnimateEntity)},
        { 188, -1, -1, sizeof(::minecpp::proto::event::clientbound::AcknowledgeBlockChange)},
        { 197, 207, -1, sizeof(::minecpp::proto::event::clientbound::LoadTerrain)},
        { 209, -1, -1, sizeof(::minecpp::proto::event::clientbound::TransferPlayer)},
        { 218, 233, -1, sizeof(::minecpp::proto::event::clientbound::UpdatePlayerAbilities)},
        { 240, 250, -1, sizeof(::minecpp::proto::event::clientbound::UnloadChunk)},
        { 252, -1, -1, sizeof(::minecpp::proto::event::clientbound::PlayerList)},
        { 261, -1, -1, sizeof(::minecpp::proto::event::clientbound::EntityList)},
        { 271, 281, -1, sizeof(::minecpp::proto::event::clientbound::SetEntityVelocity)},
        { 283, 294, -1, sizeof(::minecpp::proto::event::clientbound::AcceptPlayer)},
        { 297, -1, -1, sizeof(::minecpp::proto::event::clientbound::DenyPlayer)},
        { 306, 316, -1, sizeof(::minecpp::proto::event::clientbound::SetInventorySlot)},
        { 318, -1, -1, sizeof(::minecpp::proto::event::clientbound::SectionBlockLight)},
        { 328, 338, -1, sizeof(::minecpp::proto::event::clientbound::ChunkBlockLight)},
        { 340, -1, -1, sizeof(::minecpp::proto::event::clientbound::UpdateBlockLight)},
        { 349, 359, -1, sizeof(::minecpp::proto::event::clientbound::ChunkData)},
        { 361, 370, -1, sizeof(::minecpp::proto::event::clientbound::SetCenterChunk)},
        { 371, 382, -1, sizeof(::minecpp::proto::event::clientbound::SetEntityEquipment)},
        { 385, -1, -1, sizeof(::minecpp::proto::event::clientbound::SetHealth)},
        { 396, -1, -1, sizeof(::minecpp::proto::event::clientbound::CollectItem)},
        { 407, -1, -1, sizeof(::minecpp::proto::event::clientbound::RemoveEntity)},
        { 416, 428, -1, sizeof(::minecpp::proto::event::clientbound::TeleportEntity)},
        { 432, -1, -1, sizeof(::minecpp::proto::event::clientbound::DisplayDeathScreen)},
        { 443, 462, -1, sizeof(::minecpp::proto::event::clientbound::Respawn)},
        { 473, 482, -1, sizeof(::minecpp::proto::event::clientbound::SetAbilities)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::minecpp::proto::event::clientbound::_Event_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_RecipientSinglePlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_RecipientMultiplePlayers_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_RecipientAllPlayers_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_RecipientExcluding_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_AddPlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SpawnEntity_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SpawnPlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_EntityMove_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_EntityLook_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_PlayerPositionRotation_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetSpawnPosition_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_Chat_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_RemovePlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_UpdateBlock_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_AnimateEntity_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_AcknowledgeBlockChange_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_LoadTerrain_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_TransferPlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_UpdatePlayerAbilities_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_UnloadChunk_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_PlayerList_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_EntityList_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetEntityVelocity_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_AcceptPlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_DenyPlayer_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetInventorySlot_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SectionBlockLight_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_ChunkBlockLight_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_UpdateBlockLight_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_ChunkData_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetCenterChunk_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetEntityEquipment_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetHealth_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_CollectItem_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_RemoveEntity_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_TeleportEntity_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_DisplayDeathScreen_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_Respawn_default_instance_._instance,
    &::minecpp::proto::event::clientbound::_SetAbilities_default_instance_._instance,
};
const char descriptor_table_protodef_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n1minecpp/proto/event/clientbound/Client"
    "bound.proto\022\037minecpp.proto.event.clientb"
    "ound\032\031google/protobuf/any.proto\032!minecpp"
    "/proto/common/Common.proto\032!minecpp/prot"
    "o/common/Vector.proto\032\035minecpp/proto/pla"
    "yer/Id.proto\032!minecpp/proto/player/Playe"
    "r.proto\032!minecpp/proto/entity/Entity.pro"
    "to\032\037minecpp/proto/chunk/Chunk.proto\"\372\002\n\005"
    "Event\022%\n\007payload\030\001 \001(\0132\024.google.protobuf"
    ".Any\022O\n\rsingle_player\030\002 \001(\01326.minecpp.pr"
    "oto.event.clientbound.RecipientSinglePla"
    "yerH\000\022U\n\020multiple_players\030\003 \001(\01329.minecp"
    "p.proto.event.clientbound.RecipientMulti"
    "plePlayersH\000\022K\n\013all_players\030\004 \001(\01324.mine"
    "cpp.proto.event.clientbound.RecipientAll"
    "PlayersH\000\022H\n\texcluding\030\005 \001(\01323.minecpp.p"
    "roto.event.clientbound.RecipientExcludin"
    "gH\000B\013\n\trecipient\"J\n\025RecipientSinglePlaye"
    "r\0221\n\tplayer_id\030\001 \001(\0132\036.minecpp.proto.pla"
    "yer.PlayerId\"N\n\030RecipientMultiplePlayers"
    "\0222\n\nplayer_ids\030\001 \003(\0132\036.minecpp.proto.pla"
    "yer.PlayerId\"\025\n\023RecipientAllPlayers\"G\n\022R"
    "ecipientExcluding\0221\n\tplayer_id\030\001 \001(\0132\036.m"
    "inecpp.proto.player.PlayerId\"\215\001\n\tAddPlay"
    "er\0221\n\tplayer_id\030\001 \001(\0132\036.minecpp.proto.pl"
    "ayer.PlayerId\022\014\n\004name\030\002 \001(\t\0221\n\tgame_mode"
    "\030\003 \001(\0162\036.minecpp.proto.common.GameMode\022\014"
    "\n\004ping\030\004 \001(\r\";\n\013SpawnEntity\022,\n\006entity\030\001 "
    "\001(\0132\034.minecpp.proto.entity.Entity\"t\n\013Spa"
    "wnPlayer\0221\n\tplayer_id\030\001 \001(\0132\036.minecpp.pr"
    "oto.player.PlayerId\0222\n\006entity\030\002 \001(\0132\".mi"
    "necpp.proto.entity.PlayerEntity\"\231\001\n\nEnti"
    "tyMove\022\021\n\tentity_id\030\001 \001(\r\0220\n\010movement\030\002 "
    "\001(\0132\036.minecpp.proto.common.Vector3i\0220\n\010r"
    "otation\030\003 \001(\0132\036.minecpp.proto.common.Rot"
    "ation\022\024\n\014is_on_ground\030\004 \001(\010\"\204\001\n\nEntityLo"
    "ok\0221\n\tplayer_id\030\001 \001(\0132\036.minecpp.proto.pl"
    "ayer.PlayerId\022\021\n\tentity_id\030\002 \001(\r\0220\n\010rota"
    "tion\030\003 \001(\0132\036.minecpp.proto.common.Rotati"
    "on\"{\n\026PlayerPositionRotation\022/\n\010position"
    "\030\001 \001(\0132\035.minecpp.proto.common.Vector3\0220\n"
    "\010rotation\030\002 \001(\0132\036.minecpp.proto.common.R"
    "otation\"3\n\020SetSpawnPosition\022\020\n\010position\030"
    "\001 \001(\004\022\r\n\005angle\030\002 \001(\002\"%\n\004Chat\022\017\n\007message\030"
    "\001 \001(\t\022\014\n\004type\030\002 \001(\005\"T\n\014RemovePlayer\0221\n\tp"
    "layer_id\030\001 \001(\0132\036.minecpp.proto.player.Pl"
    "ayerId\022\021\n\tentity_id\030\002 \001(\r\"4\n\013UpdateBlock"
    "\022\026\n\016block_position\030\001 \001(\004\022\r\n\005state\030\002 \001(\r\""
    "\\\n\rAnimateEntity\022\021\n\tentity_id\030\001 \001(\r\0228\n\ta"
    "nimation\030\002 \001(\0162%.minecpp.proto.common.En"
    "tityAnimation\"-\n\026AcknowledgeBlockChange\022"
    "\023\n\013sequence_id\030\001 \001(\005\"~\n\013LoadTerrain\022:\n\rc"
    "entral_chunk\030\001 \001(\0132#.minecpp.proto.commo"
    "n.ChunkPosition\0223\n\006coords\030\002 \003(\0132#.minecp"
    "p.proto.common.ChunkPosition\",\n\016Transfer"
    "Player\022\032\n\022engine_instance_id\030\002 \001(\004\"\307\001\n\025U"
    "pdatePlayerAbilities\0221\n\tplayer_id\030\001 \001(\0132"
    "\036.minecpp.proto.player.PlayerId\022\024\n\014invul"
    "nerable\030\002 \001(\010\022\021\n\tis_flying\030\003 \001(\010\022\024\n\014allo"
    "w_flying\030\004 \001(\010\022\025\n\rcreative_mode\030\005 \001(\010\022\022\n"
    "\nwalk_speed\030\007 \001(\002\022\021\n\tfly_speed\030\010 \001(\002\"}\n\013"
    "UnloadChunk\0221\n\tplayer_id\030\001 \001(\0132\036.minecpp"
    ".proto.player.PlayerId\022;\n\016chunk_position"
    "\030\002 \001(\0132#.minecpp.proto.common.ChunkPosit"
    "ion\"8\n\nPlayerList\022*\n\004list\030\001 \003(\0132\034.minecp"
    "p.proto.player.Status\"y\n\nEntityList\022.\n\010e"
    "ntities\030\001 \003(\0132\034.minecpp.proto.entity.Ent"
    "ity\022;\n\017player_entities\030\002 \003(\0132\".minecpp.p"
    "roto.entity.PlayerEntity\"X\n\021SetEntityVel"
    "ocity\022\021\n\tentity_id\030\001 \001(\r\0220\n\010velocity\030\002 \001"
    "(\0132\036.minecpp.proto.common.Vector3i\"\242\001\n\014A"
    "cceptPlayer\0220\n\010gameplay\030\001 \001(\0132\036.minecpp."
    "proto.common.Gameplay\0222\n\tabilities\030\002 \001(\013"
    "2\037.minecpp.proto.entity.Abilities\022,\n\006pla"
    "yer\030\003 \001(\0132\034.minecpp.proto.player.Player\""
    "#\n\nDenyPlayer\022\025\n\rdenial_reason\030\001 \001(\t\"M\n\020"
    "SetInventorySlot\022\017\n\007slot_id\030\001 \001(\r\022(\n\004slo"
    "t\030\002 \001(\0132\032.minecpp.proto.common.Slot\"3\n\021S"
    "ectionBlockLight\022\t\n\001y\030\001 \001(\005\022\023\n\013block_lig"
    "ht\030\002 \001(\014\"\216\001\n\017ChunkBlockLight\0225\n\010position"
    "\030\001 \001(\0132#.minecpp.proto.common.ChunkPosit"
    "ion\022D\n\010sections\030\002 \003(\01322.minecpp.proto.ev"
    "ent.clientbound.SectionBlockLight\"Y\n\020Upd"
    "ateBlockLight\022E\n\013block_light\030\001 \003(\01320.min"
    "ecpp.proto.event.clientbound.ChunkBlockL"
    "ight\"P\n\tChunkData\022)\n\005chunk\030\001 \001(\0132\032.minec"
    "pp.proto.chunk.Chunk\022\030\n\020is_initial_chunk"
    "\030\002 \001(\010\"G\n\016SetCenterChunk\0225\n\010position\030\001 \001"
    "(\0132#.minecpp.proto.common.ChunkPosition\""
    "\216\001\n\022SetEntityEquipment\022\021\n\tentity_id\030\001 \001("
    "\r\022;\n\016equipment_slot\030\002 \001(\0162#.minecpp.prot"
    "o.entity.EquipmentSlot\022(\n\004item\030\003 \001(\0132\032.m"
    "inecpp.proto.common.Slot\"B\n\tSetHealth\022\016\n"
    "\006health\030\001 \001(\002\022\014\n\004food\030\002 \001(\005\022\027\n\017food_satu"
    "ration\030\003 \001(\002\"V\n\013CollectItem\022\033\n\023collected"
    "_entity_id\030\001 \001(\r\022\033\n\023collector_entity_id\030"
    "\002 \001(\r\022\r\n\005count\030\003 \001(\r\"!\n\014RemoveEntity\022\021\n\t"
    "entity_id\030\001 \001(\r\"\234\001\n\016TeleportEntity\022\021\n\ten"
    "tity_id\030\001 \001(\r\022/\n\010position\030\002 \001(\0132\035.minecp"
    "p.proto.common.Vector3\0220\n\010rotation\030\003 \001(\013"
    "2\036.minecpp.proto.common.Rotation\022\024\n\014is_o"
    "n_ground\030\004 \001(\010\"_\n\022DisplayDeathScreen\022\030\n\020"
    "victim_entity_id\030\001 \001(\r\022\030\n\020killer_entity_"
    "id\030\002 \001(\r\022\025\n\rdeath_message\030\003 \001(\t\"\343\002\n\007Resp"
    "awn\022\026\n\016dimension_type\030\001 \001(\t\022\026\n\016dimension"
    "_name\030\002 \001(\t\022\023\n\013hashed_seed\030\003 \001(\003\0221\n\tgame"
    "_mode\030\004 \001(\0162\036.minecpp.proto.common.GameM"
    "ode\022:\n\022previous_game_mode\030\005 \001(\0162\036.minecp"
    "p.proto.common.GameMode\022\020\n\010is_debug\030\006 \001("
    "\010\022\017\n\007is_flat\030\007 \001(\010\022\025\n\rcopy_metadata\030\010 \001("
    "\010\022\032\n\022has_death_location\030\t \001(\010\022\027\n\017death_d"
    "imension\030\n \001(\t\0225\n\016death_position\030\013 \001(\0132\035"
    ".minecpp.proto.common.Vector3\"B\n\014SetAbil"
    "ities\0222\n\tabilities\030\001 \001(\0132\037.minecpp.proto"
    ".entity.Abilitiesb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_deps[7] =
    {
        &::descriptor_table_google_2fprotobuf_2fany_2eproto,
        &::descriptor_table_minecpp_2fproto_2fchunk_2fChunk_2eproto,
        &::descriptor_table_minecpp_2fproto_2fcommon_2fCommon_2eproto,
        &::descriptor_table_minecpp_2fproto_2fcommon_2fVector_2eproto,
        &::descriptor_table_minecpp_2fproto_2fentity_2fEntity_2eproto,
        &::descriptor_table_minecpp_2fproto_2fplayer_2fId_2eproto,
        &::descriptor_table_minecpp_2fproto_2fplayer_2fPlayer_2eproto,
};
static ::absl::once_flag descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto = {
    false,
    false,
    4585,
    descriptor_table_protodef_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto,
    "minecpp/proto/event/clientbound/Clientbound.proto",
    &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
    descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_deps,
    7,
    40,
    schemas,
    file_default_instances,
    TableStruct_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto::offsets,
    file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto,
    file_level_enum_descriptors_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto,
    file_level_service_descriptors_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter() {
  return &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto(&descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto);
namespace minecpp {
namespace proto {
namespace event {
namespace clientbound {
// ===================================================================

class Event::_Internal {
 public:
  using HasBits = decltype(std::declval<Event>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Event, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::minecpp::proto::event::clientbound::Event, _impl_._oneof_case_);
  static const ::PROTOBUF_NAMESPACE_ID::Any& payload(const Event* msg);
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::event::clientbound::RecipientSinglePlayer& single_player(const Event* msg);
  static const ::minecpp::proto::event::clientbound::RecipientMultiplePlayers& multiple_players(const Event* msg);
  static const ::minecpp::proto::event::clientbound::RecipientAllPlayers& all_players(const Event* msg);
  static const ::minecpp::proto::event::clientbound::RecipientExcluding& excluding(const Event* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Any&
Event::_Internal::payload(const Event* msg) {
  return *msg->_impl_.payload_;
}
const ::minecpp::proto::event::clientbound::RecipientSinglePlayer&
Event::_Internal::single_player(const Event* msg) {
  return *msg->_impl_.recipient_.single_player_;
}
const ::minecpp::proto::event::clientbound::RecipientMultiplePlayers&
Event::_Internal::multiple_players(const Event* msg) {
  return *msg->_impl_.recipient_.multiple_players_;
}
const ::minecpp::proto::event::clientbound::RecipientAllPlayers&
Event::_Internal::all_players(const Event* msg) {
  return *msg->_impl_.recipient_.all_players_;
}
const ::minecpp::proto::event::clientbound::RecipientExcluding&
Event::_Internal::excluding(const Event* msg) {
  return *msg->_impl_.recipient_.excluding_;
}
void Event::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void Event::set_allocated_single_player(::minecpp::proto::event::clientbound::RecipientSinglePlayer* single_player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_recipient();
  if (single_player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(single_player);
    if (message_arena != submessage_arena) {
      single_player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, single_player, submessage_arena);
    }
    set_has_single_player();
    _impl_.recipient_.single_player_ = single_player;
  }
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.Event.single_player)
}
void Event::set_allocated_multiple_players(::minecpp::proto::event::clientbound::RecipientMultiplePlayers* multiple_players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_recipient();
  if (multiple_players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multiple_players);
    if (message_arena != submessage_arena) {
      multiple_players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiple_players, submessage_arena);
    }
    set_has_multiple_players();
    _impl_.recipient_.multiple_players_ = multiple_players;
  }
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.Event.multiple_players)
}
void Event::set_allocated_all_players(::minecpp::proto::event::clientbound::RecipientAllPlayers* all_players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_recipient();
  if (all_players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(all_players);
    if (message_arena != submessage_arena) {
      all_players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_players, submessage_arena);
    }
    set_has_all_players();
    _impl_.recipient_.all_players_ = all_players;
  }
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.Event.all_players)
}
void Event::set_allocated_excluding(::minecpp::proto::event::clientbound::RecipientExcluding* excluding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_recipient();
  if (excluding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(excluding);
    if (message_arena != submessage_arena) {
      excluding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, excluding, submessage_arena);
    }
    set_has_excluding();
    _impl_.recipient_.excluding_ = excluding;
  }
  // @@protoc_insertion_point(field_set_allocated:minecpp.proto.event.clientbound.Event.excluding)
}
Event::Event(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Event* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){nullptr}
    , decltype(_impl_.recipient_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.payload_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.payload_);
  }
  clear_has_recipient();
  switch (from.recipient_case()) {
    case kSinglePlayer: {
      _this->_internal_mutable_single_player()->::minecpp::proto::event::clientbound::RecipientSinglePlayer::MergeFrom(
          from._internal_single_player());
      break;
    }
    case kMultiplePlayers: {
      _this->_internal_mutable_multiple_players()->::minecpp::proto::event::clientbound::RecipientMultiplePlayers::MergeFrom(
          from._internal_multiple_players());
      break;
    }
    case kAllPlayers: {
      _this->_internal_mutable_all_players()->::minecpp::proto::event::clientbound::RecipientAllPlayers::MergeFrom(
          from._internal_all_players());
      break;
    }
    case kExcluding: {
      _this->_internal_mutable_excluding()->::minecpp::proto::event::clientbound::RecipientExcluding::MergeFrom(
          from._internal_excluding());
      break;
    }
    case RECIPIENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.Event)
}

inline void Event::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.payload_){nullptr}
    , decltype(_impl_.recipient_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_recipient();
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.Event)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Event::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.payload_;
  if (has_recipient()) {
    clear_recipient();
  }
}

void Event::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Event::clear_recipient() {
// @@protoc_insertion_point(one_of_clear_start:minecpp.proto.event.clientbound.Event)
  switch (recipient_case()) {
    case kSinglePlayer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.recipient_.single_player_;
      }
      break;
    }
    case kMultiplePlayers: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.recipient_.multiple_players_;
      }
      break;
    }
    case kAllPlayers: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.recipient_.all_players_;
      }
      break;
    }
    case kExcluding: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.recipient_.excluding_;
      }
      break;
    }
    case RECIPIENT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RECIPIENT_NOT_SET;
}


void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.Event)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.payload_ != nullptr);
    _impl_.payload_->Clear();
  }
  clear_recipient();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Event::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Any payload = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_payload(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.event.clientbound.RecipientSinglePlayer single_player = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_single_player(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.event.clientbound.RecipientMultiplePlayers multiple_players = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiple_players(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.event.clientbound.RecipientAllPlayers all_players = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_all_players(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.event.clientbound.RecipientExcluding excluding = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_excluding(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Event::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.Event)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Any payload = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::payload(this),
        _Internal::payload(this).GetCachedSize(), target, stream);
  }

  switch (recipient_case()) {
    case kSinglePlayer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::single_player(this),
          _Internal::single_player(this).GetCachedSize(), target, stream);
      break;
    }
    case kMultiplePlayers: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::multiple_players(this),
          _Internal::multiple_players(this).GetCachedSize(), target, stream);
      break;
    }
    case kAllPlayers: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::all_players(this),
          _Internal::all_players(this).GetCachedSize(), target, stream);
      break;
    }
    case kExcluding: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::excluding(this),
          _Internal::excluding(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.Event)
  return target;
}

::size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.Event)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .google.protobuf.Any payload = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.payload_);
  }

  switch (recipient_case()) {
    // .minecpp.proto.event.clientbound.RecipientSinglePlayer single_player = 2;
    case kSinglePlayer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recipient_.single_player_);
      break;
    }
    // .minecpp.proto.event.clientbound.RecipientMultiplePlayers multiple_players = 3;
    case kMultiplePlayers: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recipient_.multiple_players_);
      break;
    }
    // .minecpp.proto.event.clientbound.RecipientAllPlayers all_players = 4;
    case kAllPlayers: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recipient_.all_players_);
      break;
    }
    // .minecpp.proto.event.clientbound.RecipientExcluding excluding = 5;
    case kExcluding: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recipient_.excluding_);
      break;
    }
    case RECIPIENT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Event::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Event::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Event::GetClassData() const { return &_class_data_; }


void Event::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Event*>(&to_msg);
  auto& from = static_cast<const Event&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.Event)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_payload()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
        from._internal_payload());
  }
  switch (from.recipient_case()) {
    case kSinglePlayer: {
      _this->_internal_mutable_single_player()->::minecpp::proto::event::clientbound::RecipientSinglePlayer::MergeFrom(
          from._internal_single_player());
      break;
    }
    case kMultiplePlayers: {
      _this->_internal_mutable_multiple_players()->::minecpp::proto::event::clientbound::RecipientMultiplePlayers::MergeFrom(
          from._internal_multiple_players());
      break;
    }
    case kAllPlayers: {
      _this->_internal_mutable_all_players()->::minecpp::proto::event::clientbound::RecipientAllPlayers::MergeFrom(
          from._internal_all_players());
      break;
    }
    case kExcluding: {
      _this->_internal_mutable_excluding()->::minecpp::proto::event::clientbound::RecipientExcluding::MergeFrom(
          from._internal_excluding());
      break;
    }
    case RECIPIENT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_.recipient_, other->_impl_.recipient_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[0]);
}
// ===================================================================

class RecipientSinglePlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<RecipientSinglePlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RecipientSinglePlayer, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const RecipientSinglePlayer* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::player::PlayerId&
RecipientSinglePlayer::_Internal::player_id(const RecipientSinglePlayer* msg) {
  return *msg->_impl_.player_id_;
}
void RecipientSinglePlayer::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RecipientSinglePlayer::RecipientSinglePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.RecipientSinglePlayer)
}
RecipientSinglePlayer::RecipientSinglePlayer(const RecipientSinglePlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecipientSinglePlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.RecipientSinglePlayer)
}

inline void RecipientSinglePlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
  };
}

RecipientSinglePlayer::~RecipientSinglePlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecipientSinglePlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
}

void RecipientSinglePlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecipientSinglePlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.player_id_ != nullptr);
    _impl_.player_id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecipientSinglePlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RecipientSinglePlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  return target;
}

::size_t RecipientSinglePlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.player.PlayerId player_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecipientSinglePlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecipientSinglePlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecipientSinglePlayer::GetClassData() const { return &_class_data_; }


void RecipientSinglePlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecipientSinglePlayer*>(&to_msg);
  auto& from = static_cast<const RecipientSinglePlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
        from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecipientSinglePlayer::CopyFrom(const RecipientSinglePlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.RecipientSinglePlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecipientSinglePlayer::IsInitialized() const {
  return true;
}

void RecipientSinglePlayer::InternalSwap(RecipientSinglePlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RecipientSinglePlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[1]);
}
// ===================================================================

class RecipientMultiplePlayers::_Internal {
 public:
};

void RecipientMultiplePlayers::clear_player_ids() {
  _internal_mutable_player_ids()->Clear();
}
RecipientMultiplePlayers::RecipientMultiplePlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
}
RecipientMultiplePlayers::RecipientMultiplePlayers(const RecipientMultiplePlayers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecipientMultiplePlayers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_ids_){from._impl_.player_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
}

inline void RecipientMultiplePlayers::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.player_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecipientMultiplePlayers::~RecipientMultiplePlayers() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecipientMultiplePlayers::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_player_ids()->~RepeatedPtrField();
}

void RecipientMultiplePlayers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecipientMultiplePlayers::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_player_ids()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecipientMultiplePlayers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .minecpp.proto.player.PlayerId player_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RecipientMultiplePlayers::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .minecpp.proto.player.PlayerId player_ids = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  return target;
}

::size_t RecipientMultiplePlayers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .minecpp.proto.player.PlayerId player_ids = 1;
  total_size += 1UL * this->_internal_player_ids_size();
  for (const auto& msg : this->_internal_player_ids()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecipientMultiplePlayers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecipientMultiplePlayers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecipientMultiplePlayers::GetClassData() const { return &_class_data_; }


void RecipientMultiplePlayers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecipientMultiplePlayers*>(&to_msg);
  auto& from = static_cast<const RecipientMultiplePlayers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_player_ids()->MergeFrom(from._internal_player_ids());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecipientMultiplePlayers::CopyFrom(const RecipientMultiplePlayers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.RecipientMultiplePlayers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecipientMultiplePlayers::IsInitialized() const {
  return true;
}

void RecipientMultiplePlayers::InternalSwap(RecipientMultiplePlayers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_player_ids()->InternalSwap(other->_internal_mutable_player_ids());
}

::PROTOBUF_NAMESPACE_ID::Metadata RecipientMultiplePlayers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[2]);
}
// ===================================================================

class RecipientAllPlayers::_Internal {
 public:
};

RecipientAllPlayers::RecipientAllPlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena) {
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.RecipientAllPlayers)
}
RecipientAllPlayers::RecipientAllPlayers(const RecipientAllPlayers& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  RecipientAllPlayers* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.RecipientAllPlayers)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecipientAllPlayers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecipientAllPlayers::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RecipientAllPlayers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[3]);
}
// ===================================================================

class RecipientExcluding::_Internal {
 public:
  using HasBits = decltype(std::declval<RecipientExcluding>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RecipientExcluding, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const RecipientExcluding* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::player::PlayerId&
RecipientExcluding::_Internal::player_id(const RecipientExcluding* msg) {
  return *msg->_impl_.player_id_;
}
void RecipientExcluding::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RecipientExcluding::RecipientExcluding(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.RecipientExcluding)
}
RecipientExcluding::RecipientExcluding(const RecipientExcluding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RecipientExcluding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.RecipientExcluding)
}

inline void RecipientExcluding::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
  };
}

RecipientExcluding::~RecipientExcluding() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.RecipientExcluding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecipientExcluding::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
}

void RecipientExcluding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecipientExcluding::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.RecipientExcluding)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.player_id_ != nullptr);
    _impl_.player_id_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RecipientExcluding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RecipientExcluding::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.RecipientExcluding)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.RecipientExcluding)
  return target;
}

::size_t RecipientExcluding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.RecipientExcluding)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.player.PlayerId player_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RecipientExcluding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RecipientExcluding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RecipientExcluding::GetClassData() const { return &_class_data_; }


void RecipientExcluding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RecipientExcluding*>(&to_msg);
  auto& from = static_cast<const RecipientExcluding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.RecipientExcluding)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
        from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RecipientExcluding::CopyFrom(const RecipientExcluding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.RecipientExcluding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecipientExcluding::IsInitialized() const {
  return true;
}

void RecipientExcluding::InternalSwap(RecipientExcluding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.player_id_, other->_impl_.player_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RecipientExcluding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[4]);
}
// ===================================================================

class AddPlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<AddPlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AddPlayer, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const AddPlayer* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::player::PlayerId&
AddPlayer::_Internal::player_id(const AddPlayer* msg) {
  return *msg->_impl_.player_id_;
}
void AddPlayer::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AddPlayer::AddPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.AddPlayer)
}
AddPlayer::AddPlayer(const AddPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.game_mode_) {}

    , decltype(_impl_.ping_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  ::memcpy(&_impl_.game_mode_, &from._impl_.game_mode_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ping_) -
    reinterpret_cast<char*>(&_impl_.game_mode_)) + sizeof(_impl_.ping_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.AddPlayer)
}

inline void AddPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_) {}

    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.game_mode_) { 0 }

    , decltype(_impl_.ping_) { 0u }

  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddPlayer::~AddPlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.AddPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.player_id_;
}

void AddPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.AddPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.player_id_ != nullptr);
    _impl_.player_id_->Clear();
  }
  ::memset(&_impl_.game_mode_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ping_) -
      reinterpret_cast<char*>(&_impl_.game_mode_)) + sizeof(_impl_.ping_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.AddPlayer.name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.GameMode game_mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_game_mode(static_cast<::minecpp::proto::common::GameMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 ping = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AddPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.AddPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.AddPlayer.name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // .minecpp.proto.common.GameMode game_mode = 3;
  if (this->_internal_game_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_game_mode(), target);
  }

  // uint32 ping = 4;
  if (this->_internal_ping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_ping(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.AddPlayer)
  return target;
}

::size_t AddPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.AddPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // .minecpp.proto.player.PlayerId player_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_id_);
  }

  // .minecpp.proto.common.GameMode game_mode = 3;
  if (this->_internal_game_mode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode());
  }

  // uint32 ping = 4;
  if (this->_internal_ping() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ping());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddPlayer::GetClassData() const { return &_class_data_; }


void AddPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddPlayer*>(&to_msg);
  auto& from = static_cast<const AddPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.AddPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
        from._internal_player_id());
  }
  if (from._internal_game_mode() != 0) {
    _this->_internal_set_game_mode(from._internal_game_mode());
  }
  if (from._internal_ping() != 0) {
    _this->_internal_set_ping(from._internal_ping());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddPlayer::CopyFrom(const AddPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.AddPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddPlayer::IsInitialized() const {
  return true;
}

void AddPlayer::InternalSwap(AddPlayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena,
                                       &other->_impl_.name_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddPlayer, _impl_.ping_)
      + sizeof(AddPlayer::_impl_.ping_)
      - PROTOBUF_FIELD_OFFSET(AddPlayer, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[5]);
}
// ===================================================================

class SpawnEntity::_Internal {
 public:
  using HasBits = decltype(std::declval<SpawnEntity>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpawnEntity, _impl_._has_bits_);
  static const ::minecpp::proto::entity::Entity& entity(const SpawnEntity* msg);
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::entity::Entity&
SpawnEntity::_Internal::entity(const SpawnEntity* msg) {
  return *msg->_impl_.entity_;
}
void SpawnEntity::clear_entity() {
  if (_impl_.entity_ != nullptr) _impl_.entity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SpawnEntity::SpawnEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SpawnEntity)
}
SpawnEntity::SpawnEntity(const SpawnEntity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpawnEntity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.entity_ = new ::minecpp::proto::entity::Entity(*from._impl_.entity_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SpawnEntity)
}

inline void SpawnEntity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_){nullptr}
  };
}

SpawnEntity::~SpawnEntity() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SpawnEntity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpawnEntity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.entity_;
}

void SpawnEntity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpawnEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SpawnEntity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.entity_ != nullptr);
    _impl_.entity_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpawnEntity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.entity.Entity entity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_entity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpawnEntity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SpawnEntity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.entity.Entity entity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::entity(this),
        _Internal::entity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SpawnEntity)
  return target;
}

::size_t SpawnEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SpawnEntity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.entity.Entity entity = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.entity_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpawnEntity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpawnEntity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpawnEntity::GetClassData() const { return &_class_data_; }


void SpawnEntity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpawnEntity*>(&to_msg);
  auto& from = static_cast<const SpawnEntity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SpawnEntity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_entity()->::minecpp::proto::entity::Entity::MergeFrom(
        from._internal_entity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpawnEntity::CopyFrom(const SpawnEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SpawnEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpawnEntity::IsInitialized() const {
  return true;
}

void SpawnEntity::InternalSwap(SpawnEntity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.entity_, other->_impl_.entity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpawnEntity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[6]);
}
// ===================================================================

class SpawnPlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<SpawnPlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SpawnPlayer, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const SpawnPlayer* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::entity::PlayerEntity& entity(const SpawnPlayer* msg);
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::minecpp::proto::player::PlayerId&
SpawnPlayer::_Internal::player_id(const SpawnPlayer* msg) {
  return *msg->_impl_.player_id_;
}
const ::minecpp::proto::entity::PlayerEntity&
SpawnPlayer::_Internal::entity(const SpawnPlayer* msg) {
  return *msg->_impl_.entity_;
}
void SpawnPlayer::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SpawnPlayer::clear_entity() {
  if (_impl_.entity_ != nullptr) _impl_.entity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
SpawnPlayer::SpawnPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SpawnPlayer)
}
SpawnPlayer::SpawnPlayer(const SpawnPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpawnPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.entity_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.entity_ = new ::minecpp::proto::entity::PlayerEntity(*from._impl_.entity_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SpawnPlayer)
}

inline void SpawnPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.entity_){nullptr}
  };
}

SpawnPlayer::~SpawnPlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SpawnPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpawnPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
  if (this != internal_default_instance()) delete _impl_.entity_;
}

void SpawnPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpawnPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SpawnPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.player_id_ != nullptr);
      _impl_.player_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.entity_ != nullptr);
      _impl_.entity_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpawnPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.entity.PlayerEntity entity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_entity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SpawnPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SpawnPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.entity.PlayerEntity entity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::entity(this),
        _Internal::entity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SpawnPlayer)
  return target;
}

::size_t SpawnPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SpawnPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .minecpp.proto.player.PlayerId player_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_id_);
    }

    // .minecpp.proto.entity.PlayerEntity entity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.entity_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpawnPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpawnPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpawnPlayer::GetClassData() const { return &_class_data_; }


void SpawnPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpawnPlayer*>(&to_msg);
  auto& from = static_cast<const SpawnPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SpawnPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
          from._internal_player_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_entity()->::minecpp::proto::entity::PlayerEntity::MergeFrom(
          from._internal_entity());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpawnPlayer::CopyFrom(const SpawnPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SpawnPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpawnPlayer::IsInitialized() const {
  return true;
}

void SpawnPlayer::InternalSwap(SpawnPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpawnPlayer, _impl_.entity_)
      + sizeof(SpawnPlayer::_impl_.entity_)
      - PROTOBUF_FIELD_OFFSET(SpawnPlayer, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpawnPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[7]);
}
// ===================================================================

class EntityMove::_Internal {
 public:
  using HasBits = decltype(std::declval<EntityMove>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EntityMove, _impl_._has_bits_);
  static const ::minecpp::proto::common::Vector3i& movement(const EntityMove* msg);
  static void set_has_movement(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::common::Rotation& rotation(const EntityMove* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::minecpp::proto::common::Vector3i&
EntityMove::_Internal::movement(const EntityMove* msg) {
  return *msg->_impl_.movement_;
}
const ::minecpp::proto::common::Rotation&
EntityMove::_Internal::rotation(const EntityMove* msg) {
  return *msg->_impl_.rotation_;
}
void EntityMove::clear_movement() {
  if (_impl_.movement_ != nullptr) _impl_.movement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EntityMove::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
EntityMove::EntityMove(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.EntityMove)
}
EntityMove::EntityMove(const EntityMove& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EntityMove* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movement_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.entity_id_) {}

    , decltype(_impl_.is_on_ground_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.movement_ = new ::minecpp::proto::common::Vector3i(*from._impl_.movement_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.rotation_ = new ::minecpp::proto::common::Rotation(*from._impl_.rotation_);
  }
  ::memcpy(&_impl_.entity_id_, &from._impl_.entity_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_on_ground_) -
    reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.is_on_ground_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.EntityMove)
}

inline void EntityMove::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movement_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.entity_id_) { 0u }

    , decltype(_impl_.is_on_ground_) { false }

  };
}

EntityMove::~EntityMove() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.EntityMove)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EntityMove::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.movement_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void EntityMove::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EntityMove::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.EntityMove)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.movement_ != nullptr);
      _impl_.movement_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  ::memset(&_impl_.entity_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_on_ground_) -
      reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.is_on_ground_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EntityMove::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Vector3i movement = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_movement(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Rotation rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_on_ground = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.is_on_ground_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EntityMove::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.EntityMove)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_entity_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Vector3i movement = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::movement(this),
        _Internal::movement(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.common.Rotation rotation = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // bool is_on_ground = 4;
  if (this->_internal_is_on_ground() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is_on_ground(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.EntityMove)
  return target;
}

::size_t EntityMove::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.EntityMove)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .minecpp.proto.common.Vector3i movement = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.movement_);
    }

    // .minecpp.proto.common.Rotation rotation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

  }
  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  // bool is_on_ground = 4;
  if (this->_internal_is_on_ground() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntityMove::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EntityMove::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntityMove::GetClassData() const { return &_class_data_; }


void EntityMove::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EntityMove*>(&to_msg);
  auto& from = static_cast<const EntityMove&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.EntityMove)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_movement()->::minecpp::proto::common::Vector3i::MergeFrom(
          from._internal_movement());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rotation()->::minecpp::proto::common::Rotation::MergeFrom(
          from._internal_rotation());
    }
  }
  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  if (from._internal_is_on_ground() != 0) {
    _this->_internal_set_is_on_ground(from._internal_is_on_ground());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EntityMove::CopyFrom(const EntityMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.EntityMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntityMove::IsInitialized() const {
  return true;
}

void EntityMove::InternalSwap(EntityMove* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EntityMove, _impl_.is_on_ground_)
      + sizeof(EntityMove::_impl_.is_on_ground_)
      - PROTOBUF_FIELD_OFFSET(EntityMove, _impl_.movement_)>(
          reinterpret_cast<char*>(&_impl_.movement_),
          reinterpret_cast<char*>(&other->_impl_.movement_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EntityMove::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[8]);
}
// ===================================================================

class EntityLook::_Internal {
 public:
  using HasBits = decltype(std::declval<EntityLook>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EntityLook, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const EntityLook* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::common::Rotation& rotation(const EntityLook* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::minecpp::proto::player::PlayerId&
EntityLook::_Internal::player_id(const EntityLook* msg) {
  return *msg->_impl_.player_id_;
}
const ::minecpp::proto::common::Rotation&
EntityLook::_Internal::rotation(const EntityLook* msg) {
  return *msg->_impl_.rotation_;
}
void EntityLook::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EntityLook::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
EntityLook::EntityLook(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.EntityLook)
}
EntityLook::EntityLook(const EntityLook& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EntityLook* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.entity_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.rotation_ = new ::minecpp::proto::common::Rotation(*from._impl_.rotation_);
  }
  _this->_impl_.entity_id_ = from._impl_.entity_id_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.EntityLook)
}

inline void EntityLook::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.entity_id_) { 0u }

  };
}

EntityLook::~EntityLook() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.EntityLook)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EntityLook::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void EntityLook::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EntityLook::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.EntityLook)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.player_id_ != nullptr);
      _impl_.player_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  _impl_.entity_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EntityLook::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 entity_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Rotation rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EntityLook::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.EntityLook)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  // uint32 entity_id = 2;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_entity_id(), target);
  }

  // .minecpp.proto.common.Rotation rotation = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.EntityLook)
  return target;
}

::size_t EntityLook::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.EntityLook)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .minecpp.proto.player.PlayerId player_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_id_);
    }

    // .minecpp.proto.common.Rotation rotation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

  }
  // uint32 entity_id = 2;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntityLook::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EntityLook::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntityLook::GetClassData() const { return &_class_data_; }


void EntityLook::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EntityLook*>(&to_msg);
  auto& from = static_cast<const EntityLook&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.EntityLook)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
          from._internal_player_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rotation()->::minecpp::proto::common::Rotation::MergeFrom(
          from._internal_rotation());
    }
  }
  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EntityLook::CopyFrom(const EntityLook& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.EntityLook)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntityLook::IsInitialized() const {
  return true;
}

void EntityLook::InternalSwap(EntityLook* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EntityLook, _impl_.entity_id_)
      + sizeof(EntityLook::_impl_.entity_id_)
      - PROTOBUF_FIELD_OFFSET(EntityLook, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EntityLook::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[9]);
}
// ===================================================================

class PlayerPositionRotation::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerPositionRotation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PlayerPositionRotation, _impl_._has_bits_);
  static const ::minecpp::proto::common::Vector3& position(const PlayerPositionRotation* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::common::Rotation& rotation(const PlayerPositionRotation* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::minecpp::proto::common::Vector3&
PlayerPositionRotation::_Internal::position(const PlayerPositionRotation* msg) {
  return *msg->_impl_.position_;
}
const ::minecpp::proto::common::Rotation&
PlayerPositionRotation::_Internal::rotation(const PlayerPositionRotation* msg) {
  return *msg->_impl_.rotation_;
}
void PlayerPositionRotation::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PlayerPositionRotation::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PlayerPositionRotation::PlayerPositionRotation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.PlayerPositionRotation)
}
PlayerPositionRotation::PlayerPositionRotation(const PlayerPositionRotation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerPositionRotation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::minecpp::proto::common::Vector3(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.rotation_ = new ::minecpp::proto::common::Rotation(*from._impl_.rotation_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.PlayerPositionRotation)
}

inline void PlayerPositionRotation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
  };
}

PlayerPositionRotation::~PlayerPositionRotation() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.PlayerPositionRotation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerPositionRotation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void PlayerPositionRotation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerPositionRotation::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.PlayerPositionRotation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerPositionRotation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.common.Vector3 position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Rotation rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlayerPositionRotation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.PlayerPositionRotation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Vector3 position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.common.Rotation rotation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.PlayerPositionRotation)
  return target;
}

::size_t PlayerPositionRotation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.PlayerPositionRotation)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .minecpp.proto.common.Vector3 position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .minecpp.proto.common.Rotation rotation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerPositionRotation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerPositionRotation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerPositionRotation::GetClassData() const { return &_class_data_; }


void PlayerPositionRotation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerPositionRotation*>(&to_msg);
  auto& from = static_cast<const PlayerPositionRotation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.PlayerPositionRotation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::minecpp::proto::common::Vector3::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rotation()->::minecpp::proto::common::Rotation::MergeFrom(
          from._internal_rotation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerPositionRotation::CopyFrom(const PlayerPositionRotation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.PlayerPositionRotation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerPositionRotation::IsInitialized() const {
  return true;
}

void PlayerPositionRotation::InternalSwap(PlayerPositionRotation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerPositionRotation, _impl_.rotation_)
      + sizeof(PlayerPositionRotation::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(PlayerPositionRotation, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerPositionRotation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[10]);
}
// ===================================================================

class SetSpawnPosition::_Internal {
 public:
};

SetSpawnPosition::SetSpawnPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetSpawnPosition)
}
SetSpawnPosition::SetSpawnPosition(const SetSpawnPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetSpawnPosition)
}

inline void SetSpawnPosition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.position_) { ::uint64_t{0u} }

    , decltype(_impl_.angle_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetSpawnPosition::~SetSpawnPosition() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetSpawnPosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetSpawnPosition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetSpawnPosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetSpawnPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetSpawnPosition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.position_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.angle_) -
      reinterpret_cast<char*>(&_impl_.position_)) + sizeof(_impl_.angle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetSpawnPosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetSpawnPosition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetSpawnPosition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 position = 1;
  if (this->_internal_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_position(), target);
  }

  // float angle = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetSpawnPosition)
  return target;
}

::size_t SetSpawnPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetSpawnPosition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 position = 1;
  if (this->_internal_position() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_position());
  }

  // float angle = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = this->_internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetSpawnPosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetSpawnPosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetSpawnPosition::GetClassData() const { return &_class_data_; }


void SetSpawnPosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetSpawnPosition*>(&to_msg);
  auto& from = static_cast<const SetSpawnPosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetSpawnPosition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_position() != 0) {
    _this->_internal_set_position(from._internal_position());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_angle = from._internal_angle();
  ::uint32_t raw_angle;
  memcpy(&raw_angle, &tmp_angle, sizeof(tmp_angle));
  if (raw_angle != 0) {
    _this->_internal_set_angle(from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetSpawnPosition::CopyFrom(const SetSpawnPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetSpawnPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetSpawnPosition::IsInitialized() const {
  return true;
}

void SetSpawnPosition::InternalSwap(SetSpawnPosition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetSpawnPosition, _impl_.angle_)
      + sizeof(SetSpawnPosition::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(SetSpawnPosition, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetSpawnPosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[11]);
}
// ===================================================================

class Chat::_Internal {
 public:
};

Chat::Chat(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.Chat)
}
Chat::Chat(const Chat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Chat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , decltype(_impl_.type_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.Chat)
}

inline void Chat::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.message_) {}

    , decltype(_impl_.type_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Chat::~Chat() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.Chat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Chat::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void Chat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Chat::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.Chat)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Chat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.Chat.message"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Chat::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.Chat)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.Chat.message");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int32 type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.Chat)
  return target;
}

::size_t Chat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.Chat)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // int32 type = 2;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Chat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Chat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Chat::GetClassData() const { return &_class_data_; }


void Chat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Chat*>(&to_msg);
  auto& from = static_cast<const Chat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.Chat)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Chat::CopyFrom(const Chat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.Chat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Chat::IsInitialized() const {
  return true;
}

void Chat::InternalSwap(Chat* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena,
                                       &other->_impl_.message_, rhs_arena);

  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Chat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[12]);
}
// ===================================================================

class RemovePlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<RemovePlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RemovePlayer, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const RemovePlayer* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::player::PlayerId&
RemovePlayer::_Internal::player_id(const RemovePlayer* msg) {
  return *msg->_impl_.player_id_;
}
void RemovePlayer::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RemovePlayer::RemovePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.RemovePlayer)
}
RemovePlayer::RemovePlayer(const RemovePlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemovePlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.entity_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  _this->_impl_.entity_id_ = from._impl_.entity_id_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.RemovePlayer)
}

inline void RemovePlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.entity_id_) { 0u }

  };
}

RemovePlayer::~RemovePlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.RemovePlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemovePlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
}

void RemovePlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemovePlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.RemovePlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.player_id_ != nullptr);
    _impl_.player_id_->Clear();
  }
  _impl_.entity_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemovePlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 entity_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RemovePlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.RemovePlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  // uint32 entity_id = 2;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_entity_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.RemovePlayer)
  return target;
}

::size_t RemovePlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.RemovePlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.player.PlayerId player_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_id_);
  }

  // uint32 entity_id = 2;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemovePlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemovePlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemovePlayer::GetClassData() const { return &_class_data_; }


void RemovePlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemovePlayer*>(&to_msg);
  auto& from = static_cast<const RemovePlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.RemovePlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
        from._internal_player_id());
  }
  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemovePlayer::CopyFrom(const RemovePlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.RemovePlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemovePlayer::IsInitialized() const {
  return true;
}

void RemovePlayer::InternalSwap(RemovePlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemovePlayer, _impl_.entity_id_)
      + sizeof(RemovePlayer::_impl_.entity_id_)
      - PROTOBUF_FIELD_OFFSET(RemovePlayer, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemovePlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[13]);
}
// ===================================================================

class UpdateBlock::_Internal {
 public:
};

UpdateBlock::UpdateBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.UpdateBlock)
}
UpdateBlock::UpdateBlock(const UpdateBlock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.UpdateBlock)
}

inline void UpdateBlock::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.block_position_) { ::uint64_t{0u} }

    , decltype(_impl_.state_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateBlock::~UpdateBlock() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.UpdateBlock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateBlock::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpdateBlock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.UpdateBlock)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.block_position_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.state_) -
      reinterpret_cast<char*>(&_impl_.block_position_)) + sizeof(_impl_.state_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateBlock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 block_position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.block_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdateBlock::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.UpdateBlock)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 block_position = 1;
  if (this->_internal_block_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_block_position(), target);
  }

  // uint32 state = 2;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.UpdateBlock)
  return target;
}

::size_t UpdateBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.UpdateBlock)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 block_position = 1;
  if (this->_internal_block_position() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_block_position());
  }

  // uint32 state = 2;
  if (this->_internal_state() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateBlock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateBlock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateBlock::GetClassData() const { return &_class_data_; }


void UpdateBlock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateBlock*>(&to_msg);
  auto& from = static_cast<const UpdateBlock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.UpdateBlock)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_block_position() != 0) {
    _this->_internal_set_block_position(from._internal_block_position());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateBlock::CopyFrom(const UpdateBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.UpdateBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateBlock::IsInitialized() const {
  return true;
}

void UpdateBlock::InternalSwap(UpdateBlock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateBlock, _impl_.state_)
      + sizeof(UpdateBlock::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(UpdateBlock, _impl_.block_position_)>(
          reinterpret_cast<char*>(&_impl_.block_position_),
          reinterpret_cast<char*>(&other->_impl_.block_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateBlock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[14]);
}
// ===================================================================

class AnimateEntity::_Internal {
 public:
};

AnimateEntity::AnimateEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.AnimateEntity)
}
AnimateEntity::AnimateEntity(const AnimateEntity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.AnimateEntity)
}

inline void AnimateEntity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.entity_id_) { 0u }

    , decltype(_impl_.animation_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AnimateEntity::~AnimateEntity() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.AnimateEntity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnimateEntity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AnimateEntity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnimateEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.AnimateEntity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.entity_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.animation_) -
      reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.animation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnimateEntity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.EntityAnimation animation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_animation(static_cast<::minecpp::proto::common::EntityAnimation>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AnimateEntity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.AnimateEntity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_entity_id(), target);
  }

  // .minecpp.proto.common.EntityAnimation animation = 2;
  if (this->_internal_animation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_animation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.AnimateEntity)
  return target;
}

::size_t AnimateEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.AnimateEntity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  // .minecpp.proto.common.EntityAnimation animation = 2;
  if (this->_internal_animation() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_animation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnimateEntity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnimateEntity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnimateEntity::GetClassData() const { return &_class_data_; }


void AnimateEntity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnimateEntity*>(&to_msg);
  auto& from = static_cast<const AnimateEntity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.AnimateEntity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  if (from._internal_animation() != 0) {
    _this->_internal_set_animation(from._internal_animation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnimateEntity::CopyFrom(const AnimateEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.AnimateEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnimateEntity::IsInitialized() const {
  return true;
}

void AnimateEntity::InternalSwap(AnimateEntity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnimateEntity, _impl_.animation_)
      + sizeof(AnimateEntity::_impl_.animation_)
      - PROTOBUF_FIELD_OFFSET(AnimateEntity, _impl_.entity_id_)>(
          reinterpret_cast<char*>(&_impl_.entity_id_),
          reinterpret_cast<char*>(&other->_impl_.entity_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AnimateEntity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[15]);
}
// ===================================================================

class AcknowledgeBlockChange::_Internal {
 public:
};

AcknowledgeBlockChange::AcknowledgeBlockChange(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
}
AcknowledgeBlockChange::AcknowledgeBlockChange(const AcknowledgeBlockChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
}

inline void AcknowledgeBlockChange::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_id_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AcknowledgeBlockChange::~AcknowledgeBlockChange() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AcknowledgeBlockChange::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void AcknowledgeBlockChange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AcknowledgeBlockChange::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sequence_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcknowledgeBlockChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sequence_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.sequence_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AcknowledgeBlockChange::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sequence_id = 1;
  if (this->_internal_sequence_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_sequence_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  return target;
}

::size_t AcknowledgeBlockChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 sequence_id = 1;
  if (this->_internal_sequence_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_sequence_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AcknowledgeBlockChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AcknowledgeBlockChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AcknowledgeBlockChange::GetClassData() const { return &_class_data_; }


void AcknowledgeBlockChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AcknowledgeBlockChange*>(&to_msg);
  auto& from = static_cast<const AcknowledgeBlockChange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_sequence_id() != 0) {
    _this->_internal_set_sequence_id(from._internal_sequence_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AcknowledgeBlockChange::CopyFrom(const AcknowledgeBlockChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.AcknowledgeBlockChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcknowledgeBlockChange::IsInitialized() const {
  return true;
}

void AcknowledgeBlockChange::InternalSwap(AcknowledgeBlockChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.sequence_id_, other->_impl_.sequence_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AcknowledgeBlockChange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[16]);
}
// ===================================================================

class LoadTerrain::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadTerrain>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LoadTerrain, _impl_._has_bits_);
  static const ::minecpp::proto::common::ChunkPosition& central_chunk(const LoadTerrain* msg);
  static void set_has_central_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::ChunkPosition&
LoadTerrain::_Internal::central_chunk(const LoadTerrain* msg) {
  return *msg->_impl_.central_chunk_;
}
void LoadTerrain::clear_central_chunk() {
  if (_impl_.central_chunk_ != nullptr) _impl_.central_chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LoadTerrain::clear_coords() {
  _internal_mutable_coords()->Clear();
}
LoadTerrain::LoadTerrain(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.LoadTerrain)
}
LoadTerrain::LoadTerrain(const LoadTerrain& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadTerrain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coords_){from._impl_.coords_}
    , decltype(_impl_.central_chunk_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.central_chunk_ = new ::minecpp::proto::common::ChunkPosition(*from._impl_.central_chunk_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.LoadTerrain)
}

inline void LoadTerrain::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coords_){arena}
    , decltype(_impl_.central_chunk_){nullptr}
  };
}

LoadTerrain::~LoadTerrain() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.LoadTerrain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadTerrain::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_coords()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.central_chunk_;
}

void LoadTerrain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadTerrain::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.LoadTerrain)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_coords()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.central_chunk_ != nullptr);
    _impl_.central_chunk_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadTerrain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.common.ChunkPosition central_chunk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_central_chunk(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .minecpp.proto.common.ChunkPosition coords = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coords(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* LoadTerrain::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.LoadTerrain)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.ChunkPosition central_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::central_chunk(this),
        _Internal::central_chunk(this).GetCachedSize(), target, stream);
  }

  // repeated .minecpp.proto.common.ChunkPosition coords = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coords_size()); i < n; i++) {
    const auto& repfield = this->_internal_coords(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.LoadTerrain)
  return target;
}

::size_t LoadTerrain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.LoadTerrain)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .minecpp.proto.common.ChunkPosition coords = 2;
  total_size += 1UL * this->_internal_coords_size();
  for (const auto& msg : this->_internal_coords()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .minecpp.proto.common.ChunkPosition central_chunk = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.central_chunk_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadTerrain::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadTerrain::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadTerrain::GetClassData() const { return &_class_data_; }


void LoadTerrain::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadTerrain*>(&to_msg);
  auto& from = static_cast<const LoadTerrain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.LoadTerrain)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_coords()->MergeFrom(from._internal_coords());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_central_chunk()->::minecpp::proto::common::ChunkPosition::MergeFrom(
        from._internal_central_chunk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadTerrain::CopyFrom(const LoadTerrain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.LoadTerrain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadTerrain::IsInitialized() const {
  return true;
}

void LoadTerrain::InternalSwap(LoadTerrain* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_coords()->InternalSwap(other->_internal_mutable_coords());
  swap(_impl_.central_chunk_, other->_impl_.central_chunk_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadTerrain::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[17]);
}
// ===================================================================

class TransferPlayer::_Internal {
 public:
};

TransferPlayer::TransferPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.TransferPlayer)
}
TransferPlayer::TransferPlayer(const TransferPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.TransferPlayer)
}

inline void TransferPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.engine_instance_id_) { ::uint64_t{0u} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransferPlayer::~TransferPlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.TransferPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransferPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TransferPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransferPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.TransferPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.engine_instance_id_ = ::uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransferPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 engine_instance_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.engine_instance_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TransferPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.TransferPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 engine_instance_id = 2;
  if (this->_internal_engine_instance_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_engine_instance_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.TransferPlayer)
  return target;
}

::size_t TransferPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.TransferPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 engine_instance_id = 2;
  if (this->_internal_engine_instance_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_engine_instance_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransferPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransferPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransferPlayer::GetClassData() const { return &_class_data_; }


void TransferPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransferPlayer*>(&to_msg);
  auto& from = static_cast<const TransferPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.TransferPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_engine_instance_id() != 0) {
    _this->_internal_set_engine_instance_id(from._internal_engine_instance_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransferPlayer::CopyFrom(const TransferPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.TransferPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransferPlayer::IsInitialized() const {
  return true;
}

void TransferPlayer::InternalSwap(TransferPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.engine_instance_id_, other->_impl_.engine_instance_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransferPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[18]);
}
// ===================================================================

class UpdatePlayerAbilities::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdatePlayerAbilities>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UpdatePlayerAbilities, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const UpdatePlayerAbilities* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::player::PlayerId&
UpdatePlayerAbilities::_Internal::player_id(const UpdatePlayerAbilities* msg) {
  return *msg->_impl_.player_id_;
}
void UpdatePlayerAbilities::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
UpdatePlayerAbilities::UpdatePlayerAbilities(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
}
UpdatePlayerAbilities::UpdatePlayerAbilities(const UpdatePlayerAbilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdatePlayerAbilities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.invulnerable_) {}

    , decltype(_impl_.is_flying_) {}

    , decltype(_impl_.allow_flying_) {}

    , decltype(_impl_.creative_mode_) {}

    , decltype(_impl_.walk_speed_) {}

    , decltype(_impl_.fly_speed_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  ::memcpy(&_impl_.invulnerable_, &from._impl_.invulnerable_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.fly_speed_) -
    reinterpret_cast<char*>(&_impl_.invulnerable_)) + sizeof(_impl_.fly_speed_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
}

inline void UpdatePlayerAbilities::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.invulnerable_) { false }

    , decltype(_impl_.is_flying_) { false }

    , decltype(_impl_.allow_flying_) { false }

    , decltype(_impl_.creative_mode_) { false }

    , decltype(_impl_.walk_speed_) { 0 }

    , decltype(_impl_.fly_speed_) { 0 }

  };
}

UpdatePlayerAbilities::~UpdatePlayerAbilities() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdatePlayerAbilities::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
}

void UpdatePlayerAbilities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdatePlayerAbilities::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.player_id_ != nullptr);
    _impl_.player_id_->Clear();
  }
  ::memset(&_impl_.invulnerable_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.fly_speed_) -
      reinterpret_cast<char*>(&_impl_.invulnerable_)) + sizeof(_impl_.fly_speed_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdatePlayerAbilities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool invulnerable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.invulnerable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_flying = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.is_flying_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool allow_flying = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.allow_flying_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool creative_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.creative_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float walk_speed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _impl_.walk_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // float fly_speed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 69)) {
          _impl_.fly_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdatePlayerAbilities::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  // bool invulnerable = 2;
  if (this->_internal_invulnerable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_invulnerable(), target);
  }

  // bool is_flying = 3;
  if (this->_internal_is_flying() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_is_flying(), target);
  }

  // bool allow_flying = 4;
  if (this->_internal_allow_flying() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_allow_flying(), target);
  }

  // bool creative_mode = 5;
  if (this->_internal_creative_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_creative_mode(), target);
  }

  // float walk_speed = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_walk_speed = this->_internal_walk_speed();
  ::uint32_t raw_walk_speed;
  memcpy(&raw_walk_speed, &tmp_walk_speed, sizeof(tmp_walk_speed));
  if (raw_walk_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_walk_speed(), target);
  }

  // float fly_speed = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_fly_speed = this->_internal_fly_speed();
  ::uint32_t raw_fly_speed;
  memcpy(&raw_fly_speed, &tmp_fly_speed, sizeof(tmp_fly_speed));
  if (raw_fly_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_fly_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  return target;
}

::size_t UpdatePlayerAbilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.player.PlayerId player_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_id_);
  }

  // bool invulnerable = 2;
  if (this->_internal_invulnerable() != 0) {
    total_size += 2;
  }

  // bool is_flying = 3;
  if (this->_internal_is_flying() != 0) {
    total_size += 2;
  }

  // bool allow_flying = 4;
  if (this->_internal_allow_flying() != 0) {
    total_size += 2;
  }

  // bool creative_mode = 5;
  if (this->_internal_creative_mode() != 0) {
    total_size += 2;
  }

  // float walk_speed = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_walk_speed = this->_internal_walk_speed();
  ::uint32_t raw_walk_speed;
  memcpy(&raw_walk_speed, &tmp_walk_speed, sizeof(tmp_walk_speed));
  if (raw_walk_speed != 0) {
    total_size += 5;
  }

  // float fly_speed = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_fly_speed = this->_internal_fly_speed();
  ::uint32_t raw_fly_speed;
  memcpy(&raw_fly_speed, &tmp_fly_speed, sizeof(tmp_fly_speed));
  if (raw_fly_speed != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdatePlayerAbilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdatePlayerAbilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdatePlayerAbilities::GetClassData() const { return &_class_data_; }


void UpdatePlayerAbilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdatePlayerAbilities*>(&to_msg);
  auto& from = static_cast<const UpdatePlayerAbilities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
        from._internal_player_id());
  }
  if (from._internal_invulnerable() != 0) {
    _this->_internal_set_invulnerable(from._internal_invulnerable());
  }
  if (from._internal_is_flying() != 0) {
    _this->_internal_set_is_flying(from._internal_is_flying());
  }
  if (from._internal_allow_flying() != 0) {
    _this->_internal_set_allow_flying(from._internal_allow_flying());
  }
  if (from._internal_creative_mode() != 0) {
    _this->_internal_set_creative_mode(from._internal_creative_mode());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_walk_speed = from._internal_walk_speed();
  ::uint32_t raw_walk_speed;
  memcpy(&raw_walk_speed, &tmp_walk_speed, sizeof(tmp_walk_speed));
  if (raw_walk_speed != 0) {
    _this->_internal_set_walk_speed(from._internal_walk_speed());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_fly_speed = from._internal_fly_speed();
  ::uint32_t raw_fly_speed;
  memcpy(&raw_fly_speed, &tmp_fly_speed, sizeof(tmp_fly_speed));
  if (raw_fly_speed != 0) {
    _this->_internal_set_fly_speed(from._internal_fly_speed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdatePlayerAbilities::CopyFrom(const UpdatePlayerAbilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.UpdatePlayerAbilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdatePlayerAbilities::IsInitialized() const {
  return true;
}

void UpdatePlayerAbilities::InternalSwap(UpdatePlayerAbilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdatePlayerAbilities, _impl_.fly_speed_)
      + sizeof(UpdatePlayerAbilities::_impl_.fly_speed_)
      - PROTOBUF_FIELD_OFFSET(UpdatePlayerAbilities, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdatePlayerAbilities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[19]);
}
// ===================================================================

class UnloadChunk::_Internal {
 public:
  using HasBits = decltype(std::declval<UnloadChunk>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UnloadChunk, _impl_._has_bits_);
  static const ::minecpp::proto::player::PlayerId& player_id(const UnloadChunk* msg);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::common::ChunkPosition& chunk_position(const UnloadChunk* msg);
  static void set_has_chunk_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::minecpp::proto::player::PlayerId&
UnloadChunk::_Internal::player_id(const UnloadChunk* msg) {
  return *msg->_impl_.player_id_;
}
const ::minecpp::proto::common::ChunkPosition&
UnloadChunk::_Internal::chunk_position(const UnloadChunk* msg) {
  return *msg->_impl_.chunk_position_;
}
void UnloadChunk::clear_player_id() {
  if (_impl_.player_id_ != nullptr) _impl_.player_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void UnloadChunk::clear_chunk_position() {
  if (_impl_.chunk_position_ != nullptr) _impl_.chunk_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
UnloadChunk::UnloadChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.UnloadChunk)
}
UnloadChunk::UnloadChunk(const UnloadChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnloadChunk* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.chunk_position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.player_id_ = new ::minecpp::proto::player::PlayerId(*from._impl_.player_id_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.chunk_position_ = new ::minecpp::proto::common::ChunkPosition(*from._impl_.chunk_position_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.UnloadChunk)
}

inline void UnloadChunk::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_id_){nullptr}
    , decltype(_impl_.chunk_position_){nullptr}
  };
}

UnloadChunk::~UnloadChunk() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.UnloadChunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnloadChunk::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_id_;
  if (this != internal_default_instance()) delete _impl_.chunk_position_;
}

void UnloadChunk::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnloadChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.UnloadChunk)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.player_id_ != nullptr);
      _impl_.player_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.chunk_position_ != nullptr);
      _impl_.chunk_position_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnloadChunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.player.PlayerId player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player_id(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.ChunkPosition chunk_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_chunk_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UnloadChunk::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.UnloadChunk)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.player.PlayerId player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player_id(this),
        _Internal::player_id(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.common.ChunkPosition chunk_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::chunk_position(this),
        _Internal::chunk_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.UnloadChunk)
  return target;
}

::size_t UnloadChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.UnloadChunk)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .minecpp.proto.player.PlayerId player_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_id_);
    }

    // .minecpp.proto.common.ChunkPosition chunk_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.chunk_position_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnloadChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnloadChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnloadChunk::GetClassData() const { return &_class_data_; }


void UnloadChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnloadChunk*>(&to_msg);
  auto& from = static_cast<const UnloadChunk&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.UnloadChunk)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_player_id()->::minecpp::proto::player::PlayerId::MergeFrom(
          from._internal_player_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_chunk_position()->::minecpp::proto::common::ChunkPosition::MergeFrom(
          from._internal_chunk_position());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnloadChunk::CopyFrom(const UnloadChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.UnloadChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnloadChunk::IsInitialized() const {
  return true;
}

void UnloadChunk::InternalSwap(UnloadChunk* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnloadChunk, _impl_.chunk_position_)
      + sizeof(UnloadChunk::_impl_.chunk_position_)
      - PROTOBUF_FIELD_OFFSET(UnloadChunk, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnloadChunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[20]);
}
// ===================================================================

class PlayerList::_Internal {
 public:
};

void PlayerList::clear_list() {
  _internal_mutable_list()->Clear();
}
PlayerList::PlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.PlayerList)
}
PlayerList::PlayerList(const PlayerList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.list_){from._impl_.list_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.PlayerList)
}

inline void PlayerList::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.list_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerList::~PlayerList() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.PlayerList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerList::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_list()->~RepeatedPtrField();
}

void PlayerList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerList::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.PlayerList)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_list()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .minecpp.proto.player.Status list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PlayerList::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.PlayerList)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .minecpp.proto.player.Status list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.PlayerList)
  return target;
}

::size_t PlayerList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.PlayerList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .minecpp.proto.player.Status list = 1;
  total_size += 1UL * this->_internal_list_size();
  for (const auto& msg : this->_internal_list()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerList::GetClassData() const { return &_class_data_; }


void PlayerList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerList*>(&to_msg);
  auto& from = static_cast<const PlayerList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.PlayerList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_list()->MergeFrom(from._internal_list());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerList::CopyFrom(const PlayerList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.PlayerList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerList::IsInitialized() const {
  return true;
}

void PlayerList::InternalSwap(PlayerList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_list()->InternalSwap(other->_internal_mutable_list());
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[21]);
}
// ===================================================================

class EntityList::_Internal {
 public:
};

void EntityList::clear_entities() {
  _internal_mutable_entities()->Clear();
}
void EntityList::clear_player_entities() {
  _internal_mutable_player_entities()->Clear();
}
EntityList::EntityList(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.EntityList)
}
EntityList::EntityList(const EntityList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EntityList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entities_){from._impl_.entities_}
    , decltype(_impl_.player_entities_){from._impl_.player_entities_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.EntityList)
}

inline void EntityList::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.entities_){arena}
    , decltype(_impl_.player_entities_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EntityList::~EntityList() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.EntityList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EntityList::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_entities()->~RepeatedPtrField();
  _internal_mutable_player_entities()->~RepeatedPtrField();
}

void EntityList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EntityList::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.EntityList)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_entities()->Clear();
  _internal_mutable_player_entities()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EntityList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .minecpp.proto.entity.Entity entities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .minecpp.proto.entity.PlayerEntity player_entities = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_entities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EntityList::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.EntityList)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .minecpp.proto.entity.Entity entities = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entities_size()); i < n; i++) {
    const auto& repfield = this->_internal_entities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .minecpp.proto.entity.PlayerEntity player_entities = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_entities_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_entities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.EntityList)
  return target;
}

::size_t EntityList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.EntityList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .minecpp.proto.entity.Entity entities = 1;
  total_size += 1UL * this->_internal_entities_size();
  for (const auto& msg : this->_internal_entities()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .minecpp.proto.entity.PlayerEntity player_entities = 2;
  total_size += 1UL * this->_internal_player_entities_size();
  for (const auto& msg : this->_internal_player_entities()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntityList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EntityList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntityList::GetClassData() const { return &_class_data_; }


void EntityList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EntityList*>(&to_msg);
  auto& from = static_cast<const EntityList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.EntityList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entities()->MergeFrom(from._internal_entities());
  _this->_internal_mutable_player_entities()->MergeFrom(from._internal_player_entities());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EntityList::CopyFrom(const EntityList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.EntityList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntityList::IsInitialized() const {
  return true;
}

void EntityList::InternalSwap(EntityList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_entities()->InternalSwap(other->_internal_mutable_entities());
  _internal_mutable_player_entities()->InternalSwap(other->_internal_mutable_player_entities());
}

::PROTOBUF_NAMESPACE_ID::Metadata EntityList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[22]);
}
// ===================================================================

class SetEntityVelocity::_Internal {
 public:
  using HasBits = decltype(std::declval<SetEntityVelocity>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SetEntityVelocity, _impl_._has_bits_);
  static const ::minecpp::proto::common::Vector3i& velocity(const SetEntityVelocity* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::Vector3i&
SetEntityVelocity::_Internal::velocity(const SetEntityVelocity* msg) {
  return *msg->_impl_.velocity_;
}
void SetEntityVelocity::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SetEntityVelocity::SetEntityVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetEntityVelocity)
}
SetEntityVelocity::SetEntityVelocity(const SetEntityVelocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetEntityVelocity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.entity_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.velocity_ = new ::minecpp::proto::common::Vector3i(*from._impl_.velocity_);
  }
  _this->_impl_.entity_id_ = from._impl_.entity_id_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetEntityVelocity)
}

inline void SetEntityVelocity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.entity_id_) { 0u }

  };
}

SetEntityVelocity::~SetEntityVelocity() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetEntityVelocity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetEntityVelocity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.velocity_;
}

void SetEntityVelocity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetEntityVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetEntityVelocity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.velocity_ != nullptr);
    _impl_.velocity_->Clear();
  }
  _impl_.entity_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetEntityVelocity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Vector3i velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetEntityVelocity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetEntityVelocity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_entity_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Vector3i velocity = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetEntityVelocity)
  return target;
}

::size_t SetEntityVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetEntityVelocity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.common.Vector3i velocity = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);
  }

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetEntityVelocity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetEntityVelocity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetEntityVelocity::GetClassData() const { return &_class_data_; }


void SetEntityVelocity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetEntityVelocity*>(&to_msg);
  auto& from = static_cast<const SetEntityVelocity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetEntityVelocity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_velocity()->::minecpp::proto::common::Vector3i::MergeFrom(
        from._internal_velocity());
  }
  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetEntityVelocity::CopyFrom(const SetEntityVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetEntityVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetEntityVelocity::IsInitialized() const {
  return true;
}

void SetEntityVelocity::InternalSwap(SetEntityVelocity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetEntityVelocity, _impl_.entity_id_)
      + sizeof(SetEntityVelocity::_impl_.entity_id_)
      - PROTOBUF_FIELD_OFFSET(SetEntityVelocity, _impl_.velocity_)>(
          reinterpret_cast<char*>(&_impl_.velocity_),
          reinterpret_cast<char*>(&other->_impl_.velocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetEntityVelocity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[23]);
}
// ===================================================================

class AcceptPlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<AcceptPlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AcceptPlayer, _impl_._has_bits_);
  static const ::minecpp::proto::common::Gameplay& gameplay(const AcceptPlayer* msg);
  static void set_has_gameplay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::entity::Abilities& abilities(const AcceptPlayer* msg);
  static void set_has_abilities(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::minecpp::proto::player::Player& player(const AcceptPlayer* msg);
  static void set_has_player(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::minecpp::proto::common::Gameplay&
AcceptPlayer::_Internal::gameplay(const AcceptPlayer* msg) {
  return *msg->_impl_.gameplay_;
}
const ::minecpp::proto::entity::Abilities&
AcceptPlayer::_Internal::abilities(const AcceptPlayer* msg) {
  return *msg->_impl_.abilities_;
}
const ::minecpp::proto::player::Player&
AcceptPlayer::_Internal::player(const AcceptPlayer* msg) {
  return *msg->_impl_.player_;
}
void AcceptPlayer::clear_gameplay() {
  if (_impl_.gameplay_ != nullptr) _impl_.gameplay_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void AcceptPlayer::clear_abilities() {
  if (_impl_.abilities_ != nullptr) _impl_.abilities_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void AcceptPlayer::clear_player() {
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
AcceptPlayer::AcceptPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.AcceptPlayer)
}
AcceptPlayer::AcceptPlayer(const AcceptPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AcceptPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gameplay_){nullptr}
    , decltype(_impl_.abilities_){nullptr}
    , decltype(_impl_.player_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.gameplay_ = new ::minecpp::proto::common::Gameplay(*from._impl_.gameplay_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.abilities_ = new ::minecpp::proto::entity::Abilities(*from._impl_.abilities_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.player_ = new ::minecpp::proto::player::Player(*from._impl_.player_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.AcceptPlayer)
}

inline void AcceptPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gameplay_){nullptr}
    , decltype(_impl_.abilities_){nullptr}
    , decltype(_impl_.player_){nullptr}
  };
}

AcceptPlayer::~AcceptPlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.AcceptPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AcceptPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.gameplay_;
  if (this != internal_default_instance()) delete _impl_.abilities_;
  if (this != internal_default_instance()) delete _impl_.player_;
}

void AcceptPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AcceptPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.AcceptPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.gameplay_ != nullptr);
      _impl_.gameplay_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.abilities_ != nullptr);
      _impl_.abilities_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.player_ != nullptr);
      _impl_.player_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcceptPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.common.Gameplay gameplay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_gameplay(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.entity.Abilities abilities = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_abilities(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.player.Player player = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AcceptPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.AcceptPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Gameplay gameplay = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::gameplay(this),
        _Internal::gameplay(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.entity.Abilities abilities = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::abilities(this),
        _Internal::abilities(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.player.Player player = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.AcceptPlayer)
  return target;
}

::size_t AcceptPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.AcceptPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .minecpp.proto.common.Gameplay gameplay = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gameplay_);
    }

    // .minecpp.proto.entity.Abilities abilities = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.abilities_);
    }

    // .minecpp.proto.player.Player player = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.player_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AcceptPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AcceptPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AcceptPlayer::GetClassData() const { return &_class_data_; }


void AcceptPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AcceptPlayer*>(&to_msg);
  auto& from = static_cast<const AcceptPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.AcceptPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_gameplay()->::minecpp::proto::common::Gameplay::MergeFrom(
          from._internal_gameplay());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_abilities()->::minecpp::proto::entity::Abilities::MergeFrom(
          from._internal_abilities());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_player()->::minecpp::proto::player::Player::MergeFrom(
          from._internal_player());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AcceptPlayer::CopyFrom(const AcceptPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.AcceptPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcceptPlayer::IsInitialized() const {
  return true;
}

void AcceptPlayer::InternalSwap(AcceptPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AcceptPlayer, _impl_.player_)
      + sizeof(AcceptPlayer::_impl_.player_)
      - PROTOBUF_FIELD_OFFSET(AcceptPlayer, _impl_.gameplay_)>(
          reinterpret_cast<char*>(&_impl_.gameplay_),
          reinterpret_cast<char*>(&other->_impl_.gameplay_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AcceptPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[24]);
}
// ===================================================================

class DenyPlayer::_Internal {
 public:
};

DenyPlayer::DenyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.DenyPlayer)
}
DenyPlayer::DenyPlayer(const DenyPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DenyPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denial_reason_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denial_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denial_reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denial_reason().empty()) {
    _this->_impl_.denial_reason_.Set(from._internal_denial_reason(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.DenyPlayer)
}

inline void DenyPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.denial_reason_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denial_reason_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denial_reason_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DenyPlayer::~DenyPlayer() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.DenyPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DenyPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.denial_reason_.Destroy();
}

void DenyPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DenyPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.DenyPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.denial_reason_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DenyPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denial_reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_denial_reason();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.DenyPlayer.denial_reason"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DenyPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.DenyPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denial_reason = 1;
  if (!this->_internal_denial_reason().empty()) {
    const std::string& _s = this->_internal_denial_reason();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.DenyPlayer.denial_reason");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.DenyPlayer)
  return target;
}

::size_t DenyPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.DenyPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string denial_reason = 1;
  if (!this->_internal_denial_reason().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denial_reason());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DenyPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DenyPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DenyPlayer::GetClassData() const { return &_class_data_; }


void DenyPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DenyPlayer*>(&to_msg);
  auto& from = static_cast<const DenyPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.DenyPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_denial_reason().empty()) {
    _this->_internal_set_denial_reason(from._internal_denial_reason());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DenyPlayer::CopyFrom(const DenyPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.DenyPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenyPlayer::IsInitialized() const {
  return true;
}

void DenyPlayer::InternalSwap(DenyPlayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denial_reason_, lhs_arena,
                                       &other->_impl_.denial_reason_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata DenyPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[25]);
}
// ===================================================================

class SetInventorySlot::_Internal {
 public:
  using HasBits = decltype(std::declval<SetInventorySlot>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SetInventorySlot, _impl_._has_bits_);
  static const ::minecpp::proto::common::Slot& slot(const SetInventorySlot* msg);
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::Slot&
SetInventorySlot::_Internal::slot(const SetInventorySlot* msg) {
  return *msg->_impl_.slot_;
}
void SetInventorySlot::clear_slot() {
  if (_impl_.slot_ != nullptr) _impl_.slot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SetInventorySlot::SetInventorySlot(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetInventorySlot)
}
SetInventorySlot::SetInventorySlot(const SetInventorySlot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetInventorySlot* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){nullptr}
    , decltype(_impl_.slot_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.slot_ = new ::minecpp::proto::common::Slot(*from._impl_.slot_);
  }
  _this->_impl_.slot_id_ = from._impl_.slot_id_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetInventorySlot)
}

inline void SetInventorySlot::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){nullptr}
    , decltype(_impl_.slot_id_) { 0u }

  };
}

SetInventorySlot::~SetInventorySlot() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetInventorySlot)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetInventorySlot::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.slot_;
}

void SetInventorySlot::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetInventorySlot::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetInventorySlot)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.slot_ != nullptr);
    _impl_.slot_->Clear();
  }
  _impl_.slot_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetInventorySlot::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 slot_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.slot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Slot slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_slot(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetInventorySlot::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetInventorySlot)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 slot_id = 1;
  if (this->_internal_slot_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_slot_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Slot slot = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::slot(this),
        _Internal::slot(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetInventorySlot)
  return target;
}

::size_t SetInventorySlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetInventorySlot)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.common.Slot slot = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.slot_);
  }

  // uint32 slot_id = 1;
  if (this->_internal_slot_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_slot_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetInventorySlot::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetInventorySlot::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetInventorySlot::GetClassData() const { return &_class_data_; }


void SetInventorySlot::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetInventorySlot*>(&to_msg);
  auto& from = static_cast<const SetInventorySlot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetInventorySlot)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_slot()->::minecpp::proto::common::Slot::MergeFrom(
        from._internal_slot());
  }
  if (from._internal_slot_id() != 0) {
    _this->_internal_set_slot_id(from._internal_slot_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetInventorySlot::CopyFrom(const SetInventorySlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetInventorySlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetInventorySlot::IsInitialized() const {
  return true;
}

void SetInventorySlot::InternalSwap(SetInventorySlot* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetInventorySlot, _impl_.slot_id_)
      + sizeof(SetInventorySlot::_impl_.slot_id_)
      - PROTOBUF_FIELD_OFFSET(SetInventorySlot, _impl_.slot_)>(
          reinterpret_cast<char*>(&_impl_.slot_),
          reinterpret_cast<char*>(&other->_impl_.slot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetInventorySlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[26]);
}
// ===================================================================

class SectionBlockLight::_Internal {
 public:
};

SectionBlockLight::SectionBlockLight(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SectionBlockLight)
}
SectionBlockLight::SectionBlockLight(const SectionBlockLight& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SectionBlockLight* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_light_) {}

    , decltype(_impl_.y_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_light_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.block_light_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_light().empty()) {
    _this->_impl_.block_light_.Set(from._internal_block_light(), _this->GetArenaForAllocation());
  }
  _this->_impl_.y_ = from._impl_.y_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SectionBlockLight)
}

inline void SectionBlockLight::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.block_light_) {}

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_light_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.block_light_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SectionBlockLight::~SectionBlockLight() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SectionBlockLight)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SectionBlockLight::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.block_light_.Destroy();
}

void SectionBlockLight::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SectionBlockLight::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SectionBlockLight)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_light_.ClearToEmpty();
  _impl_.y_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SectionBlockLight::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 y = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bytes block_light = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_block_light();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SectionBlockLight::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SectionBlockLight)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 y = 1;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_y(), target);
  }

  // bytes block_light = 2;
  if (!this->_internal_block_light().empty()) {
    const std::string& _s = this->_internal_block_light();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SectionBlockLight)
  return target;
}

::size_t SectionBlockLight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SectionBlockLight)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes block_light = 2;
  if (!this->_internal_block_light().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                                    this->_internal_block_light());
  }

  // int32 y = 1;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_y());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SectionBlockLight::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SectionBlockLight::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SectionBlockLight::GetClassData() const { return &_class_data_; }


void SectionBlockLight::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SectionBlockLight*>(&to_msg);
  auto& from = static_cast<const SectionBlockLight&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SectionBlockLight)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_block_light().empty()) {
    _this->_internal_set_block_light(from._internal_block_light());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SectionBlockLight::CopyFrom(const SectionBlockLight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SectionBlockLight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SectionBlockLight::IsInitialized() const {
  return true;
}

void SectionBlockLight::InternalSwap(SectionBlockLight* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.block_light_, lhs_arena,
                                       &other->_impl_.block_light_, rhs_arena);

  swap(_impl_.y_, other->_impl_.y_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SectionBlockLight::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[27]);
}
// ===================================================================

class ChunkBlockLight::_Internal {
 public:
  using HasBits = decltype(std::declval<ChunkBlockLight>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ChunkBlockLight, _impl_._has_bits_);
  static const ::minecpp::proto::common::ChunkPosition& position(const ChunkBlockLight* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::ChunkPosition&
ChunkBlockLight::_Internal::position(const ChunkBlockLight* msg) {
  return *msg->_impl_.position_;
}
void ChunkBlockLight::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ChunkBlockLight::ChunkBlockLight(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.ChunkBlockLight)
}
ChunkBlockLight::ChunkBlockLight(const ChunkBlockLight& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkBlockLight* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sections_){from._impl_.sections_}
    , decltype(_impl_.position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::minecpp::proto::common::ChunkPosition(*from._impl_.position_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.ChunkBlockLight)
}

inline void ChunkBlockLight::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sections_){arena}
    , decltype(_impl_.position_){nullptr}
  };
}

ChunkBlockLight::~ChunkBlockLight() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.ChunkBlockLight)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkBlockLight::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_sections()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void ChunkBlockLight::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkBlockLight::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.ChunkBlockLight)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_sections()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkBlockLight::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.common.ChunkPosition position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .minecpp.proto.event.clientbound.SectionBlockLight sections = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChunkBlockLight::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.ChunkBlockLight)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.ChunkPosition position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // repeated .minecpp.proto.event.clientbound.SectionBlockLight sections = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sections_size()); i < n; i++) {
    const auto& repfield = this->_internal_sections(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.ChunkBlockLight)
  return target;
}

::size_t ChunkBlockLight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.ChunkBlockLight)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .minecpp.proto.event.clientbound.SectionBlockLight sections = 2;
  total_size += 1UL * this->_internal_sections_size();
  for (const auto& msg : this->_internal_sections()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .minecpp.proto.common.ChunkPosition position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkBlockLight::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkBlockLight::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkBlockLight::GetClassData() const { return &_class_data_; }


void ChunkBlockLight::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkBlockLight*>(&to_msg);
  auto& from = static_cast<const ChunkBlockLight&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.ChunkBlockLight)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_sections()->MergeFrom(from._internal_sections());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::minecpp::proto::common::ChunkPosition::MergeFrom(
        from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkBlockLight::CopyFrom(const ChunkBlockLight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.ChunkBlockLight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkBlockLight::IsInitialized() const {
  return true;
}

void ChunkBlockLight::InternalSwap(ChunkBlockLight* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_sections()->InternalSwap(other->_internal_mutable_sections());
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkBlockLight::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[28]);
}
// ===================================================================

class UpdateBlockLight::_Internal {
 public:
};

UpdateBlockLight::UpdateBlockLight(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.UpdateBlockLight)
}
UpdateBlockLight::UpdateBlockLight(const UpdateBlockLight& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateBlockLight* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_light_){from._impl_.block_light_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.UpdateBlockLight)
}

inline void UpdateBlockLight::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.block_light_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateBlockLight::~UpdateBlockLight() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.UpdateBlockLight)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateBlockLight::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_block_light()->~RepeatedPtrField();
}

void UpdateBlockLight::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateBlockLight::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.UpdateBlockLight)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_block_light()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateBlockLight::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .minecpp.proto.event.clientbound.ChunkBlockLight block_light = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_block_light(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdateBlockLight::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.UpdateBlockLight)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .minecpp.proto.event.clientbound.ChunkBlockLight block_light = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_block_light_size()); i < n; i++) {
    const auto& repfield = this->_internal_block_light(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.UpdateBlockLight)
  return target;
}

::size_t UpdateBlockLight::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.UpdateBlockLight)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .minecpp.proto.event.clientbound.ChunkBlockLight block_light = 1;
  total_size += 1UL * this->_internal_block_light_size();
  for (const auto& msg : this->_internal_block_light()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateBlockLight::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateBlockLight::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateBlockLight::GetClassData() const { return &_class_data_; }


void UpdateBlockLight::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateBlockLight*>(&to_msg);
  auto& from = static_cast<const UpdateBlockLight&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.UpdateBlockLight)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_block_light()->MergeFrom(from._internal_block_light());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateBlockLight::CopyFrom(const UpdateBlockLight& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.UpdateBlockLight)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateBlockLight::IsInitialized() const {
  return true;
}

void UpdateBlockLight::InternalSwap(UpdateBlockLight* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_block_light()->InternalSwap(other->_internal_mutable_block_light());
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateBlockLight::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[29]);
}
// ===================================================================

class ChunkData::_Internal {
 public:
  using HasBits = decltype(std::declval<ChunkData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ChunkData, _impl_._has_bits_);
  static const ::minecpp::proto::chunk::Chunk& chunk(const ChunkData* msg);
  static void set_has_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::chunk::Chunk&
ChunkData::_Internal::chunk(const ChunkData* msg) {
  return *msg->_impl_.chunk_;
}
void ChunkData::clear_chunk() {
  if (_impl_.chunk_ != nullptr) _impl_.chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ChunkData::ChunkData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.ChunkData)
}
ChunkData::ChunkData(const ChunkData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChunkData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunk_){nullptr}
    , decltype(_impl_.is_initial_chunk_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.chunk_ = new ::minecpp::proto::chunk::Chunk(*from._impl_.chunk_);
  }
  _this->_impl_.is_initial_chunk_ = from._impl_.is_initial_chunk_;
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.ChunkData)
}

inline void ChunkData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunk_){nullptr}
    , decltype(_impl_.is_initial_chunk_) { false }

  };
}

ChunkData::~ChunkData() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.ChunkData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChunkData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.chunk_;
}

void ChunkData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChunkData::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.ChunkData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.chunk_ != nullptr);
    _impl_.chunk_->Clear();
  }
  _impl_.is_initial_chunk_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChunkData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.chunk.Chunk chunk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chunk(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_initial_chunk = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.is_initial_chunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ChunkData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.ChunkData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.chunk.Chunk chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chunk(this),
        _Internal::chunk(this).GetCachedSize(), target, stream);
  }

  // bool is_initial_chunk = 2;
  if (this->_internal_is_initial_chunk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_is_initial_chunk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.ChunkData)
  return target;
}

::size_t ChunkData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.ChunkData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.chunk.Chunk chunk = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chunk_);
  }

  // bool is_initial_chunk = 2;
  if (this->_internal_is_initial_chunk() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChunkData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChunkData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChunkData::GetClassData() const { return &_class_data_; }


void ChunkData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChunkData*>(&to_msg);
  auto& from = static_cast<const ChunkData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.ChunkData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_chunk()->::minecpp::proto::chunk::Chunk::MergeFrom(
        from._internal_chunk());
  }
  if (from._internal_is_initial_chunk() != 0) {
    _this->_internal_set_is_initial_chunk(from._internal_is_initial_chunk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkData::CopyFrom(const ChunkData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.ChunkData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChunkData::IsInitialized() const {
  return true;
}

void ChunkData::InternalSwap(ChunkData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChunkData, _impl_.is_initial_chunk_)
      + sizeof(ChunkData::_impl_.is_initial_chunk_)
      - PROTOBUF_FIELD_OFFSET(ChunkData, _impl_.chunk_)>(
          reinterpret_cast<char*>(&_impl_.chunk_),
          reinterpret_cast<char*>(&other->_impl_.chunk_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChunkData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[30]);
}
// ===================================================================

class SetCenterChunk::_Internal {
 public:
  using HasBits = decltype(std::declval<SetCenterChunk>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SetCenterChunk, _impl_._has_bits_);
  static const ::minecpp::proto::common::ChunkPosition& position(const SetCenterChunk* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::ChunkPosition&
SetCenterChunk::_Internal::position(const SetCenterChunk* msg) {
  return *msg->_impl_.position_;
}
void SetCenterChunk::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SetCenterChunk::SetCenterChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetCenterChunk)
}
SetCenterChunk::SetCenterChunk(const SetCenterChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetCenterChunk* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::minecpp::proto::common::ChunkPosition(*from._impl_.position_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetCenterChunk)
}

inline void SetCenterChunk::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
  };
}

SetCenterChunk::~SetCenterChunk() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetCenterChunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetCenterChunk::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
}

void SetCenterChunk::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetCenterChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetCenterChunk)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.position_ != nullptr);
    _impl_.position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetCenterChunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.common.ChunkPosition position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetCenterChunk::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetCenterChunk)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.ChunkPosition position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetCenterChunk)
  return target;
}

::size_t SetCenterChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetCenterChunk)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.common.ChunkPosition position = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetCenterChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetCenterChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetCenterChunk::GetClassData() const { return &_class_data_; }


void SetCenterChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetCenterChunk*>(&to_msg);
  auto& from = static_cast<const SetCenterChunk&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetCenterChunk)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_position()->::minecpp::proto::common::ChunkPosition::MergeFrom(
        from._internal_position());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetCenterChunk::CopyFrom(const SetCenterChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetCenterChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetCenterChunk::IsInitialized() const {
  return true;
}

void SetCenterChunk::InternalSwap(SetCenterChunk* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.position_, other->_impl_.position_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetCenterChunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[31]);
}
// ===================================================================

class SetEntityEquipment::_Internal {
 public:
  using HasBits = decltype(std::declval<SetEntityEquipment>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SetEntityEquipment, _impl_._has_bits_);
  static const ::minecpp::proto::common::Slot& item(const SetEntityEquipment* msg);
  static void set_has_item(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::Slot&
SetEntityEquipment::_Internal::item(const SetEntityEquipment* msg) {
  return *msg->_impl_.item_;
}
void SetEntityEquipment::clear_item() {
  if (_impl_.item_ != nullptr) _impl_.item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SetEntityEquipment::SetEntityEquipment(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetEntityEquipment)
}
SetEntityEquipment::SetEntityEquipment(const SetEntityEquipment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetEntityEquipment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_){nullptr}
    , decltype(_impl_.entity_id_) {}

    , decltype(_impl_.equipment_slot_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.item_ = new ::minecpp::proto::common::Slot(*from._impl_.item_);
  }
  ::memcpy(&_impl_.entity_id_, &from._impl_.entity_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.equipment_slot_) -
    reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.equipment_slot_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetEntityEquipment)
}

inline void SetEntityEquipment::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.item_){nullptr}
    , decltype(_impl_.entity_id_) { 0u }

    , decltype(_impl_.equipment_slot_) { 0 }

  };
}

SetEntityEquipment::~SetEntityEquipment() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetEntityEquipment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetEntityEquipment::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.item_;
}

void SetEntityEquipment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetEntityEquipment::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetEntityEquipment)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.item_ != nullptr);
    _impl_.item_->Clear();
  }
  ::memset(&_impl_.entity_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.equipment_slot_) -
      reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.equipment_slot_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetEntityEquipment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.entity.EquipmentSlot equipment_slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_equipment_slot(static_cast<::minecpp::proto::entity::EquipmentSlot>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Slot item = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_item(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetEntityEquipment::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetEntityEquipment)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_entity_id(), target);
  }

  // .minecpp.proto.entity.EquipmentSlot equipment_slot = 2;
  if (this->_internal_equipment_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_equipment_slot(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Slot item = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::item(this),
        _Internal::item(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetEntityEquipment)
  return target;
}

::size_t SetEntityEquipment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetEntityEquipment)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.common.Slot item = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.item_);
  }

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  // .minecpp.proto.entity.EquipmentSlot equipment_slot = 2;
  if (this->_internal_equipment_slot() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_equipment_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetEntityEquipment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetEntityEquipment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetEntityEquipment::GetClassData() const { return &_class_data_; }


void SetEntityEquipment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetEntityEquipment*>(&to_msg);
  auto& from = static_cast<const SetEntityEquipment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetEntityEquipment)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_item()->::minecpp::proto::common::Slot::MergeFrom(
        from._internal_item());
  }
  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  if (from._internal_equipment_slot() != 0) {
    _this->_internal_set_equipment_slot(from._internal_equipment_slot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetEntityEquipment::CopyFrom(const SetEntityEquipment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetEntityEquipment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetEntityEquipment::IsInitialized() const {
  return true;
}

void SetEntityEquipment::InternalSwap(SetEntityEquipment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetEntityEquipment, _impl_.equipment_slot_)
      + sizeof(SetEntityEquipment::_impl_.equipment_slot_)
      - PROTOBUF_FIELD_OFFSET(SetEntityEquipment, _impl_.item_)>(
          reinterpret_cast<char*>(&_impl_.item_),
          reinterpret_cast<char*>(&other->_impl_.item_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetEntityEquipment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[32]);
}
// ===================================================================

class SetHealth::_Internal {
 public:
};

SetHealth::SetHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetHealth)
}
SetHealth::SetHealth(const SetHealth& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetHealth)
}

inline void SetHealth::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.health_) { 0 }

    , decltype(_impl_.food_) { 0 }

    , decltype(_impl_.food_saturation_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetHealth::~SetHealth() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetHealth)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetHealth::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetHealth::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetHealth::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetHealth)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.health_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.food_saturation_) -
      reinterpret_cast<char*>(&_impl_.health_)) + sizeof(_impl_.food_saturation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetHealth::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float health = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _impl_.health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 food = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.food_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // float food_saturation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _impl_.food_saturation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetHealth::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetHealth)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float health = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_health = this->_internal_health();
  ::uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_health(), target);
  }

  // int32 food = 2;
  if (this->_internal_food() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_food(), target);
  }

  // float food_saturation = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_food_saturation = this->_internal_food_saturation();
  ::uint32_t raw_food_saturation;
  memcpy(&raw_food_saturation, &tmp_food_saturation, sizeof(tmp_food_saturation));
  if (raw_food_saturation != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_food_saturation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetHealth)
  return target;
}

::size_t SetHealth::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetHealth)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float health = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_health = this->_internal_health();
  ::uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    total_size += 5;
  }

  // int32 food = 2;
  if (this->_internal_food() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_food());
  }

  // float food_saturation = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_food_saturation = this->_internal_food_saturation();
  ::uint32_t raw_food_saturation;
  memcpy(&raw_food_saturation, &tmp_food_saturation, sizeof(tmp_food_saturation));
  if (raw_food_saturation != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetHealth::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetHealth::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetHealth::GetClassData() const { return &_class_data_; }


void SetHealth::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetHealth*>(&to_msg);
  auto& from = static_cast<const SetHealth&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetHealth)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_health = from._internal_health();
  ::uint32_t raw_health;
  memcpy(&raw_health, &tmp_health, sizeof(tmp_health));
  if (raw_health != 0) {
    _this->_internal_set_health(from._internal_health());
  }
  if (from._internal_food() != 0) {
    _this->_internal_set_food(from._internal_food());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float), "Code assumes ::uint32_t and float are the same size.");
  float tmp_food_saturation = from._internal_food_saturation();
  ::uint32_t raw_food_saturation;
  memcpy(&raw_food_saturation, &tmp_food_saturation, sizeof(tmp_food_saturation));
  if (raw_food_saturation != 0) {
    _this->_internal_set_food_saturation(from._internal_food_saturation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetHealth::CopyFrom(const SetHealth& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetHealth)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetHealth::IsInitialized() const {
  return true;
}

void SetHealth::InternalSwap(SetHealth* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetHealth, _impl_.food_saturation_)
      + sizeof(SetHealth::_impl_.food_saturation_)
      - PROTOBUF_FIELD_OFFSET(SetHealth, _impl_.health_)>(
          reinterpret_cast<char*>(&_impl_.health_),
          reinterpret_cast<char*>(&other->_impl_.health_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetHealth::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[33]);
}
// ===================================================================

class CollectItem::_Internal {
 public:
};

CollectItem::CollectItem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.CollectItem)
}
CollectItem::CollectItem(const CollectItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.CollectItem)
}

inline void CollectItem::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.collected_entity_id_) { 0u }

    , decltype(_impl_.collector_entity_id_) { 0u }

    , decltype(_impl_.count_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CollectItem::~CollectItem() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.CollectItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CollectItem::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void CollectItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CollectItem::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.CollectItem)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.collected_entity_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_) -
      reinterpret_cast<char*>(&_impl_.collected_entity_id_)) + sizeof(_impl_.count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CollectItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 collected_entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.collected_entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 collector_entity_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.collector_entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CollectItem::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.CollectItem)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 collected_entity_id = 1;
  if (this->_internal_collected_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_collected_entity_id(), target);
  }

  // uint32 collector_entity_id = 2;
  if (this->_internal_collector_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_collector_entity_id(), target);
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.CollectItem)
  return target;
}

::size_t CollectItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.CollectItem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 collected_entity_id = 1;
  if (this->_internal_collected_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_collected_entity_id());
  }

  // uint32 collector_entity_id = 2;
  if (this->_internal_collector_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_collector_entity_id());
  }

  // uint32 count = 3;
  if (this->_internal_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CollectItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CollectItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CollectItem::GetClassData() const { return &_class_data_; }


void CollectItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CollectItem*>(&to_msg);
  auto& from = static_cast<const CollectItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.CollectItem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_collected_entity_id() != 0) {
    _this->_internal_set_collected_entity_id(from._internal_collected_entity_id());
  }
  if (from._internal_collector_entity_id() != 0) {
    _this->_internal_set_collector_entity_id(from._internal_collector_entity_id());
  }
  if (from._internal_count() != 0) {
    _this->_internal_set_count(from._internal_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CollectItem::CopyFrom(const CollectItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.CollectItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectItem::IsInitialized() const {
  return true;
}

void CollectItem::InternalSwap(CollectItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CollectItem, _impl_.count_)
      + sizeof(CollectItem::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(CollectItem, _impl_.collected_entity_id_)>(
          reinterpret_cast<char*>(&_impl_.collected_entity_id_),
          reinterpret_cast<char*>(&other->_impl_.collected_entity_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CollectItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[34]);
}
// ===================================================================

class RemoveEntity::_Internal {
 public:
};

RemoveEntity::RemoveEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.RemoveEntity)
}
RemoveEntity::RemoveEntity(const RemoveEntity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.RemoveEntity)
}

inline void RemoveEntity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.entity_id_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RemoveEntity::~RemoveEntity() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.RemoveEntity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveEntity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void RemoveEntity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.RemoveEntity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entity_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveEntity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RemoveEntity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.RemoveEntity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_entity_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.RemoveEntity)
  return target;
}

::size_t RemoveEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.RemoveEntity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveEntity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveEntity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveEntity::GetClassData() const { return &_class_data_; }


void RemoveEntity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveEntity*>(&to_msg);
  auto& from = static_cast<const RemoveEntity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.RemoveEntity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveEntity::CopyFrom(const RemoveEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.RemoveEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveEntity::IsInitialized() const {
  return true;
}

void RemoveEntity::InternalSwap(RemoveEntity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);

  swap(_impl_.entity_id_, other->_impl_.entity_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveEntity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[35]);
}
// ===================================================================

class TeleportEntity::_Internal {
 public:
  using HasBits = decltype(std::declval<TeleportEntity>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TeleportEntity, _impl_._has_bits_);
  static const ::minecpp::proto::common::Vector3& position(const TeleportEntity* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::minecpp::proto::common::Rotation& rotation(const TeleportEntity* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::minecpp::proto::common::Vector3&
TeleportEntity::_Internal::position(const TeleportEntity* msg) {
  return *msg->_impl_.position_;
}
const ::minecpp::proto::common::Rotation&
TeleportEntity::_Internal::rotation(const TeleportEntity* msg) {
  return *msg->_impl_.rotation_;
}
void TeleportEntity::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TeleportEntity::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TeleportEntity::TeleportEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.TeleportEntity)
}
TeleportEntity::TeleportEntity(const TeleportEntity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TeleportEntity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.entity_id_) {}

    , decltype(_impl_.is_on_ground_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.position_ = new ::minecpp::proto::common::Vector3(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.rotation_ = new ::minecpp::proto::common::Rotation(*from._impl_.rotation_);
  }
  ::memcpy(&_impl_.entity_id_, &from._impl_.entity_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.is_on_ground_) -
    reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.is_on_ground_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.TeleportEntity)
}

inline void TeleportEntity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.entity_id_) { 0u }

    , decltype(_impl_.is_on_ground_) { false }

  };
}

TeleportEntity::~TeleportEntity() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.TeleportEntity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TeleportEntity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void TeleportEntity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TeleportEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.TeleportEntity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  ::memset(&_impl_.entity_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_on_ground_) -
      reinterpret_cast<char*>(&_impl_.entity_id_)) + sizeof(_impl_.is_on_ground_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TeleportEntity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Vector3 position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Rotation rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_on_ground = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.is_on_ground_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TeleportEntity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.TeleportEntity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_entity_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Vector3 position = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .minecpp.proto.common.Rotation rotation = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // bool is_on_ground = 4;
  if (this->_internal_is_on_ground() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is_on_ground(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.TeleportEntity)
  return target;
}

::size_t TeleportEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.TeleportEntity)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .minecpp.proto.common.Vector3 position = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // .minecpp.proto.common.Rotation rotation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

  }
  // uint32 entity_id = 1;
  if (this->_internal_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_entity_id());
  }

  // bool is_on_ground = 4;
  if (this->_internal_is_on_ground() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TeleportEntity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TeleportEntity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TeleportEntity::GetClassData() const { return &_class_data_; }


void TeleportEntity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TeleportEntity*>(&to_msg);
  auto& from = static_cast<const TeleportEntity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.TeleportEntity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::minecpp::proto::common::Vector3::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rotation()->::minecpp::proto::common::Rotation::MergeFrom(
          from._internal_rotation());
    }
  }
  if (from._internal_entity_id() != 0) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  if (from._internal_is_on_ground() != 0) {
    _this->_internal_set_is_on_ground(from._internal_is_on_ground());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TeleportEntity::CopyFrom(const TeleportEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.TeleportEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeleportEntity::IsInitialized() const {
  return true;
}

void TeleportEntity::InternalSwap(TeleportEntity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TeleportEntity, _impl_.is_on_ground_)
      + sizeof(TeleportEntity::_impl_.is_on_ground_)
      - PROTOBUF_FIELD_OFFSET(TeleportEntity, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TeleportEntity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[36]);
}
// ===================================================================

class DisplayDeathScreen::_Internal {
 public:
};

DisplayDeathScreen::DisplayDeathScreen(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.DisplayDeathScreen)
}
DisplayDeathScreen::DisplayDeathScreen(const DisplayDeathScreen& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DisplayDeathScreen* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.death_message_) {}

    , decltype(_impl_.victim_entity_id_) {}

    , decltype(_impl_.killer_entity_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.death_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.death_message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_death_message().empty()) {
    _this->_impl_.death_message_.Set(from._internal_death_message(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.victim_entity_id_, &from._impl_.victim_entity_id_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.killer_entity_id_) -
    reinterpret_cast<char*>(&_impl_.victim_entity_id_)) + sizeof(_impl_.killer_entity_id_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.DisplayDeathScreen)
}

inline void DisplayDeathScreen::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.death_message_) {}

    , decltype(_impl_.victim_entity_id_) { 0u }

    , decltype(_impl_.killer_entity_id_) { 0u }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.death_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.death_message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DisplayDeathScreen::~DisplayDeathScreen() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.DisplayDeathScreen)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DisplayDeathScreen::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.death_message_.Destroy();
}

void DisplayDeathScreen::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DisplayDeathScreen::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.DisplayDeathScreen)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.death_message_.ClearToEmpty();
  ::memset(&_impl_.victim_entity_id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.killer_entity_id_) -
      reinterpret_cast<char*>(&_impl_.victim_entity_id_)) + sizeof(_impl_.killer_entity_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DisplayDeathScreen::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 victim_entity_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.victim_entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 killer_entity_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.killer_entity_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string death_message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_death_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.DisplayDeathScreen.death_message"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* DisplayDeathScreen::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.DisplayDeathScreen)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 victim_entity_id = 1;
  if (this->_internal_victim_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_victim_entity_id(), target);
  }

  // uint32 killer_entity_id = 2;
  if (this->_internal_killer_entity_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_killer_entity_id(), target);
  }

  // string death_message = 3;
  if (!this->_internal_death_message().empty()) {
    const std::string& _s = this->_internal_death_message();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.DisplayDeathScreen.death_message");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.DisplayDeathScreen)
  return target;
}

::size_t DisplayDeathScreen::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.DisplayDeathScreen)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string death_message = 3;
  if (!this->_internal_death_message().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_death_message());
  }

  // uint32 victim_entity_id = 1;
  if (this->_internal_victim_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_victim_entity_id());
  }

  // uint32 killer_entity_id = 2;
  if (this->_internal_killer_entity_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_killer_entity_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DisplayDeathScreen::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DisplayDeathScreen::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DisplayDeathScreen::GetClassData() const { return &_class_data_; }


void DisplayDeathScreen::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DisplayDeathScreen*>(&to_msg);
  auto& from = static_cast<const DisplayDeathScreen&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.DisplayDeathScreen)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_death_message().empty()) {
    _this->_internal_set_death_message(from._internal_death_message());
  }
  if (from._internal_victim_entity_id() != 0) {
    _this->_internal_set_victim_entity_id(from._internal_victim_entity_id());
  }
  if (from._internal_killer_entity_id() != 0) {
    _this->_internal_set_killer_entity_id(from._internal_killer_entity_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DisplayDeathScreen::CopyFrom(const DisplayDeathScreen& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.DisplayDeathScreen)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisplayDeathScreen::IsInitialized() const {
  return true;
}

void DisplayDeathScreen::InternalSwap(DisplayDeathScreen* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.death_message_, lhs_arena,
                                       &other->_impl_.death_message_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DisplayDeathScreen, _impl_.killer_entity_id_)
      + sizeof(DisplayDeathScreen::_impl_.killer_entity_id_)
      - PROTOBUF_FIELD_OFFSET(DisplayDeathScreen, _impl_.victim_entity_id_)>(
          reinterpret_cast<char*>(&_impl_.victim_entity_id_),
          reinterpret_cast<char*>(&other->_impl_.victim_entity_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DisplayDeathScreen::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[37]);
}
// ===================================================================

class Respawn::_Internal {
 public:
  using HasBits = decltype(std::declval<Respawn>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Respawn, _impl_._has_bits_);
  static const ::minecpp::proto::common::Vector3& death_position(const Respawn* msg);
  static void set_has_death_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::common::Vector3&
Respawn::_Internal::death_position(const Respawn* msg) {
  return *msg->_impl_.death_position_;
}
void Respawn::clear_death_position() {
  if (_impl_.death_position_ != nullptr) _impl_.death_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
Respawn::Respawn(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.Respawn)
}
Respawn::Respawn(const Respawn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Respawn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dimension_type_) {}

    , decltype(_impl_.dimension_name_) {}

    , decltype(_impl_.death_dimension_) {}

    , decltype(_impl_.death_position_){nullptr}
    , decltype(_impl_.hashed_seed_) {}

    , decltype(_impl_.game_mode_) {}

    , decltype(_impl_.previous_game_mode_) {}

    , decltype(_impl_.is_debug_) {}

    , decltype(_impl_.is_flat_) {}

    , decltype(_impl_.copy_metadata_) {}

    , decltype(_impl_.has_death_location_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.dimension_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dimension_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dimension_type().empty()) {
    _this->_impl_.dimension_type_.Set(from._internal_dimension_type(), _this->GetArenaForAllocation());
  }
  _impl_.dimension_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dimension_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dimension_name().empty()) {
    _this->_impl_.dimension_name_.Set(from._internal_dimension_name(), _this->GetArenaForAllocation());
  }
  _impl_.death_dimension_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.death_dimension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_death_dimension().empty()) {
    _this->_impl_.death_dimension_.Set(from._internal_death_dimension(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.death_position_ = new ::minecpp::proto::common::Vector3(*from._impl_.death_position_);
  }
  ::memcpy(&_impl_.hashed_seed_, &from._impl_.hashed_seed_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.has_death_location_) -
    reinterpret_cast<char*>(&_impl_.hashed_seed_)) + sizeof(_impl_.has_death_location_));
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.Respawn)
}

inline void Respawn::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dimension_type_) {}

    , decltype(_impl_.dimension_name_) {}

    , decltype(_impl_.death_dimension_) {}

    , decltype(_impl_.death_position_){nullptr}
    , decltype(_impl_.hashed_seed_) { ::int64_t{0} }

    , decltype(_impl_.game_mode_) { 0 }

    , decltype(_impl_.previous_game_mode_) { 0 }

    , decltype(_impl_.is_debug_) { false }

    , decltype(_impl_.is_flat_) { false }

    , decltype(_impl_.copy_metadata_) { false }

    , decltype(_impl_.has_death_location_) { false }

  };
  _impl_.dimension_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dimension_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dimension_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dimension_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.death_dimension_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.death_dimension_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Respawn::~Respawn() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.Respawn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Respawn::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dimension_type_.Destroy();
  _impl_.dimension_name_.Destroy();
  _impl_.death_dimension_.Destroy();
  if (this != internal_default_instance()) delete _impl_.death_position_;
}

void Respawn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Respawn::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.Respawn)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dimension_type_.ClearToEmpty();
  _impl_.dimension_name_.ClearToEmpty();
  _impl_.death_dimension_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.death_position_ != nullptr);
    _impl_.death_position_->Clear();
  }
  ::memset(&_impl_.hashed_seed_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.has_death_location_) -
      reinterpret_cast<char*>(&_impl_.hashed_seed_)) + sizeof(_impl_.has_death_location_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Respawn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string dimension_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_dimension_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.Respawn.dimension_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string dimension_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dimension_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.Respawn.dimension_name"));
        } else {
          goto handle_unusual;
        }
        continue;
      // int64 hashed_seed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.hashed_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.GameMode game_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_game_mode(static_cast<::minecpp::proto::common::GameMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.GameMode previous_game_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_previous_game_mode(static_cast<::minecpp::proto::common::GameMode>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_debug = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.is_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool is_flat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.is_flat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool copy_metadata = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 64)) {
          _impl_.copy_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool has_death_location = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.has_death_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string death_dimension = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_death_dimension();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "minecpp.proto.event.clientbound.Respawn.death_dimension"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .minecpp.proto.common.Vector3 death_position = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_death_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Respawn::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.Respawn)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string dimension_type = 1;
  if (!this->_internal_dimension_type().empty()) {
    const std::string& _s = this->_internal_dimension_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.Respawn.dimension_type");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string dimension_name = 2;
  if (!this->_internal_dimension_name().empty()) {
    const std::string& _s = this->_internal_dimension_name();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.Respawn.dimension_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int64 hashed_seed = 3;
  if (this->_internal_hashed_seed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        3, this->_internal_hashed_seed(), target);
  }

  // .minecpp.proto.common.GameMode game_mode = 4;
  if (this->_internal_game_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_game_mode(), target);
  }

  // .minecpp.proto.common.GameMode previous_game_mode = 5;
  if (this->_internal_previous_game_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_previous_game_mode(), target);
  }

  // bool is_debug = 6;
  if (this->_internal_is_debug() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_is_debug(), target);
  }

  // bool is_flat = 7;
  if (this->_internal_is_flat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_flat(), target);
  }

  // bool copy_metadata = 8;
  if (this->_internal_copy_metadata() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_copy_metadata(), target);
  }

  // bool has_death_location = 9;
  if (this->_internal_has_death_location() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_has_death_location(), target);
  }

  // string death_dimension = 10;
  if (!this->_internal_death_dimension().empty()) {
    const std::string& _s = this->_internal_death_dimension();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "minecpp.proto.event.clientbound.Respawn.death_dimension");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.common.Vector3 death_position = 11;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::death_position(this),
        _Internal::death_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.Respawn)
  return target;
}

::size_t Respawn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.Respawn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string dimension_type = 1;
  if (!this->_internal_dimension_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_dimension_type());
  }

  // string dimension_name = 2;
  if (!this->_internal_dimension_name().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_dimension_name());
  }

  // string death_dimension = 10;
  if (!this->_internal_death_dimension().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_death_dimension());
  }

  // .minecpp.proto.common.Vector3 death_position = 11;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.death_position_);
  }

  // int64 hashed_seed = 3;
  if (this->_internal_hashed_seed() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_hashed_seed());
  }

  // .minecpp.proto.common.GameMode game_mode = 4;
  if (this->_internal_game_mode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_game_mode());
  }

  // .minecpp.proto.common.GameMode previous_game_mode = 5;
  if (this->_internal_previous_game_mode() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_previous_game_mode());
  }

  // bool is_debug = 6;
  if (this->_internal_is_debug() != 0) {
    total_size += 2;
  }

  // bool is_flat = 7;
  if (this->_internal_is_flat() != 0) {
    total_size += 2;
  }

  // bool copy_metadata = 8;
  if (this->_internal_copy_metadata() != 0) {
    total_size += 2;
  }

  // bool has_death_location = 9;
  if (this->_internal_has_death_location() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Respawn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Respawn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Respawn::GetClassData() const { return &_class_data_; }


void Respawn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Respawn*>(&to_msg);
  auto& from = static_cast<const Respawn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.Respawn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_dimension_type().empty()) {
    _this->_internal_set_dimension_type(from._internal_dimension_type());
  }
  if (!from._internal_dimension_name().empty()) {
    _this->_internal_set_dimension_name(from._internal_dimension_name());
  }
  if (!from._internal_death_dimension().empty()) {
    _this->_internal_set_death_dimension(from._internal_death_dimension());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_death_position()->::minecpp::proto::common::Vector3::MergeFrom(
        from._internal_death_position());
  }
  if (from._internal_hashed_seed() != 0) {
    _this->_internal_set_hashed_seed(from._internal_hashed_seed());
  }
  if (from._internal_game_mode() != 0) {
    _this->_internal_set_game_mode(from._internal_game_mode());
  }
  if (from._internal_previous_game_mode() != 0) {
    _this->_internal_set_previous_game_mode(from._internal_previous_game_mode());
  }
  if (from._internal_is_debug() != 0) {
    _this->_internal_set_is_debug(from._internal_is_debug());
  }
  if (from._internal_is_flat() != 0) {
    _this->_internal_set_is_flat(from._internal_is_flat());
  }
  if (from._internal_copy_metadata() != 0) {
    _this->_internal_set_copy_metadata(from._internal_copy_metadata());
  }
  if (from._internal_has_death_location() != 0) {
    _this->_internal_set_has_death_location(from._internal_has_death_location());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Respawn::CopyFrom(const Respawn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.Respawn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Respawn::IsInitialized() const {
  return true;
}

void Respawn::InternalSwap(Respawn* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dimension_type_, lhs_arena,
                                       &other->_impl_.dimension_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dimension_name_, lhs_arena,
                                       &other->_impl_.dimension_name_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.death_dimension_, lhs_arena,
                                       &other->_impl_.death_dimension_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Respawn, _impl_.has_death_location_)
      + sizeof(Respawn::_impl_.has_death_location_)
      - PROTOBUF_FIELD_OFFSET(Respawn, _impl_.death_position_)>(
          reinterpret_cast<char*>(&_impl_.death_position_),
          reinterpret_cast<char*>(&other->_impl_.death_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Respawn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[38]);
}
// ===================================================================

class SetAbilities::_Internal {
 public:
  using HasBits = decltype(std::declval<SetAbilities>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SetAbilities, _impl_._has_bits_);
  static const ::minecpp::proto::entity::Abilities& abilities(const SetAbilities* msg);
  static void set_has_abilities(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::minecpp::proto::entity::Abilities&
SetAbilities::_Internal::abilities(const SetAbilities* msg) {
  return *msg->_impl_.abilities_;
}
void SetAbilities::clear_abilities() {
  if (_impl_.abilities_ != nullptr) _impl_.abilities_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SetAbilities::SetAbilities(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:minecpp.proto.event.clientbound.SetAbilities)
}
SetAbilities::SetAbilities(const SetAbilities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetAbilities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abilities_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.abilities_ = new ::minecpp::proto::entity::Abilities(*from._impl_.abilities_);
  }
  // @@protoc_insertion_point(copy_constructor:minecpp.proto.event.clientbound.SetAbilities)
}

inline void SetAbilities::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.abilities_){nullptr}
  };
}

SetAbilities::~SetAbilities() {
  // @@protoc_insertion_point(destructor:minecpp.proto.event.clientbound.SetAbilities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetAbilities::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.abilities_;
}

void SetAbilities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetAbilities::Clear() {
// @@protoc_insertion_point(message_clear_start:minecpp.proto.event.clientbound.SetAbilities)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.abilities_ != nullptr);
    _impl_.abilities_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetAbilities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .minecpp.proto.entity.Abilities abilities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_abilities(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SetAbilities::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:minecpp.proto.event.clientbound.SetAbilities)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .minecpp.proto.entity.Abilities abilities = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::abilities(this),
        _Internal::abilities(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:minecpp.proto.event.clientbound.SetAbilities)
  return target;
}

::size_t SetAbilities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:minecpp.proto.event.clientbound.SetAbilities)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .minecpp.proto.entity.Abilities abilities = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.abilities_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetAbilities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetAbilities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetAbilities::GetClassData() const { return &_class_data_; }


void SetAbilities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetAbilities*>(&to_msg);
  auto& from = static_cast<const SetAbilities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:minecpp.proto.event.clientbound.SetAbilities)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_abilities()->::minecpp::proto::entity::Abilities::MergeFrom(
        from._internal_abilities());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetAbilities::CopyFrom(const SetAbilities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:minecpp.proto.event.clientbound.SetAbilities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetAbilities::IsInitialized() const {
  return true;
}

void SetAbilities::InternalSwap(SetAbilities* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.abilities_, other->_impl_.abilities_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetAbilities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_getter, &descriptor_table_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto_once,
      file_level_metadata_minecpp_2fproto_2fevent_2fclientbound_2fClientbound_2eproto[39]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace clientbound
}  // namespace event
}  // namespace proto
}  // namespace minecpp
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::Event*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::Event >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::RecipientSinglePlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::RecipientSinglePlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::RecipientSinglePlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::RecipientMultiplePlayers*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::RecipientMultiplePlayers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::RecipientMultiplePlayers >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::RecipientAllPlayers*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::RecipientAllPlayers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::RecipientAllPlayers >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::RecipientExcluding*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::RecipientExcluding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::RecipientExcluding >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::AddPlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::AddPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::AddPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SpawnEntity*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SpawnEntity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SpawnEntity >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SpawnPlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SpawnPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SpawnPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::EntityMove*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::EntityMove >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::EntityMove >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::EntityLook*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::EntityLook >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::EntityLook >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::PlayerPositionRotation*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::PlayerPositionRotation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::PlayerPositionRotation >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetSpawnPosition*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetSpawnPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetSpawnPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::Chat*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::Chat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::Chat >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::RemovePlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::RemovePlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::RemovePlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::UpdateBlock*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::UpdateBlock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::UpdateBlock >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::AnimateEntity*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::AnimateEntity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::AnimateEntity >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::AcknowledgeBlockChange*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::AcknowledgeBlockChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::AcknowledgeBlockChange >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::LoadTerrain*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::LoadTerrain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::LoadTerrain >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::TransferPlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::TransferPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::TransferPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::UpdatePlayerAbilities*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::UpdatePlayerAbilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::UpdatePlayerAbilities >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::UnloadChunk*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::UnloadChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::UnloadChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::PlayerList*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::PlayerList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::PlayerList >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::EntityList*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::EntityList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::EntityList >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetEntityVelocity*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetEntityVelocity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetEntityVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::AcceptPlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::AcceptPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::AcceptPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::DenyPlayer*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::DenyPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::DenyPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetInventorySlot*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetInventorySlot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetInventorySlot >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SectionBlockLight*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SectionBlockLight >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SectionBlockLight >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::ChunkBlockLight*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::ChunkBlockLight >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::ChunkBlockLight >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::UpdateBlockLight*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::UpdateBlockLight >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::UpdateBlockLight >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::ChunkData*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::ChunkData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::ChunkData >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetCenterChunk*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetCenterChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetCenterChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetEntityEquipment*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetEntityEquipment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetEntityEquipment >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetHealth*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetHealth >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetHealth >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::CollectItem*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::CollectItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::CollectItem >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::RemoveEntity*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::RemoveEntity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::RemoveEntity >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::TeleportEntity*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::TeleportEntity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::TeleportEntity >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::DisplayDeathScreen*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::DisplayDeathScreen >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::DisplayDeathScreen >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::Respawn*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::Respawn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::Respawn >(arena);
}
template<> PROTOBUF_NOINLINE ::minecpp::proto::event::clientbound::SetAbilities*
Arena::CreateMaybeMessage< ::minecpp::proto::event::clientbound::SetAbilities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::minecpp::proto::event::clientbound::SetAbilities >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
